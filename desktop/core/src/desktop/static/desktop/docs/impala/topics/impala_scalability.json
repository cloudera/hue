{"body":"<div><div id=\"scalability\"><div class=\"hue-doc-title\">Scalability Considerations for Impala</div><div><p>\n      This section explains how the size of your cluster and the volume of data influences SQL\n      performance and schema design for Impala tables. Typically, adding more cluster capacity\n      reduces problems due to memory limits or disk throughput. On the other hand, larger\n      clusters are more likely to have other kinds of scalability issues, such as a single slow\n      node that causes performance problems for queries.\n    </p><p/><p id=\"cookbook_blurb\">\n        A good source of tips related to scalability and performance tuning is the\n        <a class=\"hue-doc-external-link\" href=\"http://www.slideshare.net/cloudera/the-impala-cookbook-42530186\" target=\"_blank\">Impala\n        Cookbook</a> presentation. These slides are updated periodically as new features come\n        out and new benchmarks are performed.\n      </p></div><div style=\"display:none;\" id=\"scalability_memory\"><div class=\"hue-doc-title\">Overview and Guidelines for Impala Memory Usage</div><div><div class=\"hue-doc-codeblock\">Memory Usage – the Basics\n*  Memory is used by:\n*  Hash join – RHS tables after decompression, filtering and projection\n*  Group by – proportional to the #groups\n*  Parquet writer buffer – 1GB per partition\n*  IO buffer (shared across queries)\n*  Metadata cache (no more than 1GB typically)\n*  Memory held and reused by later query\n*  Impala releases memory from time to time starting in 1.4.\n\nMemory Usage – Estimating Memory Usage\n*  Use Explain Plan\n* Requires statistics! Mem estimate without stats is meaningless.\n* Reports per-host memory requirement for this cluster size.\n*  Re-run if you’ve re-sized the cluster!\n[image of explain plan]\n\nMemory Usage – Estimating Memory Usage\n*  EXPLAIN’s memory estimate issues\n*  Can be way off – much higher or much lower.\n*  group by’s estimate can be particularly off – when there’s a large number of group by columns.\n*  Mem estimate = NDV of group by column 1 * NDV of group by column 2 * ... NDV of group by column n\n*  Ignore EXPLAIN’s estimate if it’s too high! •  Do your own estimate for group by\n*  GROUP BY mem usage = (total number of groups * size of each row) + (total number of groups * size of each row) / num node\n\nMemory Usage – Finding Actual Memory Usage\n*  Search for “Per Node Peak Memory Usage” in the profile.\nThis is accurate. Use it for production capacity planning.\n\nMemory Usage – Actual Memory Usage\n*  For complex queries, how do I know which part of my query is using too much memory?\n*  Use the ExecSummary from the query profile!\n- But is that \"Peak Mem\" number aggregate or per-node?\n[image of executive summary]\n\nMemory Usage – Hitting Mem-limit\n*  Top causes (in order) of hitting mem-limit even when running a single query:\n1. Lack of statistics\n2. Lots of joins within a single query\n3. Big-table joining big-table\n4. Gigantic group by\n\nMemory Usage – Hitting Mem-limit\nLack of stats\n*  Wrong join order, wrong join strategy, wrong insert strategy\n*  Explain Plan tells you that!\n[image of explain plan]\n*  Fix: Compute Stats table\n\nMemory Usage – Hitting Mem-limit\nLots of joins within a single query\n* select...from fact, dim1, dim2,dim3,...dimN where ...\n* Each dim tbl can fit in memory, but not all of them together\n* As of Impala 1.4, Impala might choose the wrong plan – BROADCAST\nFIX 1: use shuffle hint\nselect ... from fact join [shuffle] dim1 on ... join dim2 [shuffle] ...\nFIX 2: pre-join the dim tables (if possible)\n- How about an example to illustrate that technique?\n* few join=&gt;better perf!\n\nMemory Usage: Hitting Mem-limit\nBig-table joining big-table\n*  Big-table (after decompression, filtering, and projection) is a table that is bigger than total cluster memory size.\n*  Impala 2.0 will do this (via disk-based join). Consider using Hive for now.\n*  (Advanced) For a simple query, you can try this advanced workaround – per-partition join\n*  Requires the partition key be part of the join key\nselect ... from BigTbl_A a join BigTbl_B b where a.part_key = b.part_key and a.part_key in (1,2,3)\n   union all\nselect ... from BigTbl_A a join BigTbl_B b where a.part_key = b.part_key and a.part_key in (4,5,6)\n\nMemory Usage: Hitting Mem-limit\nGigantic group by\n* The total number of distinct groups is huge, such as group by userid.\n* Impala 2.0 will do this (via disk-based agg). Consider using Hive for now.\n- Is this one of the cases where people were unhappy we recommended Hive?\n* (Advanced) For a simple query, you can try this advanced workaround – per-partition agg\n*  Requires the partition key be part of the group by\nselect part_key, col1, col2, ...agg(..) from tbl where\n       part_key in (1,2,3)\n       Union all\n       Select part_key, col1, col2, ...agg(..) from tbl where\n       part_key in (4,5,6)\n- But where's the GROUP BY in the preceding query? Need a real example.\n\nMemory Usage: Additional Notes\n*  Use explain plan for estimate; use profile for accurate measure\n*  Data skew can use uneven memory usage\n*  Review previous common issues on out-of-memory\n*  Note: Even with disk-based joins, you'll want to review these steps to speed up queries and use memory more efficiently\n</div></div></div><div id=\"scalability_catalog\"><div class=\"hue-doc-title\">Impact of Many Tables or Partitions on Impala Catalog Performance and Memory Usage</div><div><p>\n        Because Hadoop I/O is optimized for reading and writing large files, Impala is optimized\n        for tables containing relatively few, large data files. Schemas containing thousands of\n        tables, or tables containing thousands of partitions, can encounter performance issues\n        during startup or during DDL operations such as <span class=\"hue-doc-codeph\">ALTER TABLE</span> statements.\n      </p><div class=\"hue-doc-note\"><p>\n          Because of a change in the default heap size for the <span class=\"hue-doc-cmdname\">catalogd</span>\n          daemon in Impala 2.5 and higher, the following\n          procedure to increase the <span class=\"hue-doc-cmdname\">catalogd</span> memory limit might be required\n          following an upgrade to Impala 2.5 even if not needed\n          previously.\n        </p></div><p id=\"increase_catalogd_heap_size\">\n        For schemas with large numbers of tables, partitions, and data files, the\n        <span class=\"hue-doc-cmdname\">catalogd</span> daemon might encounter an out-of-memory error. To increase\n        the memory limit for the <span class=\"hue-doc-cmdname\">catalogd</span> daemon:\n        <ol><li><p>\n              Check current memory usage for the <span class=\"hue-doc-cmdname\">catalogd</span> daemon by running\n              the following commands on the host where that daemon runs on your cluster:\n            </p><div class=\"hue-doc-codeblock\">  jcmd <span class=\"hue-doc-varname\">catalogd_pid</span> VM.flags\n  jmap -heap <span class=\"hue-doc-varname\">catalogd_pid</span></div></li><li><p>\n              Decide on a large enough value for the <span class=\"hue-doc-cmdname\">catalogd</span> heap. You use\n              the <span class=\"hue-doc-codeph\">JAVA_TOOL_OPTIONS</span> environment variable to set the maximum\n              heap size. For example, the following environment variable setting specifies the\n              maximum heap size of 8 GB.\n            </p><div class=\"hue-doc-codeblock\">  JAVA_TOOL_OPTIONS=\"-Xmx8g\"\n  </div></li><li><p>\n              On systems not using cluster management software, put this environment variable\n              setting into the startup script for the <span class=\"hue-doc-cmdname\">catalogd</span> daemon, then\n              restart the <span class=\"hue-doc-cmdname\">catalogd</span> daemon.\n            </p></li><li><p>\n              Use the same <span class=\"hue-doc-cmdname\">jcmd</span> and <span class=\"hue-doc-cmdname\">jmap</span> commands as\n              earlier to verify that the new settings are in effect.\n            </p></li></ol></p></div></div><div id=\"statestore_scalability\"><div class=\"hue-doc-title\">Scalability Considerations for the Impala Statestore</div><div><p>\n        Before Impala 2.1, the statestore sent only one kind of message\n        to its subscribers. This message contained all updates for any topics that a subscriber\n        had subscribed to. It also served to let subscribers know that the statestore had not\n        failed, and conversely the statestore used the success of sending a heartbeat to a\n        subscriber to decide whether or not the subscriber had failed.\n      </p><p>\n        Combining topic updates and failure detection in a single message led to bottlenecks in\n        clusters with large numbers of tables, partitions, and HDFS data blocks. When the\n        statestore was overloaded with metadata updates to transmit, heartbeat messages were\n        sent less frequently, sometimes causing subscribers to time out their connection with\n        the statestore. Increasing the subscriber timeout and decreasing the frequency of\n        statestore heartbeats worked around the problem, but reduced responsiveness when the\n        statestore failed or restarted.\n      </p><p>\n        As of Impala 2.1, the statestore now sends topic updates and\n        heartbeats in separate messages. This allows the statestore to send and receive a steady\n        stream of lightweight heartbeats, and removes the requirement to send topic updates\n        according to a fixed schedule, reducing statestore network overhead.\n      </p><p>\n        The statestore now has the following relevant configuration flags for the\n        <span class=\"hue-doc-cmdname\">statestored</span> daemon:\n      </p><dl><dt id=\"statestore_num_update_threads\"><span class=\"hue-doc-codeph\">-statestore_num_update_threads</span></dt><dd>\n            The number of threads inside the statestore dedicated to sending topic updates. You\n            should not typically need to change this value.\n            <p><b>Default:</b> 10\n            </p></dd><dt id=\"statestore_update_frequency_ms\"><span class=\"hue-doc-codeph\">-statestore_update_frequency_ms</span></dt><dd>\n            The frequency, in milliseconds, with which the statestore tries to send topic\n            updates to each subscriber. This is a best-effort value; if the statestore is unable\n            to meet this frequency, it sends topic updates as fast as it can. You should not\n            typically need to change this value.\n            <p><b>Default:</b> 2000\n            </p></dd><dt id=\"statestore_num_heartbeat_threads\"><span class=\"hue-doc-codeph\">-statestore_num_heartbeat_threads</span></dt><dd>\n            The number of threads inside the statestore dedicated to sending heartbeats. You\n            should not typically need to change this value.\n            <p><b>Default:</b> 10\n            </p></dd><dt id=\"statestore_heartbeat_frequency_ms\"><span class=\"hue-doc-codeph\">-statestore_heartbeat_frequency_ms</span></dt><dd>\n            The frequency, in milliseconds, with which the statestore tries to send heartbeats\n            to each subscriber. This value should be good for large catalogs and clusters up to\n            approximately 150 nodes. Beyond that, you might need to increase this value to make\n            the interval longer between heartbeat messages.\n            <p><b>Default:</b> 1000 (one heartbeat message every second)\n            </p></dd><dt id=\"statestore_heartbeat_tcp_timeout_seconds\"><span class=\"hue-doc-codeph\">-statestore_heartbeat_tcp_timeout_seconds</span></dt><dd>\n            The time after which a heartbeat RPC to a subscriber will timeout. This setting\n            protects against badly hung machines that are not able to respond to the heartbeat\n            RPC in short order. Increase this if there are intermittent heartbeat RPC timeouts\n            shown in statestore's log. You can reference the max value of\n            \"statestore.priority-topic-update-durations\" metric on statestore to get a\n            reasonable value. Note that priority topic updates are assumed to be small amounts\n            of data that take a small amount of time to process (similar to the heartbeat\n            complexity).\n            <p><b>Default:</b> 3\n            </p></dd><dt id=\"statestore_max_missed_heartbeats\"><span class=\"hue-doc-codeph\">-statestore_max_missed_heartbeats</span></dt><dd>\n            Maximum number of consecutive heartbeat messages an impalad can miss before being\n            declared failed by the statestore. You should not typically need to change this\n            value.\n            <p><b>Default:</b> 10\n            </p></dd><dt id=\"statestore_subscriber_timeout_secs\"><span class=\"hue-doc-codeph\">-statestore_subscriber_timeout_secs</span></dt><dd>\n            The amount of time (in seconds) that may elapse before the connection with the\n            statestore is considered lost by subscribers (impalad/catalogd). Impalad will\n            reregister itself to statestore, which may cause its absence in the next round of\n            cluster membership update. This will cause query failures like \"Cancelled due to\n            unreachable impalad(s)\". The value of this flag should be comparable to\n            <span class=\"hue-doc-codeph\">\n            (statestore_heartbeat_frequency_ms / 1000 + statestore_heartbeat_tcp_timeout_seconds)\n            * statestore_max_missed_heartbeats</span>,\n            so subscribers won't reregister themselves too early and allow statestore to\n            resend heartbeats. You can also reference the max value of\n            \"statestore-subscriber.heartbeat-interval-time\" metrics on impalads to get a\n            reasonable value.\n            <p><b>Default:</b> 30\n            </p></dd></dl><p>\n        If it takes a very long time for a cluster to start up, and\n        <span class=\"hue-doc-cmdname\">impala-shell</span> consistently displays <span class=\"hue-doc-codeph\">This Impala daemon is not\n        ready to accept user requests</span>, the statestore might be taking too long to send\n        the entire catalog topic to the cluster. In this case, consider adding\n        <span class=\"hue-doc-codeph\">--load_catalog_in_background=false</span> to your catalog service\n        configuration. This setting stops the statestore from loading the entire catalog into\n        memory at cluster startup. Instead, metadata for each table is loaded when the table is\n        accessed for the first time.\n      </p></div></div><div id=\"scalability_buffer_pool\"><div class=\"hue-doc-title\">Effect of Buffer Pool on Memory Usage (Impala 2.10 and higher)</div><div><p>\n        The buffer pool feature, available in Impala 2.10 and higher, changes\n        the way Impala allocates memory during a query. Most of the memory needed is reserved at\n        the beginning of the query, avoiding cases where a query might run for a long time\n        before failing with an out-of-memory error. The actual memory estimates and memory\n        buffers are typically smaller than before, so that more queries can run concurrently or\n        process larger volumes of data than previously.\n      </p><p>\n        The buffer pool feature includes some query options that you can fine-tune:\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_buffer_pool_limit.xml\" data-doc-anchor-id=\"buffer_pool_limit\">BUFFER_POOL_LIMIT Query Option</a>,\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_default_spillable_buffer_size.xml\" data-doc-anchor-id=\"default_spillable_buffer_size\">DEFAULT_SPILLABLE_BUFFER_SIZE Query Option</a>,\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_max_row_size.xml\" data-doc-anchor-id=\"max_row_size\">MAX_ROW_SIZE Query Option</a>, and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_min_spillable_buffer_size.xml\" data-doc-anchor-id=\"min_spillable_buffer_size\">MIN_SPILLABLE_BUFFER_SIZE Query Option</a>.\n      </p><p>\n        Most of the effects of the buffer pool are transparent to you as an Impala user. Memory\n        use during spilling is now steadier and more predictable, instead of increasing rapidly\n        as more data is spilled to disk. The main change from a user perspective is the need to\n        increase the <span class=\"hue-doc-codeph\">MAX_ROW_SIZE</span> query option setting when querying tables\n        with columns containing long strings, many columns, or other combinations of factors\n        that produce very large rows. If Impala encounters rows that are too large to process\n        with the default query option settings, the query fails with an error message suggesting\n        to increase the <span class=\"hue-doc-codeph\">MAX_ROW_SIZE</span> setting.\n      </p></div></div><div style=\"display:none;\" id=\"scalability_cluster_size\"><div class=\"hue-doc-title\">Scalability Considerations for Impala Cluster Size and Topology</div><div><p/></div></div><div style=\"display:none;\" id=\"concurrent_connections\"><div class=\"hue-doc-title\">Scaling the Number of Concurrent Connections</div><div><p/></div></div><div id=\"spill_to_disk\"><div class=\"hue-doc-title\">SQL Operations that Spill to Disk</div><div><p>\n        Certain memory-intensive operations write temporary data to disk (known as\n        <span class=\"hue-doc-term\">spilling</span> to disk) when Impala is close to exceeding its memory limit on a\n        particular host.\n      </p><p>\n        The result is a query that completes successfully, rather than failing with an\n        out-of-memory error. The tradeoff is decreased performance due to the extra disk I/O to\n        write the temporary data and read it back in. The slowdown could be potentially be\n        significant. Thus, while this feature improves reliability, you should optimize your\n        queries, system parameters, and hardware configuration to make this spilling a rare\n        occurrence.\n      </p><div class=\"hue-doc-note\"><p>\n          In Impala 2.10 and higher, also see\n          <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_scalability.xml\" data-doc-anchor-id=\"scalability_buffer_pool\">Effect of Buffer Pool on Memory Usage (Impala 2.10 and higher)</a> for changes to Impala memory\n          allocation that might change the details of which queries spill to disk, and how much\n          memory and disk space is involved in the spilling operation.\n        </p></div><p><b>What kinds of queries might spill to disk:</b></p><p>\n        Several SQL clauses and constructs require memory allocations that could activat the\n        spilling mechanism:\n      </p><ul><li><p>\n            when a query uses a <span class=\"hue-doc-codeph\">GROUP BY</span> clause for columns with millions or\n            billions of distinct values, Impala keeps a similar number of temporary results in\n            memory, to accumulate the aggregate results for each value in the group.\n          </p></li><li><p>\n            When large tables are joined together, Impala keeps the values of the join columns\n            from one table in memory, to compare them to incoming values from the other table.\n          </p></li><li><p>\n            When a large result set is sorted by the <span class=\"hue-doc-codeph\">ORDER BY</span> clause, each node\n            sorts its portion of the result set in memory.\n          </p></li><li><p>\n            The <span class=\"hue-doc-codeph\">DISTINCT</span> and <span class=\"hue-doc-codeph\">UNION</span> operators build in-memory\n            data structures to represent all values found so far, to eliminate duplicates as the\n            query progresses.\n          </p></li></ul><p id=\"spill_to_disk_vs_dynamic_partition_pruning\">\n        When the spill-to-disk feature is activated for a join node within a query, Impala does\n        not produce any runtime filters for that join operation on that host. Other join nodes\n        within the query are not affected.\n      </p><p><b>How Impala handles scratch disk space for spilling:</b></p><p id=\"order_by_scratch_dir\"> By default, intermediate files used during\n        large sort, join, aggregation, or analytic function operations are\n        stored in the directory <span class=\"hue-doc-filepath\">/tmp/impala-scratch</span>, and\n        these intermediate files are removed when the operation finishes. You\n        can specify a different location by starting the\n          <span class=\"hue-doc-cmdname\">impalad</span> daemon with the\n            <span class=\"hue-doc-codeph\">‑‑scratch_dirs=\"<span class=\"hue-doc-varname\">path_to_directory</span>\"</span>\n        configuration option. </p><p><b>Memory usage for SQL operators:</b></p><p>\n        In Impala 2.10 and higher, the way SQL operators such as\n        <span class=\"hue-doc-codeph\">GROUP BY</span>, <span class=\"hue-doc-codeph\">DISTINCT</span>, and joins, transition between\n        using additional memory or activating the spill-to-disk feature is changed. The memory\n        required to spill to disk is reserved up front, and you can examine it in the\n        <span class=\"hue-doc-codeph\">EXPLAIN</span> plan when the <span class=\"hue-doc-codeph\">EXPLAIN_LEVEL</span> query option is\n        set to 2 or higher.\n      </p><p>\n        The infrastructure of the spilling feature affects the way the affected SQL operators,\n        such as <span class=\"hue-doc-codeph\">GROUP BY</span>, <span class=\"hue-doc-codeph\">DISTINCT</span>, and joins, use memory. On\n        each host that participates in the query, each such operator in a query requires memory\n        to store rows of data and other data structures. Impala reserves a certain amount of\n        memory up front for each operator that supports spill-to-disk that is sufficient to\n        execute the operator. If an operator accumulates more data than can fit in the reserved\n        memory, it can either reserve more memory to continue processing data in memory or start\n        spilling data to temporary scratch files on disk. Thus, operators with spill-to-disk\n        support can adapt to different memory constraints by using however much memory is\n        available to speed up execution, yet tolerate low memory conditions by spilling data to\n        disk.\n      </p><p>\n        The amount data depends on the portion of the data being handled by that host, and thus\n        the operator may end up consuming different amounts of memory on different hosts.\n      </p><p><b>Added in:</b> This feature was added to the <span class=\"hue-doc-codeph\">ORDER BY</span> clause in\n        Impala 1.4. This feature was extended to cover join queries, aggregation functions, and\n        analytic functions in Impala 2.0. The size of the memory work area required by each\n        operator that spills was reduced from 512 megabytes to 256 megabytes in Impala 2.2.\n        <span class=\"hue-doc-ph\">The spilling mechanism was reworked to take\n        advantage of the Impala buffer pool feature and be more predictable and stable in\n        Impala 2.10.</span></p><p><b>Avoiding queries that spill to disk:</b></p><p>\n        Because the extra I/O can impose significant performance overhead on these types of\n        queries, try to avoid this situation by using the following steps:\n      </p><ol><li>\n          Detect how often queries spill to disk, and how much temporary data is written. Refer\n          to the following sources:\n          <ul><li>\n              The output of the <span class=\"hue-doc-codeph\">PROFILE</span> command in the\n              <span class=\"hue-doc-cmdname\">impala-shell</span> interpreter. This data shows the memory usage for\n              each host and in total across the cluster. The <span class=\"hue-doc-codeph\">WriteIoBytes</span>\n              counter reports how much data was written to disk for each operator during the\n              query. (In Impala 2.9, the counter was\n              named <span class=\"hue-doc-codeph\">ScratchBytesWritten</span>; in\n              Impala 2.8 and earlier, it was named\n              <span class=\"hue-doc-codeph\">BytesWritten</span>.)\n            </li><li>\n              The <div class=\"hue-doc-uicontrol\">Queries</div> tab in the Impala debug web user interface.\n              Select the query to examine and click the corresponding\n              <div class=\"hue-doc-uicontrol\">Profile</div> link. This data breaks down the memory usage for a\n              single host within the cluster, the host whose web interface you are connected to.\n            </li></ul></li><li>\n          Use one or more techniques to reduce the possibility of the queries spilling to disk:\n          <ul><li>\n              Increase the Impala memory limit if practical, for example, if you can increase\n              the available memory by more than the amount of temporary data written to disk on\n              a particular node. Remember that in Impala 2.0 and later, you can issue\n              <span class=\"hue-doc-codeph\">SET MEM_LIMIT</span> as a SQL statement, which lets you fine-tune the\n              memory usage for queries from JDBC and ODBC applications.\n            </li><li>\n              Increase the number of nodes in the cluster, to increase the aggregate memory\n              available to Impala and reduce the amount of memory required on each node.\n            </li><li>\n              Add more memory to the hosts running Impala daemons.\n            </li><li>\n              On a cluster with resources shared between Impala and other Hadoop components, use\n              resource management features to allocate more memory for Impala. See\n              <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_resource_management.xml\" data-doc-anchor-id=\"resource_management\">Resource Management</a>\n              for details.\n            </li><li>\n              If the memory pressure is due to running many concurrent queries rather than a few\n              memory-intensive ones, consider using the Impala admission control feature to\n              lower the limit on the number of concurrent queries. By spacing out the most\n              resource-intensive queries, you can avoid spikes in memory usage and improve\n              overall response times. See\n              <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_admission.xml\" data-doc-anchor-id=\"admission_control\">Admission Control and Query Queuing</a> for details.\n            </li><li>\n              Tune the queries with the highest memory requirements, using one or more of the\n              following techniques:\n              <ul><li>\n                  Run the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement for all tables involved in\n                  large-scale joins and aggregation queries.\n                </li><li>\n                  Minimize your use of <span class=\"hue-doc-codeph\">STRING</span> columns in join columns. Prefer\n                  numeric values instead.\n                </li><li>\n                  Examine the <span class=\"hue-doc-codeph\">EXPLAIN</span> plan to understand the execution strategy\n                  being used for the most resource-intensive queries. See\n                  <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_explain_plan.xml\" data-doc-anchor-id=\"perf_explain\">Using the EXPLAIN Plan for Performance Tuning</a> for\n                  details.\n                </li><li>\n                  If Impala still chooses a suboptimal execution strategy even with statistics\n                  available, or if it is impractical to keep the statistics up to date for huge\n                  or rapidly changing tables, add hints to the most resource-intensive queries\n                  to select the right execution strategy. See\n                  <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_hints.xml\" data-doc-anchor-id=\"hints\">Optimizer Hints</a> for details.\n                </li></ul></li><li>\n              If your queries experience substantial performance overhead due to spilling,\n              enable the <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> query option. This option\n              prevents queries whose memory usage is likely to be exorbitant from spilling to\n              disk. See\n              <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_disable_unsafe_spills.xml\" data-doc-anchor-id=\"disable_unsafe_spills\">DISABLE_UNSAFE_SPILLS Query Option (Impala 2.0 or higher only)</a>\n              for details. As you tune problematic queries using the preceding steps, fewer and\n              fewer will be cancelled by this option setting.\n            </li></ul></li></ol><p><b>Testing performance implications of spilling to disk:</b></p><p>\n        To artificially provoke spilling, to test this feature and understand the performance\n        implications, use a test environment with a memory limit of at least 2 GB. Issue the\n        <span class=\"hue-doc-codeph\">SET</span> command with no arguments to check the current setting for the\n        <span class=\"hue-doc-codeph\">MEM_LIMIT</span> query option. Set the query option\n        <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS=true</span>. This option limits the spill-to-disk\n        feature to prevent runaway disk usage from queries that are known in advance to be\n        suboptimal. Within <span class=\"hue-doc-cmdname\">impala-shell</span>, run a query that you expect to be\n        memory-intensive, based on the criteria explained earlier. A self-join of a large table\n        is a good candidate:\n      </p><div class=\"hue-doc-codeblock\">select count(*) from big_table a join big_table b using (column_with_many_values);\n</div><p>\n        Issue the <span class=\"hue-doc-codeph\">PROFILE</span> command to get a detailed breakdown of the memory\n        usage on each node during the query.\n</p><p>\n        Set the <span class=\"hue-doc-codeph\">MEM_LIMIT</span> query option to a value that is smaller than the peak\n        memory usage reported in the profile output. Now try the memory-intensive query again.\n      </p><p>\n        Check if the query fails with a message like the following:\n      </p><div class=\"hue-doc-codeblock\">WARNINGS: Spilling has been disabled for plans that do not have stats and are not hinted\nto prevent potentially bad plans from using too many cluster resources. Compute stats on\nthese tables, hint the plan or disable this behavior via query options to enable spilling.\n</div><p>\n        If so, the query could have consumed substantial temporary disk space, slowing down so\n        much that it would not complete in any reasonable time. Rather than rely on the\n        spill-to-disk feature in this case, issue the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement\n        for the table or tables in your sample query. Then run the query again, check the peak\n        memory usage again in the <span class=\"hue-doc-codeph\">PROFILE</span> output, and adjust the memory limit\n        again if necessary to be lower than the peak memory usage.\n      </p><p>\n        At this point, you have a query that is memory-intensive, but Impala can optimize it\n        efficiently so that the memory usage is not exorbitant. You have set an artificial\n        constraint through the <span class=\"hue-doc-codeph\">MEM_LIMIT</span> option so that the query would\n        normally fail with an out-of-memory error. But the automatic spill-to-disk feature means\n        that the query should actually succeed, at the expense of some extra disk I/O to read\n        and write temporary work data.\n      </p><p>\n        Try the query again, and confirm that it succeeds. Examine the <span class=\"hue-doc-codeph\">PROFILE</span>\n        output again. This time, look for lines of this form:\n      </p><div class=\"hue-doc-codeblock\">- SpilledPartitions: <span class=\"hue-doc-varname\">N</span></div><p>\n        If you see any such lines with <span class=\"hue-doc-varname\">N</span> greater than 0, that indicates the\n        query would have failed in Impala releases prior to 2.0, but now it succeeded because of\n        the spill-to-disk feature. Examine the total time taken by the\n        <span class=\"hue-doc-codeph\">AGGREGATION_NODE</span> or other query fragments containing non-zero\n        <span class=\"hue-doc-codeph\">SpilledPartitions</span> values. Compare the times to similar fragments that\n        did not spill, for example in the <span class=\"hue-doc-codeph\">PROFILE</span> output when the same query is\n        run with a higher memory limit. This gives you an idea of the performance penalty of the\n        spill operation for a particular query with a particular memory limit. If you make the\n        memory limit just a little lower than the peak memory usage, the query only needs to\n        write a small amount of temporary data to disk. The lower you set the memory limit, the\n        more temporary data is written and the slower the query becomes.\n      </p><p>\n        Now repeat this procedure for actual queries used in your environment. Use the\n        <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> setting to identify cases where queries used more\n        memory than necessary due to lack of statistics on the relevant tables and columns, and\n        issue <span class=\"hue-doc-codeph\">COMPUTE STATS</span> where necessary.\n      </p><p><b>When to use DISABLE_UNSAFE_SPILLS:</b></p><p>\n        You might wonder, why not leave <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> turned on all the\n        time. Whether and how frequently to use this option depends on your system environment\n        and workload.\n      </p><p><span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> is suitable for an environment with ad hoc\n        queries whose performance characteristics and memory usage are not known in advance. It\n        prevents <q>worst-case scenario</q> queries that use large amounts of memory\n        unnecessarily. Thus, you might turn this option on within a session while developing new\n        SQL code, even though it is turned off for existing applications.\n      </p><p>\n        Organizations where table and column statistics are generally up-to-date might leave\n        this option turned on all the time, again to avoid worst-case scenarios for untested\n        queries or if a problem in the ETL pipeline results in a table with no statistics.\n        Turning on <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> lets you <q>fail fast</q> in this case\n        and immediately gather statistics or tune the problematic queries.\n      </p><p>\n        Some organizations might leave this option turned off. For example, you might have\n        tables large enough that the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> takes substantial time to\n        run, making it impractical to re-run after loading new data. If you have examined the\n        <span class=\"hue-doc-codeph\">EXPLAIN</span> plans of your queries and know that they are operating\n        efficiently, you might leave <span class=\"hue-doc-codeph\">DISABLE_UNSAFE_SPILLS</span> turned off. In that\n        case, you know that any queries that spill will not go overboard with their memory\n        consumption.\n      </p></div></div><div id=\"complex_query\"><div class=\"hue-doc-title\">Limits on Query Size and Complexity</div><div><p>\n        There are hardcoded limits on the maximum size and complexity of queries. Currently, the\n        maximum number of expressions in a query is 2000. You might exceed the limits with large\n        or deeply nested queries produced by business intelligence tools or other query\n        generators.\n      </p><p>\n        If you have the ability to customize such queries or the query generation logic that\n        produces them, replace sequences of repetitive expressions with single operators such as\n        <span class=\"hue-doc-codeph\">IN</span> or <span class=\"hue-doc-codeph\">BETWEEN</span> that can represent multiple values or\n        ranges. For example, instead of a large number of <span class=\"hue-doc-codeph\">OR</span> clauses:\n      </p><div class=\"hue-doc-codeblock\">WHERE val = 1 OR val = 2 OR val = 6 OR val = 100 ...\n</div><p>\n        use a single <span class=\"hue-doc-codeph\">IN</span> clause:\n      </p><div class=\"hue-doc-codeblock\">WHERE val IN (1,2,6,100,...)</div></div></div><div id=\"scalability_io\"><div class=\"hue-doc-title\">Scalability Considerations for Impala I/O</div><div><p>\n        Impala parallelizes its I/O operations aggressively, therefore the more disks you can\n        attach to each host, the better. Impala retrieves data from disk so quickly using bulk\n        read operations on large blocks, that most queries are CPU-bound rather than I/O-bound.\n      </p><p>\n        Because the kind of sequential scanning typically done by Impala queries does not\n        benefit much from the random-access capabilities of SSDs, spinning disks typically\n        provide the most cost-effective kind of storage for Impala data, with little or no\n        performance penalty as compared to SSDs.\n      </p><p>\n        Resource management features such as YARN, Llama, and admission control typically\n        constrain the amount of memory, CPU, or overall number of queries in a high-concurrency\n        environment. Currently, there is no throttling mechanism for Impala I/O.\n      </p></div></div><div id=\"big_tables\"><div class=\"hue-doc-title\">Scalability Considerations for Table Layout</div><div><p>\n        Due to the overhead of retrieving and updating table metadata in the metastore database,\n        try to limit the number of columns in a table to a maximum of approximately 2000.\n        Although Impala can handle wider tables than this, the metastore overhead can become\n        significant, leading to query performance that is slower than expected based on the\n        actual data volume.\n      </p><p>\n        To minimize overhead related to the metastore database and Impala query planning, try to\n        limit the number of partitions for any partitioned table to a few tens of thousands.\n      </p><p>\n        If the volume of data within a table makes it impractical to run exploratory queries,\n        consider using the <span class=\"hue-doc-codeph\">TABLESAMPLE</span> clause to limit query processing to only\n        a percentage of data within the table. This technique reduces the overhead for query\n        startup, I/O to read the data, and the amount of network, CPU, and memory needed to\n        process intermediate results during the query. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tablesample.xml\" data-doc-anchor-id=\"tablesample\">TABLESAMPLE Clause</a> for\n        details.\n      </p></div></div><div id=\"kerberos_overhead_cluster_size\"><div class=\"hue-doc-title\">Kerberos-Related Network Overhead for Large Clusters</div><div><p>\n        When Impala starts up, or after each <span class=\"hue-doc-codeph\">kinit</span> refresh, Impala sends a\n        number of simultaneous requests to the KDC. For a cluster with 100 hosts, the KDC might\n        be able to process all the requests within roughly 5 seconds. For a cluster with 1000\n        hosts, the time to process the requests would be roughly 500 seconds. Impala also makes\n        a number of DNS requests at the same time as these Kerberos-related requests.\n      </p><p>\n        While these authentication requests are being processed, any submitted Impala queries\n        will fail. During this period, the KDC and DNS may be slow to respond to requests from\n        components other than Impala, so other secure services might be affected temporarily.\n      </p><p>\n        In Impala 2.12 or earlier, to reduce the frequency of the\n        <span class=\"hue-doc-codeph\">kinit</span> renewal that initiates a new set of authentication requests,\n        increase the <span class=\"hue-doc-codeph\">kerberos_reinit_interval</span> configuration setting for the\n        <span class=\"hue-doc-codeph\">impalad</span> daemons. Currently, the default is 60 minutes. Consider using a\n        higher value such as 360 (6 hours).\n      </p><p>\n        The <span class=\"hue-doc-codeph\">kerberos_reinit_interval</span> configuration setting is removed in\n        Impala 3.0, and the above step is no longer needed.\n      </p></div></div><div id=\"scalability_hotspots\"><div class=\"hue-doc-title\">Avoiding CPU Hotspots for HDFS Cached Data</div><div><p>\n        You can use the HDFS caching feature, described in\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_perf_hdfs_caching.xml\" data-doc-anchor-id=\"hdfs_caching\">Using HDFS Caching with Impala (Impala 2.1 or higher only)</a>, with Impala to\n        reduce I/O and memory-to-memory copying for frequently accessed tables or partitions.\n      </p><p>\n        In the early days of this feature, you might have found that enabling HDFS caching\n        resulted in little or no performance improvement, because it could result in\n        <q>hotspots</q>: instead of the I/O to read the table data being parallelized across the\n        cluster, the I/O was reduced but the CPU load to process the data blocks might be\n        concentrated on a single host.\n      </p><p>\n        To avoid hotspots, include the <span class=\"hue-doc-codeph\">WITH REPLICATION</span> clause with the\n        <span class=\"hue-doc-codeph\">CREATE TABLE</span> or <span class=\"hue-doc-codeph\">ALTER TABLE</span> statements for tables that\n        use HDFS caching. This clause allows more than one host to cache the relevant data\n        blocks, so the CPU load can be shared, reducing the load on any one host. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a> and\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_alter_table.xml\" data-doc-anchor-id=\"alter_table\">ALTER TABLE Statement</a> for details.\n      </p><p>\n        Hotspots with high CPU load for HDFS cached data could still arise in some cases, due to\n        the way that Impala schedules the work of processing data blocks on different hosts. In\n        Impala 2.5 and higher, scheduling improvements mean that the work\n        for HDFS cached data is divided better among all the hosts that have cached replicas for\n        a particular data block. When more than one host has a cached replica for a data block,\n        Impala assigns the work of processing that block to whichever host has done the least\n        work (in terms of number of bytes read) for the current query. If hotspots persist even\n        with this load-based scheduling algorithm, you can enable the query option\n        <span class=\"hue-doc-codeph\">SCHEDULE_RANDOM_REPLICA=TRUE</span> to further distribute the CPU load. This\n        setting causes Impala to randomly pick a host to process a cached data block if the\n        scheduling algorithm encounters a tie when deciding which host has done the least work.\n      </p></div></div><div id=\"scalability_file_handle_cache\"><div class=\"hue-doc-title\">Scalability Considerations for File Handle Caching</div><div><p>\n        One scalability aspect that affects heavily loaded clusters is the load on the metadata\n        layer from looking up the details as each file is opened. On HDFS, that can lead to\n        increased load on the NameNode, and on S3, this can lead to an excessive number of S3\n        metadata requests. For example, a query that does a full table scan on a partitioned\n        table may need to read thousands of partitions, each partition containing multiple data\n        files. Accessing each column of a Parquet file also involves a separate <q>open</q>\n        call, further increasing the load on the NameNode. High NameNode overhead can add\n        startup time (that is, increase latency) to Impala queries, and reduce overall\n        throughput for non-Impala workloads that also require accessing HDFS files.\n      </p><p>\n        You can reduce the number of calls made to your file system's metadata layer by enabling\n        the file handle caching feature. Data files that are accessed by different queries, or\n        even multiple times within the same query, can be accessed without a new <q>open</q>\n        call and without fetching the file details multiple times.\n      </p><p>\n        Impala supports file handle caching for the following file systems:\n        <ul><li>\n            HDFS in Impala 2.10 and higher\n            <p>\n              In Impala 3.2 and higher, file handle caching also applies to remote HDFS file\n              handles. This is controlled by the <span class=\"hue-doc-codeph\">cache_remote_file_handles</span> flag\n              for an <span class=\"hue-doc-codeph\">impalad</span>. It is recommended that you use the default value\n              of <span class=\"hue-doc-codeph\">true</span> as this caching prevents your NameNode from overloading\n              when your cluster has many remote HDFS reads.\n            </p></li><li>\n            S3 in Impala 3.3 and higher\n            <p>\n              The <span class=\"hue-doc-codeph\">cache_s3_file_handles</span><span class=\"hue-doc-codeph\">impalad</span> flag controls\n              the S3 file handle caching. The feature is enabled by default with the flag set to\n              <span class=\"hue-doc-codeph\">true</span>.\n            </p></li></ul></p><p>\n        The feature is enabled by default with 20,000 file handles to be cached. To change the\n        value, set the configuration option <span class=\"hue-doc-codeph\">max_cached_file_handles</span> to a\n        non-zero value for each <span class=\"hue-doc-cmdname\">impalad</span> daemon. From the initial default\n        value of 20000, adjust upward if NameNode request load is still significant, or downward\n        if it is more important to reduce the extra memory usage on each host. Each cache entry\n        consumes 6 KB, meaning that caching 20,000 file handles requires up to 120 MB on each\n        Impala executor. The exact memory usage varies depending on how many file handles have\n        actually been cached; memory is freed as file handles are evicted from the cache.\n      </p><p>\n        If a manual operation moves a file to the trashcan while the file handle is cached,\n        Impala still accesses the contents of that file. This is a change from prior behavior.\n        Previously, accessing a file that was in the trashcan would cause an error. This\n        behavior only applies to non-Impala methods of removing files, not the Impala mechanisms\n        such as <span class=\"hue-doc-codeph\">TRUNCATE TABLE</span> or <span class=\"hue-doc-codeph\">DROP TABLE</span>.\n      </p><p>\n        If files are removed, replaced, or appended by operations outside of Impala, the way to\n        bring the file information up to date is to run the <span class=\"hue-doc-codeph\">REFRESH</span> statement\n        on the table.\n      </p><p>\n        File handle cache entries are evicted as the cache fills up, or based on a timeout\n        period when they have not been accessed for some time.\n      </p><p>\n        To evaluate the effectiveness of file handle caching for a particular workload, issue\n        the <span class=\"hue-doc-codeph\">PROFILE</span> statement in <span class=\"hue-doc-cmdname\">impala-shell</span> or examine\n        query profiles in the Impala Web UI. Look for the ratio of\n        <span class=\"hue-doc-codeph\">CachedFileHandlesHitCount</span> (ideally, should be high) to\n        <span class=\"hue-doc-codeph\">CachedFileHandlesMissCount</span> (ideally, should be low). Before starting\n        any evaluation, run several representative queries to <q>warm up</q> the cache because\n        the first time each data file is accessed is always recorded as a cache miss.\n      </p><p>\n        To see metrics about file handle caching for each <span class=\"hue-doc-cmdname\">impalad</span> instance,\n        examine the following fields on the <div class=\"hue-doc-uicontrol\">/metrics</div> page in the Impala\n        Web UI:\n      </p><ul><li><div class=\"hue-doc-uicontrol\">impala-server.io.mgr.cached-file-handles-miss-count</div></li><li><div class=\"hue-doc-uicontrol\">impala-server.io.mgr.num-cached-file-handles</div></li></ul></div></div></div></div>","title":"Scalability Considerations for Impala"}