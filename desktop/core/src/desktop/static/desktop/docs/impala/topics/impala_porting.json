{"body":"<div><div id=\"porting\"><div class=\"hue-doc-title\">Porting SQL from Other Database Systems to Impala</div><div><p> Although Impala uses standard SQL for queries, you might need to modify\n      SQL source when bringing applications to Impala, due to variations in data\n      types, built-in functions, vendor language extensions, and Hadoop-specific\n      syntax. Even when SQL is working correctly, you might make further minor\n      modifications for best performance. </p><p/></div><div id=\"porting_ddl_dml\"><div class=\"hue-doc-title\">Porting DDL and DML Statements</div><div><p>\n        When adapting SQL code from a traditional database system to Impala, expect to find a number of differences\n        in the DDL statements that you use to set up the schema. Clauses related to physical layout of files,\n        tablespaces, and indexes have no equivalent in Impala. You might restructure your schema considerably to\n        account for the Impala partitioning scheme and Hadoop file formats.\n      </p><p>\n        Expect SQL queries to have a much higher degree of compatibility. With modest rewriting to address vendor\n        extensions and features not yet supported in Impala, you might be able to run identical or almost-identical\n        query text on both systems.\n      </p><p>\n        Therefore, consider separating out the DDL into a separate Impala-specific setup script. Focus your reuse\n        and ongoing tuning efforts on the code for SQL queries.\n      </p></div></div><div id=\"porting_data_types\"><div class=\"hue-doc-title\">Porting Data Types from Other Database Systems</div><div><ul><li><p>\n            Change any <span class=\"hue-doc-codeph\">VARCHAR</span>, <span class=\"hue-doc-codeph\">VARCHAR2</span>, and <span class=\"hue-doc-codeph\">CHAR</span> columns to\n            <span class=\"hue-doc-codeph\">STRING</span>. Remove any length constraints from the column declarations; for example,\n            change <span class=\"hue-doc-codeph\">VARCHAR(32)</span> or <span class=\"hue-doc-codeph\">CHAR(1)</span> to <span class=\"hue-doc-codeph\">STRING</span>. Impala is\n            very flexible about the length of string values; it does not impose any length constraints\n            or do any special processing (such as blank-padding) for <span class=\"hue-doc-codeph\">STRING</span> columns.\n            (In Impala 2.0 and higher, there are data types <span class=\"hue-doc-codeph\">VARCHAR</span> and <span class=\"hue-doc-codeph\">CHAR</span>,\n            with length constraints for both types and blank-padding for <span class=\"hue-doc-codeph\">CHAR</span>.\n            However, for performance reasons, it is still preferable to use <span class=\"hue-doc-codeph\">STRING</span>\n            columns where practical.)\n          </p></li><li><p>\n            For national language character types such as <span class=\"hue-doc-codeph\">NCHAR</span>, <span class=\"hue-doc-codeph\">NVARCHAR</span>, or\n            <span class=\"hue-doc-codeph\">NCLOB</span>, be aware that while Impala can store and query UTF-8 character data, currently\n            some string manipulation operations only work correctly with ASCII data. See\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_string.xml\" data-doc-anchor-id=\"string\">STRING Data Type</a> for details.\n          </p></li><li><p>\n            Change any <span class=\"hue-doc-codeph\">DATE</span>, <span class=\"hue-doc-codeph\">DATETIME</span>, or <span class=\"hue-doc-codeph\">TIME</span> columns to\n            <span class=\"hue-doc-codeph\">TIMESTAMP</span>. Remove any precision constraints. Remove any timezone clauses, and make\n            sure your application logic or ETL process accounts for the fact that Impala expects all\n            <span class=\"hue-doc-codeph\">TIMESTAMP</span> values to be in\n            <a class=\"hue-doc-external-link\" href=\"http://en.wikipedia.org/wiki/Coordinated_Universal_Time\" target=\"_blank\">Coordinated\n            Universal Time (UTC)</a>. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_timestamp.xml\" data-doc-anchor-id=\"timestamp\">TIMESTAMP Data Type</a> for information about\n            the <span class=\"hue-doc-codeph\">TIMESTAMP</span> data type, and\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datetime_functions.xml\" data-doc-anchor-id=\"datetime_functions\">Impala Date and Time Functions</a> for conversion functions for different\n            date and time formats.\n          </p><p>\n            You might also need to adapt date- and time-related literal values and format strings to use the\n            supported Impala date and time formats. If you have date and time literals with different separators or\n            different numbers of <span class=\"hue-doc-codeph\">YY</span>, <span class=\"hue-doc-codeph\">MM</span>, and so on placeholders than Impala\n            expects, consider using calls to <span class=\"hue-doc-codeph\">regexp_replace()</span> to transform those values to the\n            Impala-compatible format. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_timestamp.xml\" data-doc-anchor-id=\"timestamp\">TIMESTAMP Data Type</a> for information about the\n            allowed formats for date and time literals, and\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_string_functions.xml\" data-doc-anchor-id=\"string_functions\">Impala String Functions</a> for string conversion functions such as\n            <span class=\"hue-doc-codeph\">regexp_replace()</span>.\n          </p><p>\n            Instead of <span class=\"hue-doc-codeph\">SYSDATE</span>, call the function <span class=\"hue-doc-codeph\">NOW()</span>.\n          </p><p>\n            Instead of adding or subtracting directly from a date value to produce a value <span class=\"hue-doc-varname\">N</span>\n            days in the past or future, use an <span class=\"hue-doc-codeph\">INTERVAL</span> expression, for example <span class=\"hue-doc-codeph\">NOW() +\n            INTERVAL 30 DAYS</span>.\n          </p></li><li><p>\n            Although Impala supports <span class=\"hue-doc-codeph\">INTERVAL</span> expressions for datetime arithmetic, as shown in\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_timestamp.xml\" data-doc-anchor-id=\"timestamp\">TIMESTAMP Data Type</a>, <span class=\"hue-doc-codeph\">INTERVAL</span> is not available as a column\n            data type in Impala. For any <span class=\"hue-doc-codeph\">INTERVAL</span> values stored in tables, convert them to numeric\n            values that you can add or subtract using the functions in\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datetime_functions.xml\" data-doc-anchor-id=\"datetime_functions\">Impala Date and Time Functions</a>. For example, if you had a table\n            <span class=\"hue-doc-codeph\">DEADLINES</span> with an <span class=\"hue-doc-codeph\">INT</span> column <span class=\"hue-doc-codeph\">TIME_PERIOD</span>, you could\n            construct dates N days in the future like so:\n          </p><div class=\"hue-doc-codeblock\">SELECT NOW() + INTERVAL time_period DAYS from deadlines;</div></li><li><p>\n            For <span class=\"hue-doc-codeph\">YEAR</span> columns, change to the smallest Impala integer type that has sufficient\n            range. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for details about ranges, casting, and so on\n            for the various numeric data types.\n          </p></li><li><p>\n            Change any <span class=\"hue-doc-codeph\">DECIMAL</span> and <span class=\"hue-doc-codeph\">NUMBER</span> types. If fixed-point precision is not\n            required, you can use <span class=\"hue-doc-codeph\">FLOAT</span> or <span class=\"hue-doc-codeph\">DOUBLE</span> on the Impala side depending on\n            the range of values. For applications that require precise decimal values, such as financial data, you\n            might need to make more extensive changes to table structure and application logic, such as using\n            separate integer columns for dollars and cents, or encoding numbers as string values and writing UDFs\n            to manipulate them. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for details about ranges,\n            casting, and so on for the various numeric data types.\n          </p></li><li><p><span class=\"hue-doc-codeph\">FLOAT</span>, <span class=\"hue-doc-codeph\">DOUBLE</span>, and <span class=\"hue-doc-codeph\">REAL</span> types are supported in\n            Impala. Remove any precision and scale specifications. (In Impala, <span class=\"hue-doc-codeph\">REAL</span> is just an\n            alias for <span class=\"hue-doc-codeph\">DOUBLE</span>; columns declared as <span class=\"hue-doc-codeph\">REAL</span> are turned into\n            <span class=\"hue-doc-codeph\">DOUBLE</span> behind the scenes.) See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for\n            details about ranges, casting, and so on for the various numeric data types.\n          </p></li><li><p>\n            Most integer types from other systems have equivalents in Impala, perhaps under different names such as\n            <span class=\"hue-doc-codeph\">BIGINT</span> instead of <span class=\"hue-doc-codeph\">INT8</span>. For any that are unavailable, for example\n            <span class=\"hue-doc-codeph\">MEDIUMINT</span>, switch to the smallest Impala integer type that has sufficient range.\n            Remove any precision specifications. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for details\n            about ranges, casting, and so on for the various numeric data types.\n          </p></li><li><p>\n            Remove any <span class=\"hue-doc-codeph\">UNSIGNED</span> constraints. All Impala numeric types are signed. See\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for details about ranges, casting, and so on for the\n            various numeric data types.\n          </p></li><li><p>\n            For any types holding bitwise values, use an integer type with enough range to hold all the relevant\n            bits within a positive integer. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datatypes.xml\" data-doc-anchor-id=\"datatypes\">Data Types</a> for details about\n            ranges, casting, and so on for the various numeric data types.\n          </p><p>\n            For example, <span class=\"hue-doc-codeph\">TINYINT</span> has a maximum positive value of 127, not 256, so to manipulate\n            8-bit bitfields as positive numbers switch to the next largest type <span class=\"hue-doc-codeph\">SMALLINT</span>.\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select cast(127*2 as tinyint);\n+--------------------------+\n| cast(127 * 2 as tinyint) |\n+--------------------------+\n| -2                       |\n+--------------------------+\n[localhost:21000] &gt; select cast(128 as tinyint);\n+----------------------+\n| cast(128 as tinyint) |\n+----------------------+\n| -128                 |\n+----------------------+\n[localhost:21000] &gt; select cast(127*2 as smallint);\n+---------------------------+\n| cast(127 * 2 as smallint) |\n+---------------------------+\n| 254                       |\n+---------------------------+</div><p>\n            Impala does not support notation such as <span class=\"hue-doc-codeph\">b'0101'</span> for bit literals.\n          </p></li><li><p>\n            For BLOB values, use <span class=\"hue-doc-codeph\">STRING</span> to represent <span class=\"hue-doc-codeph\">CLOB</span> or\n            <span class=\"hue-doc-codeph\">TEXT</span> types (character based large objects) up to 32 KB in size. Binary large objects\n            such as <span class=\"hue-doc-codeph\">BLOB</span>, <span class=\"hue-doc-codeph\">RAW</span><span class=\"hue-doc-codeph\">BINARY</span>, and\n            <span class=\"hue-doc-codeph\">VARBINARY</span> do not currently have an equivalent in Impala.\n          </p></li><li><p>\n            For Boolean-like types such as <span class=\"hue-doc-codeph\">BOOL</span>, use the Impala <span class=\"hue-doc-codeph\">BOOLEAN</span> type.\n          </p></li><li><p>\n            Because Impala currently does not support composite or nested types, any spatial data types in other\n            database systems do not have direct equivalents in Impala. You could represent spatial values in string\n            format and write UDFs to process them. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">User-Defined Functions (UDFs)</a> for details. Where\n            practical, separate spatial types into separate tables so that Impala can still work with the\n            non-spatial data.\n          </p></li><li><p>\n            Take out any <span class=\"hue-doc-codeph\">DEFAULT</span> clauses. Impala can use data files produced from many different\n            sources, such as Pig, Hive, or MapReduce jobs. The fast import mechanisms of <span class=\"hue-doc-codeph\">LOAD DATA</span>\n            and external tables mean that Impala is flexible about the format of data files, and Impala does not\n            necessarily validate or cleanse data before querying it. When copying data through Impala\n            <span class=\"hue-doc-codeph\">INSERT</span> statements, you can use conditional functions such as <span class=\"hue-doc-codeph\">CASE</span> or\n            <span class=\"hue-doc-codeph\">NVL</span> to substitute some other value for <span class=\"hue-doc-codeph\">NULL</span> fields; see\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_conditional_functions.xml\" data-doc-anchor-id=\"conditional_functions\">Impala Conditional Functions</a> for details.\n          </p></li><li><p>\n            Take out any constraints from your <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n            statements, for example <span class=\"hue-doc-codeph\">PRIMARY KEY</span>, <span class=\"hue-doc-codeph\">FOREIGN KEY</span>,\n            <span class=\"hue-doc-codeph\">UNIQUE</span>, <span class=\"hue-doc-codeph\">NOT NULL</span>, <span class=\"hue-doc-codeph\">UNSIGNED</span>, or\n            <span class=\"hue-doc-codeph\">CHECK</span> constraints. Impala can use data files produced from many different sources,\n            such as Pig, Hive, or MapReduce jobs. Therefore, Impala expects initial data validation to happen\n            earlier during the ETL or ELT cycle. After data is loaded into Impala tables, you can perform queries\n            to test for <span class=\"hue-doc-codeph\">NULL</span> values. When copying data through Impala <span class=\"hue-doc-codeph\">INSERT</span>\n            statements, you can use conditional functions such as <span class=\"hue-doc-codeph\">CASE</span> or <span class=\"hue-doc-codeph\">NVL</span> to\n            substitute some other value for <span class=\"hue-doc-codeph\">NULL</span> fields; see\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_conditional_functions.xml\" data-doc-anchor-id=\"conditional_functions\">Impala Conditional Functions</a> for details.\n          </p><p>\n            Do as much verification as practical before loading data into Impala. After data is loaded into Impala,\n            you can do further verification using SQL queries to check if values have expected ranges, if values\n            are <span class=\"hue-doc-codeph\">NULL</span> or not, and so on. If there is a problem with the data, you will need to\n            re-run earlier stages of the ETL process, or do an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement in\n            Impala to copy the faulty data to a new table and transform or filter out the bad values.\n          </p></li><li><p>\n            Take out any <span class=\"hue-doc-codeph\">CREATE INDEX</span>, <span class=\"hue-doc-codeph\">DROP INDEX</span>, and <span class=\"hue-doc-codeph\">ALTER\n            INDEX</span> statements, and equivalent <span class=\"hue-doc-codeph\">ALTER TABLE</span> statements. Remove any\n            <span class=\"hue-doc-codeph\">INDEX</span>, <span class=\"hue-doc-codeph\">KEY</span>, or <span class=\"hue-doc-codeph\">PRIMARY KEY</span> clauses from\n            <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER TABLE</span> statements. Impala is optimized for bulk\n            read operations for data warehouse-style queries, and therefore does not support indexes for its\n            tables.\n          </p></li><li><p>\n            Calls to built-in functions with out-of-range or otherwise incorrect arguments, return\n            <span class=\"hue-doc-codeph\">NULL</span> in Impala as opposed to raising exceptions. (This rule applies even when the\n            <span class=\"hue-doc-codeph\">ABORT_ON_ERROR=true</span> query option is in effect.) Run small-scale queries using\n            representative data to doublecheck that calls to built-in functions are returning expected values\n            rather than <span class=\"hue-doc-codeph\">NULL</span>. For example, unsupported <span class=\"hue-doc-codeph\">CAST</span> operations do not\n            raise an error in Impala:\n          </p><div class=\"hue-doc-codeblock\">select cast('foo' as int);\n+--------------------+\n| cast('foo' as int) |\n+--------------------+\n| NULL               |\n+--------------------+</div></li><li><p>\n            For any other type not supported in Impala, you could represent their values in string format and write\n            UDFs to process them. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">User-Defined Functions (UDFs)</a> for details.\n          </p></li><li><p>\n            To detect the presence of unsupported or unconvertable data types in data files, do initial testing\n            with the <span class=\"hue-doc-codeph\">ABORT_ON_ERROR=true</span> query option in effect. This option causes queries to\n            fail immediately if they encounter disallowed type conversions. See\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_abort_on_error.xml\" data-doc-anchor-id=\"abort_on_error\">ABORT_ON_ERROR Query Option</a> for details. For example:\n          </p><div class=\"hue-doc-codeblock\">set abort_on_error=true;\nselect count(*) from (select * from t1);\n-- The above query will fail if the data files for T1 contain any\n-- values that can't be converted to the expected Impala data types.\n-- For example, if T1.C1 is defined as INT but the column contains\n-- floating-point values like 1.1, the query will return an error.</div></li></ul></div></div><div id=\"porting_statements\"><div class=\"hue-doc-title\">SQL Statements to Remove or Adapt</div><div><p> The following SQL statements or clauses are not currently supported or\n        supported with limitations in Impala: </p><ul><li><p> Impala supports the <span class=\"hue-doc-codeph\">DELETE</span> statement only for\n            Kudu tables. </p><p>Impala is intended for data warehouse-style operations where you do\n            bulk moves and transforms of large quantities of data. When not\n            using Kudu tables, instead of <span class=\"hue-doc-codeph\">DELETE</span>, use\n              <span class=\"hue-doc-codeph\">INSERT OVERWRITE</span> to entirely replace the contents\n            of a table or partition, or use <span class=\"hue-doc-codeph\">INSERT ... SELECT</span>\n            to copy a subset of data (everything but the rows you intended to\n            delete) from one table to another. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_dml.xml\" data-doc-anchor-id=\"dml\">DML Statements</a> for an overview of Impala DML\n            statements. </p></li><li><p> Impala supports the <span class=\"hue-doc-codeph\">UPDATE</span> statement only for\n            Kudu tables.</p><p>When not using Kudu tables, instead of <span class=\"hue-doc-codeph\">UPDATE</span>, do\n            all necessary transformations early in the ETL process, such as in\n            the job that generates the original data, or when copying from one\n            table to another to convert to a particular file format or\n            partitioning scheme. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_dml.xml\" data-doc-anchor-id=\"dml\">DML Statements</a> for an\n            overview of Impala DML statements. </p></li><li><p> Impala has no transactional statements, such as\n              <span class=\"hue-doc-codeph\">COMMIT</span> or <span class=\"hue-doc-codeph\">ROLLBACK</span>. </p><p>Impala effectively works like the <span class=\"hue-doc-codeph\">AUTOCOMMIT</span> mode\n            in some database systems, where changes take effect as soon as they\n            are made. </p></li><li><p> If your database, table, column, or other names conflict with\n            Impala reserved words, use different names or quote the names with\n            backticks. </p><p>See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_reserved_words.xml\" data-doc-anchor-id=\"reserved_words\">Impala Reserved Words</a> for the\n            current list of Impala reserved words. </p><p> Conversely, if you use a keyword that Impala does not recognize,\n            it might be interpreted as a table or column alias. </p><p>For example, in <span class=\"hue-doc-codeph\">SELECT * FROM t1 NATURAL JOIN t2</span>,\n            Impala does not recognize the <span class=\"hue-doc-codeph\">NATURAL</span> keyword and\n            interprets it as an alias for the table <span class=\"hue-doc-codeph\">t1</span>. If you\n            experience any unexpected behavior with queries, check the list of\n            reserved words to make sure all keywords in join and\n              <span class=\"hue-doc-codeph\">WHERE</span> clauses are supported keywords in Impala.\n          </p></li><li><p>Impala has some restrictions on subquery support. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_subqueries.xml\" data-doc-anchor-id=\"subqueries\">Subqueries in Impala SELECT Statements</a> for the current details.</p></li><li><p> Impala supports <span class=\"hue-doc-codeph\">UNION</span> and <span class=\"hue-doc-codeph\">UNION\n              ALL</span> set operators, but not <span class=\"hue-doc-codeph\">INTERSECT</span>. </p><p><span class=\"hue-doc-ph\" id=\"union_all_vs_union\">Prefer <span class=\"hue-doc-codeph\">UNION ALL</span> over\n        <span class=\"hue-doc-codeph\">UNION</span> when you know the data sets are disjoint or duplicate values are\n        not a problem; <span class=\"hue-doc-codeph\">UNION ALL</span> is more efficient because it avoids\n        materializing and sorting the entire result set to eliminate duplicate values.</span></p></li><li><p>Impala requires query aliases for the subqueries used as inline\n            views in the <span class=\"hue-doc-codeph\">FROM</span> clause. </p><p>For example,\n            without the alias <span class=\"hue-doc-codeph\">contents_of_t1</span> at the end, the\n            following query gives a syntax\n            error:<div class=\"hue-doc-codeblock\">SELECT COUNT(*) FROM (SELECT * FROM t1) contents_of_t1;</div></p>Aliases\n          are not required for the subqueries used in other parts of queries.\n          For\n          example:<div class=\"hue-doc-codeblock\">SELECT * FROM functional.alltypes WHERE id = (SELECT MIN(id) FROM functional.alltypes);\n</div></li><li><p> When an alias is declared for an expression in a query, that alias\n            cannot be referenced again within the same <span class=\"hue-doc-codeph\">SELECT</span>\n            list.</p><p>For example, the <span class=\"hue-doc-codeph\">average</span> alias cannot be\n            referenced twice in the <span class=\"hue-doc-codeph\">SELECT</span> list as below. You\n            will receive an error:</p><div class=\"hue-doc-codeblock\">SELECT AVG(x) AS average, average+1 FROM t1 GROUP BY x;</div><p>An alias can be referenced again in the same query if not in the\n              <span class=\"hue-doc-codeph\">SELECT</span> list. For example, the\n              <span class=\"hue-doc-codeph\">average</span> alias can be referenced twice as shown\n            below:<div class=\"hue-doc-codeblock\">SELECT AVG(x) AS average FROM t1 GROUP BY x HAVING average &gt; 3;</div></p></li><li><p> Impala does not support <span class=\"hue-doc-codeph\">NATURAL JOIN</span>, and it does\n            not support the <span class=\"hue-doc-codeph\">USING</span> clause in joins. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_joins.xml\" data-doc-anchor-id=\"joins\">Joins in Impala SELECT Statements</a> for details on the syntax for\n            Impala join clauses. </p></li><li><p> Impala supports a limited choice of partitioning types. </p><p>Partitions are defined based on each distinct combination of values\n            for one or more partition key columns. Impala does not redistribute\n            or check data to create evenly distributed partitions. You must\n            choose partition key columns based on your knowledge of the data\n            volume and distribution. Adapt any tables that use range, list,\n            hash, or key partitioning to use the Impala partition syntax for\n              <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n            statements. </p><p>Impala partitioning is similar to range partitioning where every\n            range has exactly one value, or key partitioning where the hash\n            function produces a separate bucket for every combination of key\n            values. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"partitioning\">Partitioning for Impala Tables</a> for\n            usage details, and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a> and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_alter_table.xml\" data-doc-anchor-id=\"alter_table\">ALTER TABLE Statement</a> for syntax. </p><div class=\"hue-doc-note\"> Because the number of separate partitions is potentially higher\n            than in other database systems, keep a close eye on the number of\n            partitions and the volume of data in each one; scale back the number\n            of partition key columns if you end up with too many partitions with\n            a small volume of data in each one. <p>To distribute work for a\n              query across a cluster, you need at least one HDFS block per node.\n              HDFS blocks are typically multiple megabytes, <span class=\"hue-doc-ph\">especially</span> for Parquet files.\n              Therefore, if each partition holds only a few megabytes of data,\n              you are unlikely to see much parallelism in the query because such\n              a small amount of data is typically processed by a single node.\n            </p></div></li><li><p> For the <q>top-N</q> queries, Impala uses the\n              <span class=\"hue-doc-codeph\">LIMIT</span> clause rather than comparing against a\n            pseudo column named <span class=\"hue-doc-codeph\">ROWNUM</span> or\n              <span class=\"hue-doc-codeph\">ROW_NUM</span>. </p><p>See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_limit.xml\" data-doc-anchor-id=\"limit\">LIMIT Clause</a> for details. </p></li></ul></div></div><div id=\"porting_antipatterns\"><div class=\"hue-doc-title\">SQL Constructs to Double-check</div><div><p> Some SQL constructs that are supported have behavior or defaults more\n        oriented towards convenience than optimal performance. Also, sometimes\n        machine-generated SQL, perhaps issued through JDBC or ODBC applications,\n        might have inefficiencies or exceed internal Impala limits. As you port\n        SQL code, examine and possibly update the following where appropriate: </p><ul><li><p>\n            A <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement with no <span class=\"hue-doc-codeph\">STORED AS</span> clause creates data files\n            in plain text format, which is convenient for data interchange but not a good choice for high-volume\n            data with high-performance queries. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_file_formats.xml\" data-doc-anchor-id=\"file_formats\">How Impala Works with Hadoop File Formats</a> for why and\n            how to use specific file formats for compact data and high-performance queries. Especially see\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_parquet.xml\" data-doc-anchor-id=\"parquet\">Using the Parquet File Format with Impala Tables</a>, for details about the file format most heavily optimized for\n            large-scale data warehouse queries.\n          </p></li><li><p> Adapting tables that were already partitioned in a different\n            database system could produce an Impala table with a high number of\n            partitions and not enough data in each one, leading to\n            underutilization of Impala's parallel query features. </p><p>\n            See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"partitioning\">Partitioning for Impala Tables</a> for details about setting up partitioning and\n            tuning the performance of queries on partitioned tables.\n          </p></li><li><p> The <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> syntax is suitable for\n            setting up toy tables with a few rows for functional testing when\n            used with HDFS. Each such statement creates a separate tiny file in\n            HDFS, and it is not a scalable technique for loading megabytes or\n            gigabytes (let alone petabytes) of data. </p><p>Consider revising your data load process to produce raw data files\n            outside of Impala, then setting up Impala external tables or using\n            the <span class=\"hue-doc-codeph\">LOAD DATA</span> statement to use those data files\n            instantly in Impala tables, with no conversion or indexing stage.\n            See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tables.xml\" data-doc-anchor-id=\"external_tables\">External Tables</a> and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_load_data.xml\" data-doc-anchor-id=\"load_data\">LOAD DATA Statement</a> for details about the\n            Impala techniques for working with data files produced outside of\n            Impala; see <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_tutorial.html#tutorial_etl\" target=\"_blank\">Data Loading and Querying Examples</a> for\n            examples of ETL workflow for Impala. </p><p><span class=\"hue-doc-codeph\">INSERT</span> works fine for Kudu tables even though not\n            particularly fast.</p></li><li><p>\n            If your ETL process is not optimized for Hadoop, you might end up with highly fragmented small data\n            files, or a single giant data file that cannot take advantage of distributed parallel queries or\n            partitioning. In this case, use an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement to copy the data into a\n            new table and reorganize into a more efficient layout in the same operation. See\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_insert.xml\" data-doc-anchor-id=\"insert\">INSERT Statement</a> for details about the <span class=\"hue-doc-codeph\">INSERT</span> statement.\n          </p><p> You can do <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> into a table with a\n            more efficient file format (see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_file_formats.xml\" data-doc-anchor-id=\"file_formats\">How Impala Works with Hadoop File Formats</a>) or from an\n            unpartitioned table into a partitioned one. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"partitioning\">Partitioning for Impala Tables</a>. </p></li><li><p> Complex queries may have high codegen time. As a workaround, set\n            the query option <span class=\"hue-doc-codeph\">DISABLE_CODEGEN=true</span> if queries\n            fail for this reason. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_disable_codegen.xml\" data-doc-anchor-id=\"disable_codegen\">DISABLE_CODEGEN Query Option</a> for details. </p></li><li><p>\n            If practical, rewrite <span class=\"hue-doc-codeph\">UNION</span> queries to use the <span class=\"hue-doc-codeph\">UNION ALL</span> operator\n            instead. <span class=\"hue-doc-ph\" id=\"union_all_vs_union\">Prefer <span class=\"hue-doc-codeph\">UNION ALL</span> over\n        <span class=\"hue-doc-codeph\">UNION</span> when you know the data sets are disjoint or duplicate values are\n        not a problem; <span class=\"hue-doc-codeph\">UNION ALL</span> is more efficient because it avoids\n        materializing and sorting the entire result set to eliminate duplicate values.</span></p></li></ul></div></div><div id=\"porting_next\"><div class=\"hue-doc-title\">Next Porting Steps after Verifying Syntax and Semantics</div><div><p> Some of the decisions you make during the porting process can have an\n        impact on performance. After your SQL code is ported and working\n        correctly, examine the performance-related aspects of your schema\n        design, physical layout, and queries to make sure that the ported\n        application is taking full advantage of Impala's parallelism,\n        performance-related SQL features, and integration with Hadoop\n        components. The following are a few of the areas you should examine:</p><ul><li> For the optimal performance, we recommend that you run\n            <span class=\"hue-doc-codeph\">COMPUTE STATS</span> on all tables.</li><li> Use the most efficient file format for your data volumes, table\n          structure, and query characteristics.</li><li> Partition on columns that are often used for filtering in\n            <span class=\"hue-doc-codeph\">WHERE</span> clauses.</li><li> Your ETL process should produce a relatively small number of\n          multi-megabyte data files rather than a huge number of small\n          files.</li></ul><p> See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_performance.xml\" data-doc-anchor-id=\"performance\">Tuning Impala for Performance</a> for details\n        about the performance tuning process. </p></div></div></div></div>","title":"Porting SQL from Other Database Systems to Impala"}