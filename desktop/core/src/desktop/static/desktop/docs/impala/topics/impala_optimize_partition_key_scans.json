{"body":"<div><div id=\"optimize_partition_key_scans\"><div class=\"hue-doc-title\">OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)</div><div><p>\n      Enables a fast code path for queries that apply simple aggregate functions to partition key\n      columns: <span class=\"hue-doc-codeph\">MIN(<span class=\"hue-doc-varname\">key_column</span>)</span>, <span class=\"hue-doc-codeph\">MAX(<span class=\"hue-doc-varname\">key_column</span>)</span>,\n      or <span class=\"hue-doc-codeph\">COUNT(DISTINCT <span class=\"hue-doc-varname\">key_column</span>)</span>.\n    </p><p id=\"type_boolean\"><b>Type:</b> Boolean; recognized values are 1 and 0, or <span class=\"hue-doc-codeph\">true</span> and\n        <span class=\"hue-doc-codeph\">false</span>; any other value interpreted as <span class=\"hue-doc-codeph\">false</span></p><p id=\"default_false_0\"><b>Default:</b><span class=\"hue-doc-codeph\">false</span> (shown as 0 in output of <span class=\"hue-doc-codeph\">SET</span>\n        statement)\n      </p><div class=\"hue-doc-note\" id=\"one_but_not_true\">        In Impala 2.5.0, only the value 1 enables the option, and the value\n        <span class=\"hue-doc-codeph\">true</span> is not recognized. This limitation is tracked by the issue\n        <a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/IMPALA-3334\" target=\"_blank\">IMPALA-3334</a>, which shows the releases where the\n        problem is fixed.\n      </div><p id=\"added_in_250\"><b>Added in:</b>Impala 2.5.0</p><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n      This optimization speeds up common <q>introspection</q> operations\n      over partition key columns, for example determining the distinct values\n      of partition keys.\n    </p><p>\n      This optimization does not apply to <span class=\"hue-doc-codeph\">SELECT</span> statements\n      that reference columns that are not partition keys. It also only applies\n      when all the partition key columns in the <span class=\"hue-doc-codeph\">SELECT</span> statement\n      are referenced in one of the following contexts:\n      <ul><li><p>\n            Within a <span class=\"hue-doc-codeph\">MAX()</span> or <span class=\"hue-doc-codeph\">MAX()</span>\n            aggregate function or as the argument of any aggregate function with\n            the <span class=\"hue-doc-codeph\">DISTINCT</span> keyword applied.\n          </p></li><li><p>\n            Within a <span class=\"hue-doc-codeph\">WHERE</span>, <span class=\"hue-doc-codeph\">GROUP BY</span>\n            or <span class=\"hue-doc-codeph\">HAVING</span> clause.\n          </p></li></ul></p><p>\n      This optimization is enabled by a query option because it skips some consistency checks\n      and therefore can return slightly different partition values if partitions are in the\n      process of being added, dropped, or loaded outside of Impala. Queries might exhibit different\n      behavior depending on the setting of this option in the following cases:\n    </p><ul><li><p>\n          If files are removed from a partition using HDFS or other non-Impala operations,\n          there is a period until the next <span class=\"hue-doc-codeph\">REFRESH</span> of the table where regular\n          queries fail at run time because they detect the missing files. With this optimization\n          enabled, queries that evaluate only the partition key column values (not the contents of\n          the partition itself) succeed, and treat the partition as if it still exists.\n        </p></li><li><p>\n          If a partition contains any data files, but the data files do not contain any rows,\n          a regular query considers that the partition does not exist. With this optimization\n          enabled, the partition is treated as if it exists.\n        </p><p>\n          If the partition includes no files at all, this optimization does not change the query\n          behavior: the partition is considered to not exist whether or not this optimization is enabled.\n        </p></li></ul><p id=\"example_blurb\"><b>Examples:</b></p><p>\n      The following example shows initial schema setup and the default behavior of queries that\n      return just the partition key column for a table:\n    </p><div class=\"hue-doc-codeblock\">-- Make a partitioned table with 3 partitions.\ncreate table t1 (s string) partitioned by (year int);\ninsert into t1 partition (year=2015) values ('last year');\ninsert into t1 partition (year=2016) values ('this year');\ninsert into t1 partition (year=2017) values ('next year');\n\n-- Regardless of the option setting, this query must read the\n-- data files to know how many rows to return for each year value.\nexplain select year from t1;\n+-----------------------------------------------------+\n| Explain String                                      |\n+-----------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=0B VCores=0 |\n|                                                     |\n| F00:PLAN FRAGMENT [UNPARTITIONED]                   |\n|   00:SCAN HDFS [key_cols.t1]                        |\n|      partitions=3/3 files=4 size=40B                |\n|      table stats: 3 rows total                      |\n|      column stats: all                              |\n|      hosts=3 per-host-mem=unavailable               |\n|      tuple-ids=0 row-size=4B cardinality=3          |\n+-----------------------------------------------------+\n\n-- The aggregation operation means the query does not need to read\n-- the data within each partition: the result set contains exactly 1 row\n-- per partition, derived from the partition key column value.\n-- By default, Impala still includes a 'scan' operation in the query.\nexplain select distinct year from t1;\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=0B VCores=0                                |\n|                                                                                    |\n| 01:AGGREGATE [FINALIZE]                                                            |\n| |  group by: year                                                                  |\n| |                                                                                  |\n| 00:SCAN HDFS [key_cols.t1]                                                         |\n|    partitions=0/0 files=0 size=0B                                                  |\n+------------------------------------------------------------------------------------+\n</div><p>\n      The following examples show how the plan is made more efficient when the\n      <span class=\"hue-doc-codeph\">OPTIMIZE_PARTITION_KEY_SCANS</span> option is enabled:\n    </p><div class=\"hue-doc-codeblock\">set optimize_partition_key_scans=1;\nOPTIMIZE_PARTITION_KEY_SCANS set to 1\n\n-- The aggregation operation is turned into a UNION internally,\n-- with constant values known in advance based on the metadata\n-- for the partitioned table.\nexplain select distinct year from t1;\n+-----------------------------------------------------+\n| Explain String                                      |\n+-----------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=0B VCores=0 |\n|                                                     |\n| F00:PLAN FRAGMENT [UNPARTITIONED]                   |\n|   01:AGGREGATE [FINALIZE]                           |\n|   |  group by: year                                 |\n|   |  hosts=1 per-host-mem=unavailable               |\n|   |  tuple-ids=1 row-size=4B cardinality=3          |\n|   |                                                 |\n|   00:UNION                                          |\n|      constant-operands=3                            |\n|      hosts=1 per-host-mem=unavailable               |\n|      tuple-ids=0 row-size=4B cardinality=3          |\n+-----------------------------------------------------+\n\n-- The same optimization applies to other aggregation queries\n-- that only return values based on partition key columns:\n-- MIN, MAX, COUNT(DISTINCT), and so on.\nexplain select min(year) from t1;\n+-----------------------------------------------------+\n| Explain String                                      |\n+-----------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=0B VCores=0 |\n|                                                     |\n| F00:PLAN FRAGMENT [UNPARTITIONED]                   |\n|   01:AGGREGATE [FINALIZE]                           |\n|   |  output: min(year)                              |\n|   |  hosts=1 per-host-mem=unavailable               |\n|   |  tuple-ids=1 row-size=4B cardinality=1          |\n|   |                                                 |\n|   00:UNION                                          |\n|      constant-operands=3                            |\n|      hosts=1 per-host-mem=unavailable               |\n|      tuple-ids=0 row-size=4B cardinality=3          |\n+-----------------------------------------------------+\n</div></div></div></div>","title":"OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)"}