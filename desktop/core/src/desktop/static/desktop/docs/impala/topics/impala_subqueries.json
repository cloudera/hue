{"body":"<div><div id=\"subqueries\"><div class=\"hue-doc-title\">Subqueries in Impala SELECT Statements</div><div><p>\n      A <span class=\"hue-doc-term\">subquery</span> is a query that is nested within another query. Subqueries let queries on one table\n      dynamically adapt based on the contents of another table. This technique provides great flexibility and\n      expressive power for SQL queries.\n    </p><p>\n      A subquery can return a result set for use in the <span class=\"hue-doc-codeph\">FROM</span> or <span class=\"hue-doc-codeph\">WITH</span> clauses, or\n      with operators such as <span class=\"hue-doc-codeph\">IN</span> or <span class=\"hue-doc-codeph\">EXISTS</span>.\n    </p><p>\n      A <span class=\"hue-doc-term\">scalar subquery</span> produces a result set with a single row containing a single column, typically\n      produced by an aggregation function such as <span class=\"hue-doc-codeph\">MAX()</span> or <span class=\"hue-doc-codeph\">SUM()</span>. This single\n      result value can be substituted in scalar contexts such as arguments to comparison operators. If the result\n      set is empty, the value of the scalar subquery is <span class=\"hue-doc-codeph\">NULL</span>. For example, the following query\n      finds the maximum value of <span class=\"hue-doc-codeph\">T2.Y</span> and then substitutes that value into the\n      <span class=\"hue-doc-codeph\">WHERE</span> clause of the outer block that queries <span class=\"hue-doc-codeph\">T1</span>:\n    </p><div class=\"hue-doc-codeblock\">SELECT x FROM t1 WHERE x &gt; (SELECT MAX(y) FROM t2);\n</div><p><span class=\"hue-doc-term\">Uncorrelated subqueries</span> do not refer to any tables from the outer block of the query. The same\n      value or set of values produced by the subquery is used when evaluating each row from the outer query block.\n      In this example, the subquery returns an arbitrary number of values from <span class=\"hue-doc-codeph\">T2.Y</span>, and each\n      value of <span class=\"hue-doc-codeph\">T1.X</span> is tested for membership in that same set of values:\n    </p><div class=\"hue-doc-codeblock\">SELECT x FROM t1 WHERE x IN (SELECT y FROM t2);\n</div><p><span class=\"hue-doc-term\">Correlated subqueries</span> compare one or more values from the outer query block to values referenced\n      in the <span class=\"hue-doc-codeph\">WHERE</span> clause of the subquery. Each row evaluated by the outer <span class=\"hue-doc-codeph\">WHERE</span>\n      clause can be evaluated using a different set of values. These kinds of subqueries are restricted in the\n      kinds of comparisons they can do between columns of the inner and outer tables. (See the following\n      <b>Restrictions</b> item.)\n    </p><p>\n      For example, the following query finds all the employees with salaries that are higher than average for their\n      department. The subquery potentially computes a different <span class=\"hue-doc-codeph\">AVG()</span> value for each employee.\n    </p><div class=\"hue-doc-codeblock\">SELECT employee_name, employee_id FROM employees one WHERE\n  salary &gt; (SELECT avg(salary) FROM employees two WHERE one.dept_id = two.dept_id);\n</div><p id=\"syntax_blurb\"><b>Syntax:</b></p><p><b>Subquery in the <span class=\"hue-doc-codeph\">FROM</span> clause:</b></p><div class=\"hue-doc-codeblock\">SELECT <span class=\"hue-doc-varname\">select_list</span> FROM <span class=\"hue-doc-varname\">table_ref</span> [, <span class=\"hue-doc-varname\">table_ref</span> ...]\n\n<span class=\"hue-doc-varname\">table_ref</span> ::= <span class=\"hue-doc-varname\">table_name</span> | (<span class=\"hue-doc-varname\">select_statement</span>)\n</div><p><b>Subqueries in <span class=\"hue-doc-codeph\">WHERE</span> clause:</b></p><div class=\"hue-doc-codeblock\">WHERE <span class=\"hue-doc-varname\">value</span><span class=\"hue-doc-varname\">comparison_operator</span> (<span class=\"hue-doc-varname\">scalar_select_statement</span>)\nWHERE <span class=\"hue-doc-varname\">value</span> [NOT] IN (<span class=\"hue-doc-varname\">select_statement</span>)\nWHERE [NOT] EXISTS (<span class=\"hue-doc-varname\">correlated_select_statement</span>)\nWHERE NOT EXISTS (<span class=\"hue-doc-varname\">correlated_select_statement</span>)\n</div><p><span class=\"hue-doc-codeph\">comparison_operator</span> is a numeric comparison such as <span class=\"hue-doc-codeph\">=</span>,\n      <span class=\"hue-doc-codeph\">&lt;=</span>, <span class=\"hue-doc-codeph\">!=</span>, and so on, or a string comparison operator such as\n      <span class=\"hue-doc-codeph\">LIKE</span> or <span class=\"hue-doc-codeph\">REGEXP</span>.\n    </p><p>\n      Although you can use non-equality comparison operators such as <span class=\"hue-doc-codeph\">&lt;</span> or\n      <span class=\"hue-doc-codeph\">&gt;=</span>, the subquery must include at least one equality comparison between the columns of the\n      inner and outer query blocks.\n    </p><p>\n      All syntax is available for both correlated and uncorrelated queries, except that the <span class=\"hue-doc-codeph\">NOT\n      EXISTS</span> clause cannot be used with an uncorrelated subquery.\n    </p><p>\n      Impala subqueries can be nested arbitrarily deep.\n    </p><p id=\"sql1999\"><b>Standards compliance:</b> Introduced in\n        <a class=\"hue-doc-external-link\" href=\"http://en.wikipedia.org/wiki/SQL:1999\" target=\"_blank\">SQL:1999</a>.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n      This example illustrates how subqueries can be used in the <span class=\"hue-doc-codeph\">FROM</span> clause to organize the table\n      names, column names, and column values by producing intermediate result sets, especially for join queries.\n    </p><div class=\"hue-doc-codeblock\">SELECT avg(t1.x), max(t2.y) FROM\n  (SELECT id, cast(a AS DECIMAL(10,5)) AS x FROM raw_data WHERE a BETWEEN 0 AND 100) AS t1\n  JOIN\n  (SELECT id, length(s) AS y FROM raw_data WHERE s LIKE 'A%') AS t2;\n  USING (id);\n</div><p>\n      These examples show how a query can test for the existence of values in a separate table using the\n      <span class=\"hue-doc-codeph\">EXISTS()</span> operator with a subquery.\n</p><p>\n      The following examples show how a value can be compared against a set of values returned by a subquery.\n    </p><div class=\"hue-doc-codeblock\">SELECT count(x) FROM t1 WHERE EXISTS(SELECT 1 FROM t2 WHERE t1.x = t2.y * 10);\n\nSELECT x FROM t1 WHERE x IN (SELECT y FROM t2 WHERE state = 'CA');\n</div><p>\n      The following examples demonstrate scalar subqueries. When a subquery is known to return a single value, you\n      can substitute it where you would normally put a constant value.\n    </p><div class=\"hue-doc-codeblock\">SELECT x FROM t1 WHERE y = (SELECT max(z) FROM t2);\nSELECT x FROM t1 WHERE y &gt; (SELECT count(z) FROM t2);\n</div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n      If the same table is referenced in both the outer and inner query blocks, construct a table alias in the\n      outer query block and use a fully qualified name to distinguish the inner and outer table references:\n    </p><div class=\"hue-doc-codeblock\">SELECT * FROM t1 one WHERE id IN (SELECT parent FROM t1 two WHERE t1.parent = t2.id);\n</div><p id=\"straight_join_nested_queries\">\n        The <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> hint affects the join order of table references in\n        the query block containing the hint. It does not affect the join order of nested\n        queries, such as views, inline views, or <span class=\"hue-doc-codeph\">WHERE</span>-clause subqueries. To\n        use this hint for performance tuning of complex queries, apply the hint to all query\n        blocks that need a fixed join order.\n      </p><p id=\"internals_blurb\"><b>Internal details:</b></p><p>\n      Internally, subqueries involving <span class=\"hue-doc-codeph\">IN</span>, <span class=\"hue-doc-codeph\">NOT IN</span>, <span class=\"hue-doc-codeph\">EXISTS</span>, or\n      <span class=\"hue-doc-codeph\">NOT EXISTS</span> clauses are rewritten into join queries. Depending on the syntax, the subquery\n      might be rewritten to an outer join, semi join, cross join, or anti join.\n    </p><p>\n      A query is processed differently depending on whether the subquery calls any aggregation functions. There are\n      correlated and uncorrelated forms, with and without calls to aggregation functions. Each of these four\n      categories is rewritten differently.\n    </p><p id=\"column_stats_blurb\"><b>Column statistics considerations:</b></p><p>\n      Because queries that include correlated and uncorrelated subqueries in the <span class=\"hue-doc-codeph\">WHERE</span> clause are\n      written into join queries, to achieve best performance, follow the same guidelines for running the\n      <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement as you do for tables involved in regular join queries. Run the\n      <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement for each associated tables after loading or substantially changing\n      the data in that table. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_perf_stats.xml\" data-doc-anchor-id=\"perf_stats\">Table and Column Statistics</a> for details.\n    </p><p><b>Added in:</b> Subqueries are substantially enhanced starting in Impala 2.0. Now,\n      they can be used in the <span class=\"hue-doc-codeph\">WHERE</span> clause, in combination with clauses such as\n      <span class=\"hue-doc-codeph\">EXISTS</span> and <span class=\"hue-doc-codeph\">IN</span>, rather than just in the <span class=\"hue-doc-codeph\">FROM</span> clause.\n    </p><p id=\"restrictions_blurb\"><b>Restrictions:</b></p><p>\n      The initial Impala support for nested subqueries addresses the most common use cases. Some restrictions\n      remain:\n    </p><ul><li><p>\n          Although you can use subqueries in a query involving <span class=\"hue-doc-codeph\">UNION</span> or <span class=\"hue-doc-codeph\">UNION ALL</span>\n          in Impala 2.1.0 and higher, currently you cannot construct a union of two subqueries (for example, in the\n          argument of an <span class=\"hue-doc-codeph\">IN</span> or <span class=\"hue-doc-codeph\">EXISTS</span> operator).\n        </p></li><li><p>\n          Subqueries returning scalar values cannot be used with the operators <span class=\"hue-doc-codeph\">ANY</span> or\n          <span class=\"hue-doc-codeph\">ALL</span>. (Impala does not currently have a <span class=\"hue-doc-codeph\">SOME</span> operator, but if it did,\n          the same restriction would apply.)\n        </p></li><li><p>\n          For the <span class=\"hue-doc-codeph\">EXISTS</span> and <span class=\"hue-doc-codeph\">NOT EXISTS</span> clauses, any subquery comparing values\n          from the outer query block to another table must use at least one equality comparison, not exclusively\n          other kinds of comparisons such as less than, greater than, <span class=\"hue-doc-codeph\">BETWEEN</span>, or\n          <span class=\"hue-doc-codeph\">!=</span>.\n        </p></li><li><p>\n          Currently, a scalar subquery cannot be used as the first or second argument to the\n          <span class=\"hue-doc-codeph\">BETWEEN</span> operator.\n        </p></li><li><p>\n          A subquery cannot be used inside an <span class=\"hue-doc-codeph\">OR</span> conjunction. Expressions inside a subquery, for\n          example in the <span class=\"hue-doc-codeph\">WHERE</span> clause, can use <span class=\"hue-doc-codeph\">OR</span> conjunctions; the restriction\n          only applies to parts of the query <q>above</q> the subquery.\n        </p></li><li><p>\n          Scalar subqueries are only supported in numeric contexts. You cannot use a scalar subquery as an argument\n          to the <span class=\"hue-doc-codeph\">LIKE</span>, <span class=\"hue-doc-codeph\">REGEXP</span>, or <span class=\"hue-doc-codeph\">RLIKE</span> operators, or compare it\n          to a value of a non-numeric type such as <span class=\"hue-doc-codeph\">TIMESTAMP</span> or <span class=\"hue-doc-codeph\">BOOLEAN</span>.\n        </p></li><li><p>\n          You cannot use subqueries with the <span class=\"hue-doc-codeph\">CASE</span> function to generate the comparison value, the\n          values to be compared against, or the return value.\n        </p></li><li><p>\n          A subquery is not allowed in the filter condition for the <span class=\"hue-doc-codeph\">HAVING</span> clause. (Strictly\n          speaking, a subquery cannot appear anywhere outside the <span class=\"hue-doc-codeph\">WITH</span>, <span class=\"hue-doc-codeph\">FROM</span>, and\n          <span class=\"hue-doc-codeph\">WHERE</span> clauses.)\n        </p></li><li><p>\n          You must use a fully qualified name\n          (<span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">table_name</span>.<span class=\"hue-doc-varname\">column_name</span></span> or\n          <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">database_name</span>.<span class=\"hue-doc-varname\">table_name</span>.<span class=\"hue-doc-varname\">column_name</span></span>)\n          when referring to any column from the outer query block within a subquery.\n        </p></li><li><p id=\"tablesample_caveat\">\n        The <span class=\"hue-doc-codeph\">TABLESAMPLE</span> clause of the <span class=\"hue-doc-codeph\">SELECT</span> statement does\n        not apply to a table reference derived from a view, a subquery, or anything other than a\n        real base table. This clause only works for tables backed by HDFS or HDFS-like data\n        files, therefore it does not apply to Kudu or HBase tables.\n      </p></li></ul><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p>\n      For the complex types (<span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, and <span class=\"hue-doc-codeph\">MAP</span>)\n      available in Impala 2.3 and higher, the join queries that <q>unpack</q> complex type\n      columns often use correlated subqueries in the <span class=\"hue-doc-codeph\">FROM</span> clause.\n      For example, if the first table in the join clause is <span class=\"hue-doc-codeph\">CUSTOMER</span>, the second\n      join clause might have a subquery that selects from the column <span class=\"hue-doc-codeph\">CUSTOMER.C_ORDERS</span>,\n      which is an <span class=\"hue-doc-codeph\">ARRAY</span>. The subquery re-evaluates the <span class=\"hue-doc-codeph\">ARRAY</span> elements\n      corresponding to each row from the <span class=\"hue-doc-codeph\">CUSTOMER</span> table.\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details and examples of\n      using subqueries with complex types.\n    </p><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"exists\">EXISTS Operator</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"in\">IN Operator</a></p></div></div></div>","title":"Subqueries in Impala SELECT Statements"}