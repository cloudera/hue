{"body":"<div><div id=\"sum\"><div class=\"hue-doc-title\">SUM Function</div><div><p>\n      An aggregate function that returns the sum of a set of numbers. Its single argument can be numeric column, or\n      the numeric result of a function or expression applied to the column value. Rows with a <span class=\"hue-doc-codeph\">NULL</span>\n      value for the specified column are ignored. If the table is empty, or all the values supplied to\n      <span class=\"hue-doc-codeph\">MIN</span> are <span class=\"hue-doc-codeph\">NULL</span>, <span class=\"hue-doc-codeph\">SUM</span> returns <span class=\"hue-doc-codeph\">NULL</span>.\n    </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\">SUM([DISTINCT | ALL] <span class=\"hue-doc-varname\">expression</span>) [OVER (<span class=\"hue-doc-varname\">analytic_clause</span>)]</div><p>\n      When the query contains a <span class=\"hue-doc-codeph\">GROUP BY</span> clause, returns one value for each combination of\n      grouping values.\n    </p><p><b>Return type:</b><span class=\"hue-doc-codeph\">BIGINT</span> for integer arguments, <span class=\"hue-doc-codeph\">DOUBLE</span> for floating-point\n      arguments\n    </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_aggregation_explanation\">\n        To access a column with a complex type (<span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>,\n        or <span class=\"hue-doc-codeph\">MAP</span>) in an aggregation function, you unpack the individual elements\n        using join notation in the query, and then apply the function to the final scalar item,\n        field, key, or value at the bottom of any nested type hierarchy in the column. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about using\n        complex types in Impala.\n      </p><p id=\"complex_types_aggregation_example\">\n        The following example demonstrates calls to several aggregation functions using values\n        from a column containing nested complex types (an <span class=\"hue-doc-codeph\">ARRAY</span> of\n        <span class=\"hue-doc-codeph\">STRUCT</span> items). The array is unpacked inside the query using join\n        notation. The array elements are referenced using the <span class=\"hue-doc-codeph\">ITEM</span>\n        pseudocolumn, and the structure fields inside the array elements are referenced using\n        dot notation. Numeric values such as <span class=\"hue-doc-codeph\">SUM()</span> and <span class=\"hue-doc-codeph\">AVG()</span>\n        are computed using the numeric <span class=\"hue-doc-codeph\">R_NATIONKEY</span> field, and the\n        general-purpose <span class=\"hue-doc-codeph\">MAX()</span> and <span class=\"hue-doc-codeph\">MIN()</span> values are computed\n        from the string <span class=\"hue-doc-codeph\">N_NAME</span> field.\n<div class=\"hue-doc-codeblock\">describe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\nselect r_name, r_nations.item.n_nationkey\n  from region, region.r_nations as r_nations\norder by r_name, r_nations.item.n_nationkey;\n+-------------+------------------+\n| r_name      | item.n_nationkey |\n+-------------+------------------+\n| AFRICA      | 0                |\n| AFRICA      | 5                |\n| AFRICA      | 14               |\n| AFRICA      | 15               |\n| AFRICA      | 16               |\n| AMERICA     | 1                |\n| AMERICA     | 2                |\n| AMERICA     | 3                |\n| AMERICA     | 17               |\n| AMERICA     | 24               |\n| ASIA        | 8                |\n| ASIA        | 9                |\n| ASIA        | 12               |\n| ASIA        | 18               |\n| ASIA        | 21               |\n| EUROPE      | 6                |\n| EUROPE      | 7                |\n| EUROPE      | 19               |\n| EUROPE      | 22               |\n| EUROPE      | 23               |\n| MIDDLE EAST | 4                |\n| MIDDLE EAST | 10               |\n| MIDDLE EAST | 11               |\n| MIDDLE EAST | 13               |\n| MIDDLE EAST | 20               |\n+-------------+------------------+\n\nselect\n  r_name,\n  count(r_nations.item.n_nationkey) as count,\n  sum(r_nations.item.n_nationkey) as sum,\n  avg(r_nations.item.n_nationkey) as avg,\n  min(r_nations.item.n_name) as minimum,\n  max(r_nations.item.n_name) as maximum,\n  ndv(r_nations.item.n_nationkey) as distinct_vals\nfrom\n  region, region.r_nations as r_nations\ngroup by r_name\norder by r_name;\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |\n| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |\n| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |\n| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |\n| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n</div></p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n      The following example shows how to use <span class=\"hue-doc-codeph\">SUM()</span> to compute the total for all the values in the\n      table, a subset of values, or the sum for each combination of values in the <span class=\"hue-doc-codeph\">GROUP BY</span> clause:\n    </p><div class=\"hue-doc-codeblock\">-- Total all the values for this column in the table.\nselect sum(c1) from t1;\n-- Find the total for this column from a subset of the table.\nselect sum(c1) from t1 where month = 'January' and year = '2013';\n-- Find the total from a set of numeric function results.\nselect sum(length(s)) from t1;\n-- Often used with functions that return predefined values to compute a score.\nselect sum(case when grade = 'A' then 1.0 when grade = 'B' then 0.75 else 0) as class_honors from test_scores;\n-- Can also be used in combination with DISTINCT and/or GROUP BY.\n-- Return more than one result.\nselect month, year, sum(purchase_price) from store_stats group by month, year;\n-- Filter the input to eliminate duplicates before performing the calculation.\nselect sum(distinct x) from t1;\n</div><p>\n      The following examples show how to use <span class=\"hue-doc-codeph\">SUM()</span> in an analytic context. They use a table\n      containing integers from 1 to 10. Notice how the <span class=\"hue-doc-codeph\">SUM()</span> is reported for each input value, as\n      opposed to the <span class=\"hue-doc-codeph\">GROUP BY</span> clause which condenses the result set.\n<div class=\"hue-doc-codeblock\">select x, property, sum(x) <b>over (partition by property)</b> as sum from int_t where property in ('odd','even');\n+----+----------+-----+\n| x  | property | sum |\n+----+----------+-----+\n| 2  | even     | 30  |\n| 4  | even     | 30  |\n| 6  | even     | 30  |\n| 8  | even     | 30  |\n| 10 | even     | 30  |\n| 1  | odd      | 25  |\n| 3  | odd      | 25  |\n| 5  | odd      | 25  |\n| 7  | odd      | 25  |\n| 9  | odd      | 25  |\n+----+----------+-----+\n</div>\n\nAdding an <span class=\"hue-doc-codeph\">ORDER BY</span> clause lets you experiment with results that are cumulative or apply to a moving\nset of rows (the <q>window</q>). The following examples use <span class=\"hue-doc-codeph\">SUM()</span> in an analytic context\n(that is, with an <span class=\"hue-doc-codeph\">OVER()</span> clause) to produce a running total of all the even values,\nthen a running total of all the odd values. The basic <span class=\"hue-doc-codeph\">ORDER BY x</span> clause implicitly\nactivates a window clause of <span class=\"hue-doc-codeph\">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\nwhich is effectively the same as <span class=\"hue-doc-codeph\">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\ntherefore all of these examples produce the same results:\n<div class=\"hue-doc-codeblock\">select x, property,\n  sum(x) over (partition by property <b>order by x</b>) as 'cumulative total'\n  from int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative total |\n+----+----------+------------------+\n| 2  | even     | 2                |\n| 4  | even     | 6                |\n| 6  | even     | 12               |\n| 8  | even     | 20               |\n| 10 | even     | 30               |\n| 1  | odd      | 1                |\n| 3  | odd      | 4                |\n| 5  | odd      | 9                |\n| 7  | odd      | 16               |\n| 9  | odd      | 25               |\n+----+----------+------------------+\n\nselect x, property,\n  sum(x) over\n  (\n    partition by property\n    <b>order by x</b><b>range between unbounded preceding and current row</b>\n  ) as 'cumulative total'\nfrom int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative total |\n+----+----------+------------------+\n| 2  | even     | 2                |\n| 4  | even     | 6                |\n| 6  | even     | 12               |\n| 8  | even     | 20               |\n| 10 | even     | 30               |\n| 1  | odd      | 1                |\n| 3  | odd      | 4                |\n| 5  | odd      | 9                |\n| 7  | odd      | 16               |\n| 9  | odd      | 25               |\n+----+----------+------------------+\n\nselect x, property,\n  sum(x) over\n  (\n    partition by property\n    <b>order by x</b><b>rows between unbounded preceding and current row</b>\n  ) as 'cumulative total'\n  from int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative total |\n+----+----------+------------------+\n| 2  | even     | 2                |\n| 4  | even     | 6                |\n| 6  | even     | 12               |\n| 8  | even     | 20               |\n| 10 | even     | 30               |\n| 1  | odd      | 1                |\n| 3  | odd      | 4                |\n| 5  | odd      | 9                |\n| 7  | odd      | 16               |\n| 9  | odd      | 25               |\n+----+----------+------------------+\n</div>\n\nChanging the direction of the <span class=\"hue-doc-codeph\">ORDER BY</span> clause causes the intermediate\nresults of the cumulative total to be calculated in a different order:\n\n<div class=\"hue-doc-codeblock\">select sum(x) over (partition by property <b>order by x desc</b>) as 'cumulative total'\n  from int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative total |\n+----+----------+------------------+\n| 10 | even     | 10               |\n| 8  | even     | 18               |\n| 6  | even     | 24               |\n| 4  | even     | 28               |\n| 2  | even     | 30               |\n| 9  | odd      | 9                |\n| 7  | odd      | 16               |\n| 5  | odd      | 21               |\n| 3  | odd      | 24               |\n| 1  | odd      | 25               |\n+----+----------+------------------+\n</div>\n\nThe following examples show how to construct a moving window, with a running total taking into account 1 row before\nand 1 row after the current row, within the same partition (all the even values or all the odd values).\nBecause of a restriction in the Impala <span class=\"hue-doc-codeph\">RANGE</span> syntax, this type of\nmoving window is possible with the <span class=\"hue-doc-codeph\">ROWS BETWEEN</span> clause but not the <span class=\"hue-doc-codeph\">RANGE BETWEEN</span>\nclause:\n<div class=\"hue-doc-codeblock\">select x, property,\n  sum(x) over\n  (\n    partition by property\n    <b>order by x</b><b>rows between 1 preceding and 1 following</b>\n  ) as 'moving total'\n  from int_t where property in ('odd','even');\n+----+----------+--------------+\n| x  | property | moving total |\n+----+----------+--------------+\n| 2  | even     | 6            |\n| 4  | even     | 12           |\n| 6  | even     | 18           |\n| 8  | even     | 24           |\n| 10 | even     | 18           |\n| 1  | odd      | 4            |\n| 3  | odd      | 9            |\n| 5  | odd      | 15           |\n| 7  | odd      | 21           |\n| 9  | odd      | 16           |\n+----+----------+--------------+\n\n-- Doesn't work because of syntax restriction on RANGE clause.\nselect x, property,\n  sum(x) over\n  (\n    partition by property\n    <b>order by x</b><b>range between 1 preceding and 1 following</b>\n  ) as 'moving total'\nfrom int_t where property in ('odd','even');\nERROR: AnalysisException: RANGE is only supported with both the lower and upper bounds UNBOUNDED or one UNBOUNDED and the other CURRENT ROW.\n</div></p><p id=\"restrictions_blurb\"><b>Restrictions:</b></p><p id=\"sum_double\">\n        Due to the way arithmetic on <span class=\"hue-doc-codeph\">FLOAT</span> and <span class=\"hue-doc-codeph\">DOUBLE</span> columns\n        uses high-performance hardware instructions, and distributed queries can perform these\n        operations in different order for each query, results can vary slightly for aggregate\n        function calls such as <span class=\"hue-doc-codeph\">SUM()</span> and <span class=\"hue-doc-codeph\">AVG()</span> for\n        <span class=\"hue-doc-codeph\">FLOAT</span> and <span class=\"hue-doc-codeph\">DOUBLE</span> columns, particularly on large data\n        sets where millions or billions of values are summed or averaged. For perfect\n        consistency and repeatability, use the <span class=\"hue-doc-codeph\">DECIMAL</span> data type for such\n        operations instead of <span class=\"hue-doc-codeph\">FLOAT</span> or <span class=\"hue-doc-codeph\">DOUBLE</span>.\n      </p><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_analytic_functions.xml\" data-doc-anchor-id=\"analytic_functions\">Impala Analytic Functions</a></p></div></div></div>","title":"SUM Function"}