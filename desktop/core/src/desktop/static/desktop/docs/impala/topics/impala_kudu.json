{"body":"<div><div id=\"impala_kudu\"><div class=\"hue-doc-title\" id=\"kudu\">Using Impala to Query Kudu Tables</div><div><p>\n      You can use Impala to query tables stored by Apache Kudu. This capability\n      allows convenient access to a storage system that is tuned for different kinds of\n      workloads than the default with Impala.\n    </p><p>\n      By default, Impala tables are stored on HDFS using data files with various file formats.\n      HDFS files are ideal for bulk loads (append operations) and queries using full-table scans,\n      but do not support in-place updates or deletes. Kudu is an alternative storage engine used\n      by Impala which can do both in-place updates (for mixed read/write workloads) and fast scans\n      (for data-warehouse/analytic operations). Using Kudu tables with Impala can simplify the\n      ETL pipeline by avoiding extra steps to segregate and reorganize newly arrived data.\n    </p><p>\n      Certain Impala SQL statements and clauses, such as <span class=\"hue-doc-codeph\">DELETE</span>,\n      <span class=\"hue-doc-codeph\">UPDATE</span>, <span class=\"hue-doc-codeph\">UPSERT</span>, and <span class=\"hue-doc-codeph\">PRIMARY KEY</span> work\n      only with Kudu tables. Other statements and clauses, such as <span class=\"hue-doc-codeph\">LOAD DATA</span>,\n      <span class=\"hue-doc-codeph\">TRUNCATE TABLE</span>, and <span class=\"hue-doc-codeph\">INSERT OVERWRITE</span>, are not applicable\n      to Kudu tables.\n    </p><p/></div><div id=\"kudu_benefits\"><div class=\"hue-doc-title\">Benefits of Using Kudu Tables with Impala</div><div><p>\n        The combination of Kudu and Impala works best for tables where scan performance is\n        important, but data arrives continuously, in small batches, or needs to be updated\n        without being completely replaced. HDFS-backed tables can require substantial overhead\n        to replace or reorganize data files as new data arrives. Impala can perform efficient\n        lookups and scans within Kudu tables, and Impala can also perform update or\n        delete operations efficiently. You can also use the Kudu Java, C++, and Python APIs to\n        do ingestion or transformation operations outside of Impala, and Impala can query the\n        current data at any time.\n      </p></div></div><div id=\"kudu_config\"><div class=\"hue-doc-title\">Configuring Impala for Use with Kudu</div><div><p>\n        The <span class=\"hue-doc-codeph\">-kudu_master_hosts</span> configuration property must be set correctly\n        for the <span class=\"hue-doc-cmdname\">impalad</span> daemon, for <span class=\"hue-doc-codeph\">CREATE TABLE ... STORED AS\n        KUDU</span> statements to connect to the appropriate Kudu server. Typically, the\n        required value for this setting is <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">kudu_host</span>:7051</span>.\n        In a high-availability Kudu deployment, specify the names of multiple Kudu hosts separated by commas.\n      </p><p>\n        If the <span class=\"hue-doc-codeph\">-kudu_master_hosts</span> configuration property is not set, you can\n        still associate the appropriate value for each table by specifying a\n        <span class=\"hue-doc-codeph\">TBLPROPERTIES('kudu.master_addresses')</span> clause in the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement or\n        changing the <span class=\"hue-doc-codeph\">TBLPROPERTIES('kudu.master_addresses')</span> value with an <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n        statement.\n      </p></div><div id=\"kudu_topology\"><div class=\"hue-doc-title\">Cluster Topology for Kudu Tables</div><div><p>\n          With HDFS-backed tables, you are typically concerned with the number of DataNodes in\n          the cluster, how many and how large HDFS data files are read during a query, and\n          therefore the amount of work performed by each DataNode and the network communication\n          to combine intermediate results and produce the final result set.\n        </p><p>\n          With Kudu tables, the topology considerations are different, because:\n        </p><ul><li><p>\n              The underlying storage is managed and organized by Kudu, not represented as HDFS\n              data files.\n            </p></li><li><p>\n              Kudu handles some of the underlying mechanics of partitioning the data. You can specify\n              the partitioning scheme with combinations of hash and range partitioning, so that you can\n              decide how much effort to expend to manage the partitions as new data arrives. For example,\n              you can construct partitions that apply to date ranges rather than a separate partition for each\n              day or each hour.\n            </p></li><li><p> Data is physically divided based on units of storage called\n                <span class=\"hue-doc-term\">tablets</span>. Tablets are stored by <span class=\"hue-doc-term\">tablet\n                servers</span>. Each tablet server can store multiple tablets,\n              and each tablet is replicated across multiple tablet servers,\n              managed automatically by Kudu. Where practical, co-locate the\n              tablet servers on the same hosts as the Impala daemons, although\n              that is not required. </p></li></ul></div></div></div><div id=\"kudu_replication_factor\"><div class=\"hue-doc-title\">Kudu Replication Factor</div><div><p>\n        By default, Kudu tables created through Impala use a tablet\n        replication factor of 3. To change the replication factor for a Kudu\n        table, specify the replication factor using <span class=\"hue-doc-codeph\">TBLPROPERTIES\n          ('kudu.num_tablet_replicas' = '<i>n</i>')</span> in the <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a> statement.\n      </p><p>\n        The number of replicas for a Kudu table must be odd.\n      </p><p> Altering the <span class=\"hue-doc-codeph\">kudu.num_tablet_replicas</span> property after\n        table creation currently has no effect. </p></div></div><div id=\"kudu_ddl\"><div class=\"hue-doc-title\">Impala DDL Enhancements for Kudu Tables (CREATE TABLE and ALTER TABLE)</div><div><p>\n        You can use the Impala <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n        statements to create and fine-tune the characteristics of Kudu tables. Because Kudu\n        tables have features and properties that do not apply to other kinds of Impala tables,\n        familiarize yourself with Kudu-related concepts and syntax first.\n        For the general syntax of the <span class=\"hue-doc-codeph\">CREATE TABLE</span>\n        statement for Kudu tables, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a>.\n      </p><p/></div><div id=\"kudu_primary_key\"><div class=\"hue-doc-title\">Primary Key Columns for Kudu Tables</div><div><p>\n          Kudu tables introduce the notion of primary keys to Impala for the first time. The\n          primary key is made up of one or more columns, whose values are combined and used as a\n          lookup key during queries. The tuple represented by these columns must be unique and cannot contain any\n          <span class=\"hue-doc-codeph\">NULL</span> values, and can never be updated once inserted. For a\n          Kudu table, all the partition key columns must come from the set of\n          primary key columns.\n        </p><p>\n          The primary key has both physical and logical aspects:\n        </p><ul><li><p>\n              On the physical side, it is used to map the data values to particular tablets for fast retrieval.\n              Because the tuples formed by the primary key values are unique, the primary key columns are typically\n              highly selective.\n            </p></li><li><p>\n              On the logical side, the uniqueness constraint allows you to avoid duplicate data in a table.\n              For example, if an <span class=\"hue-doc-codeph\">INSERT</span> operation fails partway through, only some of the\n              new rows might be present in the table. You can re-run the same <span class=\"hue-doc-codeph\">INSERT</span>, and\n              only the missing rows will be added. Or if data in the table is stale, you can run an\n              <span class=\"hue-doc-codeph\">UPSERT</span> statement that brings the data up to date, without the possibility\n              of creating duplicate copies of existing rows.\n            </p></li></ul><div class=\"hue-doc-note\"><p>\n            Impala only allows <span class=\"hue-doc-codeph\">PRIMARY KEY</span> clauses and <span class=\"hue-doc-codeph\">NOT NULL</span>\n            constraints on columns for Kudu tables. These constraints are enforced on the Kudu side.\n          </p></div></div></div><div id=\"kudu_column_attributes\"><div class=\"hue-doc-title\">Kudu-Specific Column Attributes for CREATE TABLE</div><div><p>\n          For the general syntax of the <span class=\"hue-doc-codeph\">CREATE TABLE</span>\n          statement for Kudu tables, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a>.\n          The following sections provide more detail for some of the\n          Kudu-specific keywords you can use in column definitions.\n        </p><p>\n          The column list in a <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement can include the following\n          attributes, which only apply to Kudu tables:\n        </p><div class=\"hue-doc-codeblock\">  PRIMARY KEY\n| [NOT] NULL\n| ENCODING <span class=\"hue-doc-varname\">codec</span>\n| COMPRESSION <span class=\"hue-doc-varname\">algorithm</span>\n| DEFAULT <span class=\"hue-doc-varname\">constant_expression</span>\n| BLOCK_SIZE <span class=\"hue-doc-varname\">number</span></div><p>\n          See the following sections for details about each column attribute.\n        </p></div><div id=\"kudu_primary_key_attribute\"><div class=\"hue-doc-title\">PRIMARY KEY Attribute</div><div><p>\n            The primary key for a Kudu table is a column, or set of columns, that uniquely\n            identifies every row. The primary key value also is used as the natural sort order\n            for the values from the table. The primary key value for each row is based on the\n            combination of values for the columns.\n          </p><p id=\"pk_implies_not_null\">\n        Because all of the primary key columns must have non-null values, specifying a column in\n        the <span class=\"hue-doc-codeph\">PRIMARY KEY</span> clause implicitly adds the <span class=\"hue-doc-codeph\">NOT NULL</span>\n        attribute to that column.\n      </p><p>\n            The primary key columns must be the first ones specified in the <span class=\"hue-doc-codeph\">CREATE\n            TABLE</span> statement. For a single-column primary key, you can include a\n            <span class=\"hue-doc-codeph\">PRIMARY KEY</span> attribute inline with the column definition. For a\n            multi-column primary key, you include a <span class=\"hue-doc-codeph\">PRIMARY KEY (<span class=\"hue-doc-varname\">c1</span>,\n            <span class=\"hue-doc-varname\">c2</span>, ...)</span> clause as a separate entry at the end of the\n            column list.\n          </p><p>\n            You can specify the <span class=\"hue-doc-codeph\">PRIMARY KEY</span> attribute either inline in a single\n            column definition, or as a separate clause at the end of the column list:\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE pk_inline\n(\n  col1 BIGINT PRIMARY KEY,\n  col2 STRING,\n  col3 BOOLEAN\n) PARTITION BY HASH(col1) PARTITIONS 2 STORED AS KUDU;\n\nCREATE TABLE pk_at_end\n(\n  col1 BIGINT,\n  col2 STRING,\n  col3 BOOLEAN,\n  PRIMARY KEY (col1)\n) PARTITION BY HASH(col1) PARTITIONS 2 STORED AS KUDU;\n</div><p>\n            When the primary key is a single column, these two forms are equivalent. If the\n            primary key consists of more than one column, you must specify the primary key using\n            a separate entry in the column list:\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE pk_multiple_columns\n(\n  col1 BIGINT,\n  col2 STRING,\n  col3 BOOLEAN,\n  <b>PRIMARY KEY (col1, col2)</b>\n) PARTITION BY HASH(col2) PARTITIONS 2 STORED AS KUDU;\n</div><p>\n            The <span class=\"hue-doc-codeph\">SHOW CREATE TABLE</span> statement always represents the\n            <span class=\"hue-doc-codeph\">PRIMARY KEY</span> specification as a separate item in the column list:\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE inline_pk_rewritten (id BIGINT <b>PRIMARY KEY</b>, s STRING)\n  PARTITION BY HASH(id) PARTITIONS 2 STORED AS KUDU;\n\nSHOW CREATE TABLE inline_pk_rewritten;\n+------------------------------------------------------------------------------+\n| result                                                                       |\n+------------------------------------------------------------------------------+\n| CREATE TABLE user.inline_pk_rewritten (                                      |\n|   id BIGINT NOT NULL ENCODING AUTO_ENCODING COMPRESSION DEFAULT_COMPRESSION, |\n|   s STRING NULL ENCODING AUTO_ENCODING COMPRESSION DEFAULT_COMPRESSION,      |\n|   <b>PRIMARY KEY (id)</b>                                                           |\n| )                                                                            |\n| PARTITION BY HASH (id) PARTITIONS 2                                          |\n| STORED AS KUDU                                                               |\n| TBLPROPERTIES ('kudu.master_addresses'='host.example.com')                   |\n+------------------------------------------------------------------------------+\n</div><p>\n            The notion of primary key only applies to Kudu tables. Every Kudu table requires a\n            primary key. The primary key consists of one or more columns. You must specify any\n            primary key columns first in the column list.\n          </p><p>\n            The contents of the primary key columns cannot be changed by an\n            <span class=\"hue-doc-codeph\">UPDATE</span> or <span class=\"hue-doc-codeph\">UPSERT</span> statement. Including too many\n            columns in the primary key (more than 5 or 6) can also reduce the performance of\n            write operations. Therefore, pick the most selective and most frequently\n            tested non-null columns for the primary key specification.\n            If a column must always have a value, but that value\n            might change later, leave it out of the primary key and use a <span class=\"hue-doc-codeph\">NOT\n            NULL</span> clause for that column instead. If an existing row has an\n            incorrect or outdated key column value, delete the old row and insert an entirely\n            new row with the correct primary key.\n          </p></div></div><div id=\"kudu_not_null_attribute\"><div class=\"hue-doc-title\">NULL | NOT NULL Attribute</div><div><p>\n            For Kudu tables, you can specify which columns can contain nulls or not. This\n            constraint offers an extra level of consistency enforcement for Kudu tables. If an\n            application requires a field to always be specified, include a <span class=\"hue-doc-codeph\">NOT\n            NULL</span> clause in the corresponding column definition, and Kudu prevents rows\n            from being inserted with a <span class=\"hue-doc-codeph\">NULL</span> in that column.\n          </p><p>\n            For example, a table containing geographic information might require the latitude\n            and longitude coordinates to always be specified. Other attributes might be allowed\n            to be <span class=\"hue-doc-codeph\">NULL</span>. For example, a location might not have a designated\n            place name, its altitude might be unimportant, and its population might be initially\n            unknown, to be filled in later.\n          </p><p id=\"pk_implies_not_null\">\n        Because all of the primary key columns must have non-null values, specifying a column in\n        the <span class=\"hue-doc-codeph\">PRIMARY KEY</span> clause implicitly adds the <span class=\"hue-doc-codeph\">NOT NULL</span>\n        attribute to that column.\n      </p><p>\n            For non-Kudu tables, Impala allows any column to contain <span class=\"hue-doc-codeph\">NULL</span>\n            values, because it is not practical to enforce a <q>not null</q> constraint on HDFS\n            data files that could be prepared using external tools and ETL processes.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE required_columns\n(\n  id BIGINT PRIMARY KEY,\n  latitude DOUBLE NOT NULL,\n  longitude DOUBLE NOT NULL,\n  place_name STRING,\n  altitude DOUBLE,\n  population BIGINT\n) PARTITION BY HASH(id) PARTITIONS 2 STORED AS KUDU;\n</div><p>\n            During performance optimization, Kudu can use the knowledge that nulls are not\n            allowed to skip certain checks on each input row, speeding up queries and join\n            operations. Therefore, specify <span class=\"hue-doc-codeph\">NOT NULL</span> constraints when\n            appropriate.\n          </p><p>\n            The <span class=\"hue-doc-codeph\">NULL</span> clause is the default condition for all columns that are not\n            part of the primary key. You can omit it, or specify it to clarify that you have made a\n            conscious design decision to allow nulls in a column.\n          </p><p>\n            Because primary key columns cannot contain any <span class=\"hue-doc-codeph\">NULL</span> values, the\n            <span class=\"hue-doc-codeph\">NOT NULL</span> clause is not required for the primary key columns,\n            but you might still specify it to make your code self-describing.\n          </p></div></div><div id=\"kudu_default_attribute\"><div class=\"hue-doc-title\">DEFAULT Attribute</div><div><p>\n            You can specify a default value for columns in Kudu tables. The default value can be\n            any constant expression, for example, a combination of literal values, arithmetic\n            and string operations. It cannot contain references to columns or non-deterministic\n            function calls.\n          </p><p>\n            The following example shows different kinds of expressions for the\n            <span class=\"hue-doc-codeph\">DEFAULT</span> clause. The requirement to use a constant value means that\n            you can fill in a placeholder value such as <span class=\"hue-doc-codeph\">NULL</span>, empty string,\n            0, -1, <span class=\"hue-doc-codeph\">'N/A'</span> and so on, but you cannot reference functions or\n            column names. Therefore, you cannot use <span class=\"hue-doc-codeph\">DEFAULT</span> to do things such as\n            automatically making an uppercase copy of a string value, storing Boolean values based\n            on tests of other columns, or add or subtract one from another column representing a sequence number.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE default_vals\n(\n  id BIGINT PRIMARY KEY,\n  name STRING NOT NULL DEFAULT 'unknown',\n  address STRING DEFAULT upper('no fixed address'),\n  age INT DEFAULT -1,\n  earthling BOOLEAN DEFAULT TRUE,\n  planet_of_origin STRING DEFAULT 'Earth',\n  optional_col STRING DEFAULT NULL\n) PARTITION BY HASH(id) PARTITIONS 2 STORED AS KUDU;\n</div><div class=\"hue-doc-note\"><p>\n              When designing an entirely new schema, prefer to use <span class=\"hue-doc-codeph\">NULL</span> as the\n              placeholder for any unknown or missing values, because that is the universal convention\n              among database systems. Null values can be stored efficiently, and easily checked with the\n              <span class=\"hue-doc-codeph\">IS NULL</span> or <span class=\"hue-doc-codeph\">IS NOT NULL</span> operators. The <span class=\"hue-doc-codeph\">DEFAULT</span>\n              attribute is appropriate when ingesting data that already has an established convention for\n              representing unknown or missing values, or where the vast majority of rows have some common\n              non-null value.\n            </p></div></div></div><div id=\"kudu_encoding_attribute\"><div class=\"hue-doc-title\">ENCODING Attribute</div><div><p>\n            Each column in a Kudu table can optionally use an encoding, a low-overhead form of\n            compression that reduces the size on disk, then requires additional CPU cycles to\n            reconstruct the original values during queries. Typically, highly compressible data\n            benefits from the reduced I/O to read the data back from disk.\n          </p><p>\n            The encoding keywords that Impala recognizes are:\n\n            <ul><li><p><span class=\"hue-doc-codeph\">AUTO_ENCODING</span>: use the default encoding based\n                  on the column type, which are bitshuffle for the numeric type\n                  columns and dictionary for the string type columns.\n                </p></li><li><p><span class=\"hue-doc-codeph\">PLAIN_ENCODING</span>: leave the value in its original binary format.\n                </p></li><li><p><span class=\"hue-doc-codeph\">RLE</span>: compress repeated values (when sorted in primary key\n                  order) by including a count.\n                </p></li><li><p><span class=\"hue-doc-codeph\">DICT_ENCODING</span>: when the number of different string values is\n                  low, replace the original string with a numeric ID.\n                </p></li><li><p><span class=\"hue-doc-codeph\">BIT_SHUFFLE</span>: rearrange the bits of the values to efficiently\n                  compress sequences of values that are identical or vary only slightly based\n                  on primary key order. The resulting encoded data is also compressed with LZ4.\n                </p></li><li><p><span class=\"hue-doc-codeph\">PREFIX_ENCODING</span>: compress common prefixes in string values; mainly for use internally within Kudu.\n                </p></li></ul></p><p>\n            The following example shows the Impala keywords representing the encoding types.\n            (The Impala keywords match the symbolic names used within Kudu.)\n            For usage guidelines on the different kinds of encoding, see\n            <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/docs/schema_design.html\" target=\"_blank\">the Kudu documentation</a>.\n            The <span class=\"hue-doc-codeph\">DESCRIBE</span> output shows how the encoding is reported after\n            the table is created, and that omitting the encoding (in this case, for the\n            <span class=\"hue-doc-codeph\">ID</span> column) is the same as specifying <span class=\"hue-doc-codeph\">DEFAULT_ENCODING</span>.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE various_encodings\n(\n  id BIGINT PRIMARY KEY,\n  c1 BIGINT ENCODING PLAIN_ENCODING,\n  c2 BIGINT ENCODING AUTO_ENCODING,\n  c3 TINYINT ENCODING BIT_SHUFFLE,\n  c4 DOUBLE ENCODING BIT_SHUFFLE,\n  c5 BOOLEAN ENCODING RLE,\n  c6 STRING ENCODING DICT_ENCODING,\n  c7 STRING ENCODING PREFIX_ENCODING\n) PARTITION BY HASH(id) PARTITIONS 2 STORED AS KUDU;\n\n-- Some columns are omitted from the output for readability.\ndescribe various_encodings;\n+------+---------+-------------+----------+-----------------+\n| name | type    | primary_key | nullable | encoding        |\n+------+---------+-------------+----------+-----------------+\n| id   | bigint  | true        | false    | AUTO_ENCODING   |\n| c1   | bigint  | false       | true     | PLAIN_ENCODING  |\n| c2   | bigint  | false       | true     | AUTO_ENCODING   |\n| c3   | tinyint | false       | true     | BIT_SHUFFLE     |\n| c4   | double  | false       | true     | BIT_SHUFFLE     |\n| c5   | boolean | false       | true     | RLE             |\n| c6   | string  | false       | true     | DICT_ENCODING   |\n| c7   | string  | false       | true     | PREFIX_ENCODING |\n+------+---------+-------------+----------+-----------------+\n</div></div></div><div id=\"kudu_compression_attribute\"><div class=\"hue-doc-title\">COMPRESSION Attribute</div><div><p>\n            You can specify a compression algorithm to use for each column in a Kudu table. This\n            attribute imposes more CPU overhead when retrieving the values than the\n            <span class=\"hue-doc-codeph\">ENCODING</span> attribute does. Therefore, use it primarily for columns with\n            long strings that do not benefit much from the less-expensive <span class=\"hue-doc-codeph\">ENCODING</span>\n            attribute.\n          </p><p>\n            The choices for <span class=\"hue-doc-codeph\">COMPRESSION</span> are <span class=\"hue-doc-codeph\">LZ4</span>,\n            <span class=\"hue-doc-codeph\">SNAPPY</span>, and <span class=\"hue-doc-codeph\">ZLIB</span>.\n          </p><div class=\"hue-doc-note\"><p>\n              Columns that use the <span class=\"hue-doc-codeph\">BITSHUFFLE</span> encoding are already compressed\n              using <span class=\"hue-doc-codeph\">LZ4</span>, and so typically do not need any additional\n              <span class=\"hue-doc-codeph\">COMPRESSION</span> attribute.\n            </p></div><p>\n            The following example shows design considerations for several\n            <span class=\"hue-doc-codeph\">STRING</span> columns with different distribution characteristics, leading\n            to choices for both the <span class=\"hue-doc-codeph\">ENCODING</span> and <span class=\"hue-doc-codeph\">COMPRESSION</span>\n            attributes. The <span class=\"hue-doc-codeph\">country</span> values come from a specific set of strings,\n            therefore this column is a good candidate for dictionary encoding. The\n            <span class=\"hue-doc-codeph\">post_id</span> column contains an ascending sequence of integers, where\n            several leading bits are likely to be all zeroes, therefore this column is a good\n            candidate for bitshuffle encoding. The <span class=\"hue-doc-codeph\">body</span>\n            column and the corresponding columns for translated versions tend to be long unique\n            strings that are not practical to use with any of the encoding schemes, therefore\n            they employ the <span class=\"hue-doc-codeph\">COMPRESSION</span> attribute instead. The ideal compression\n            codec in each case would require some experimentation to determine how much space\n            savings it provided and how much CPU overhead it added, based on real-world data.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE blog_posts\n(\n  user_id STRING ENCODING DICT_ENCODING,\n  post_id BIGINT ENCODING BIT_SHUFFLE,\n  subject STRING ENCODING PLAIN_ENCODING,\n  body STRING COMPRESSION LZ4,\n  spanish_translation STRING COMPRESSION SNAPPY,\n  esperanto_translation STRING COMPRESSION ZLIB,\n  PRIMARY KEY (user_id, post_id)\n) PARTITION BY HASH(user_id, post_id) PARTITIONS 2 STORED AS KUDU;\n</div></div></div><div id=\"kudu_block_size_attribute\"><div class=\"hue-doc-title\">BLOCK_SIZE Attribute</div><div><p>\n            Although Kudu does not use HDFS files internally, and thus is not affected by\n            the HDFS block size, it does have an underlying unit of I/O called the\n            <span class=\"hue-doc-term\">block size</span>. The <span class=\"hue-doc-codeph\">BLOCK_SIZE</span> attribute lets you set the\n            block size for any column.\n          </p><p>\n            The block size attribute is a relatively advanced feature. Refer to\n            <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/docs/index.html\" target=\"_blank\">the Kudu documentation</a>\n            for usage details.\n          </p></div></div></div><div id=\"kudu_partitioning\"><div class=\"hue-doc-title\">Partitioning for Kudu Tables</div><div><p>\n          Kudu tables use special mechanisms to distribute data among the underlying\n          tablet servers. Although we refer to such tables as partitioned tables, they are\n          distinguished from traditional Impala partitioned tables by use of different clauses\n          on the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement. Kudu tables use\n          <span class=\"hue-doc-codeph\">PARTITION BY</span>, <span class=\"hue-doc-codeph\">HASH</span>, <span class=\"hue-doc-codeph\">RANGE</span>, and\n          range specification clauses rather than the <span class=\"hue-doc-codeph\">PARTITIONED BY</span> clause\n          for HDFS-backed tables, which specifies only a column name and creates a new partition for each\n          different value.\n        </p><p>\n          For background information and architectural details about the Kudu partitioning\n          mechanism, see\n          <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/kudu.pdf\" target=\"_blank\">the Kudu white paper, section 3.2</a>.\n        </p><div class=\"hue-doc-note\"><p>\n            The Impala DDL syntax for Kudu tables is different than in early Kudu versions,\n            which used an experimental fork of the Impala code. For example, the\n            <span class=\"hue-doc-codeph\">DISTRIBUTE BY</span> clause is now <span class=\"hue-doc-codeph\">PARTITION BY</span>, the\n            <span class=\"hue-doc-codeph\">INTO <span class=\"hue-doc-varname\">n</span> BUCKETS</span> clause is now\n            <span class=\"hue-doc-codeph\">PARTITIONS <span class=\"hue-doc-varname\">n</span></span> and the range partitioning syntax\n            is reworked to replace the <span class=\"hue-doc-codeph\">SPLIT ROWS</span> clause with more expressive\n            syntax involving comparison operators.\n          </p></div><p/></div><div id=\"kudu_hash_partitioning\"><div class=\"hue-doc-title\">Hash Partitioning</div><div><p>\n            Hash partitioning is the simplest type of partitioning for Kudu tables.\n            For hash-partitioned Kudu tables, inserted rows are divided up between a fixed number\n            of <q>buckets</q> by applying a hash function to the values of the columns specified\n            in the <span class=\"hue-doc-codeph\">HASH</span> clause.\n            Hashing ensures that rows with similar values are evenly distributed, instead of\n            clumping together all in the same bucket. Spreading new rows across the buckets this\n            way lets insertion operations work in parallel across multiple tablet servers.\n            Separating the hashed values can impose additional overhead on queries, where\n            queries with range-based predicates might have to read multiple tablets to retrieve\n            all the relevant values.\n          </p><div class=\"hue-doc-codeblock\">-- 1M rows with 50 hash partitions = approximately 20,000 rows per partition.\n-- The values in each partition are not sequential, but rather based on a hash function.\n-- Rows 1, 99999, and 123456 might be in the same partition.\nCREATE TABLE million_rows (id string primary key, s string)\n  PARTITION BY HASH(id) PARTITIONS 50\n  STORED AS KUDU;\n\n-- Because the ID values are unique, we expect the rows to be roughly\n-- evenly distributed between the buckets in the destination table.\nINSERT INTO million_rows SELECT * FROM billion_rows ORDER BY id LIMIT 1e6;\n</div><div class=\"hue-doc-note\"><p>\n              The largest number of buckets that you can create with a <span class=\"hue-doc-codeph\">PARTITIONS</span>\n              clause varies depending on the number of tablet servers in the cluster, while the smallest is 2.\n              For simplicity, some of the simple <span class=\"hue-doc-codeph\">CREATE TABLE</span> statements throughout this section\n              use <span class=\"hue-doc-codeph\">PARTITIONS 2</span> to illustrate the minimum requirements for a Kudu table.\n              For large tables, prefer to use roughly 10 partitions per server in the cluster.\n            </p></div></div></div><div id=\"kudu_range_partitioning\"><div class=\"hue-doc-title\">Range Partitioning</div><div><p>\n            Range partitioning lets you specify partitioning precisely, based on single values or ranges\n            of values within one or more columns. You add one or more <span class=\"hue-doc-codeph\">RANGE</span> clauses to the\n            <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement, following the <span class=\"hue-doc-codeph\">PARTITION BY</span>\n            clause.\n          </p><p>\n            Range-partitioned Kudu tables use one or more range clauses, which include a\n            combination of constant expressions, <span class=\"hue-doc-codeph\">VALUE</span> or <span class=\"hue-doc-codeph\">VALUES</span>\n            keywords, and comparison operators. (This syntax replaces the <span class=\"hue-doc-codeph\">SPLIT\n            ROWS</span> clause used with early Kudu versions.)\n            For the full syntax, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE Statement</a>.\n          </p><div class=\"hue-doc-codeblock\">-- 50 buckets, all for IDs beginning with a lowercase letter.\n-- Having only a single range enforces the allowed range of values\n-- but does not add any extra parallelism.\ncreate table million_rows_one_range (id string primary key, s string)\n  partition by hash(id) partitions 50,\n  range (partition 'a' &lt;= values &lt; '{')\n  stored as kudu;\n\n-- 50 buckets for IDs beginning with a lowercase letter\n-- plus 50 buckets for IDs beginning with an uppercase letter.\n-- Total number of buckets = number in the PARTITIONS clause x number of ranges.\n-- We are still enforcing constraints on the primary key values\n-- allowed in the table, and the 2 ranges provide better parallelism\n-- as rows are inserted or the table is scanned.\ncreate table million_rows_two_ranges (id string primary key, s string)\n  partition by hash(id) partitions 50,\n  range (partition 'a' &lt;= values &lt; '{', partition 'A' &lt;= values &lt; '[')\n  stored as kudu;\n\n-- Same as previous table, with an extra range covering the single key value '00000'.\ncreate table million_rows_three_ranges (id string primary key, s string)\n  partition by hash(id) partitions 50,\n  range (partition 'a' &lt;= values &lt; '{', partition 'A' &lt;= values &lt; '[', partition value = '00000')\n  stored as kudu;\n\n-- The range partitioning can be displayed with a SHOW command in impala-shell.\nshow range partitions million_rows_three_ranges;\n+---------------------+\n| RANGE (id)          |\n+---------------------+\n| VALUE = \"00000\"     |\n| \"A\" &lt;= VALUES &lt; \"[\" |\n| \"a\" &lt;= VALUES &lt; \"{\" |\n+---------------------+\n</div><div class=\"hue-doc-note\"><p>\n              When defining ranges, be careful to avoid <q>fencepost errors</q> where values at the\n              extreme ends might be included or omitted by accident. For example, in the tables defined\n              in the preceding code listings, the range <span class=\"hue-doc-codeph\">\"a\" &lt;= VALUES &lt; \"{\"</span> ensures that\n              any values starting with <span class=\"hue-doc-codeph\">z</span>, such as <span class=\"hue-doc-codeph\">za</span> or <span class=\"hue-doc-codeph\">zzz</span>\n              or <span class=\"hue-doc-codeph\">zzz-ZZZ</span>, are all included, by using a less-than operator for the smallest\n              value after all the values starting with <span class=\"hue-doc-codeph\">z</span>.\n            </p></div><p>\n            For range-partitioned Kudu tables, an appropriate range must exist before a data value can be created in the table.\n            Any <span class=\"hue-doc-codeph\">INSERT</span>, <span class=\"hue-doc-codeph\">UPDATE</span>, or <span class=\"hue-doc-codeph\">UPSERT</span> statements fail if they try to\n            create column values that fall outside the specified ranges. The error checking for ranges is performed on the\n            Kudu side; Impala passes the specified range information to Kudu, and passes back any error or warning if the\n            ranges are not valid. (A nonsensical range specification causes an error for a DDL statement, but only a warning\n            for a DML statement.)\n          </p><p>\n            Ranges can be non-contiguous:\n          </p><div class=\"hue-doc-codeblock\">partition by range (year) (partition 1885 &lt;= values &lt;= 1889, partition 1893 &lt;= values &lt;= 1897)\n\npartition by range (letter_grade) (partition value = 'A', partition value = 'B',\n  partition value = 'C', partition value = 'D', partition value = 'F')\n</div><p>\n            The <span class=\"hue-doc-codeph\">ALTER TABLE</span> statement with the <span class=\"hue-doc-codeph\">ADD PARTITION</span> or\n            <span class=\"hue-doc-codeph\">DROP PARTITION</span> clauses can be used to add or remove ranges from an\n            existing Kudu table.\n          </p><div class=\"hue-doc-codeblock\">ALTER TABLE foo ADD PARTITION 30 &lt;= VALUES &lt; 50;\nALTER TABLE foo DROP PARTITION 1 &lt;= VALUES &lt; 5;\n</div><p>\n            When a range is added, the new range must not overlap with any of the previous ranges;\n            that is, it can only fill in gaps within the previous ranges.\n          </p><div class=\"hue-doc-codeblock\">alter table test_scores add range partition value = 'E';\n\nalter table year_ranges add range partition 1890 &lt;= values &lt; 1893;\n</div><p>\n            When a range is removed, all the associated rows in the table are deleted. (This\n            is true whether the table is internal or external.)\n          </p><div class=\"hue-doc-codeblock\">alter table test_scores drop range partition value = 'E';\n\nalter table year_ranges drop range partition 1890 &lt;= values &lt; 1893;\n</div><p>\n          Kudu tables can also use a combination of hash and range partitioning.\n        </p><div class=\"hue-doc-codeblock\">partition by hash (school) partitions 10,\n  range (letter_grade) (partition value = 'A', partition value = 'B',\n    partition value = 'C', partition value = 'D', partition value = 'F')\n</div></div></div><div id=\"kudu_partitioning_misc\"><div class=\"hue-doc-title\">Working with Partitioning in Kudu Tables</div><div><p>\n            To see the current partitioning scheme for a Kudu table, you can use the <span class=\"hue-doc-codeph\">SHOW\n            CREATE TABLE</span> statement or the <span class=\"hue-doc-codeph\">SHOW PARTITIONS</span> statement. The\n            <span class=\"hue-doc-codeph\">CREATE TABLE</span> syntax displayed by this statement includes all the\n            hash, range, or both clauses that reflect the original table structure plus any\n            subsequent <span class=\"hue-doc-codeph\">ALTER TABLE</span> statements that changed the table structure.\n          </p><p>\n            To see the underlying buckets and partitions for a Kudu table, use the\n            <span class=\"hue-doc-codeph\">SHOW TABLE STATS</span> or <span class=\"hue-doc-codeph\">SHOW PARTITIONS</span> statement.\n          </p></div></div></div><div id=\"kudu_timestamps\"><div class=\"hue-doc-title\">Handling Date, Time, or Timestamp Data with Kudu</div><div><p id=\"kudu_timestamp_details\">\n        In Impala 2.9 and higher, you can include\n        <span class=\"hue-doc-codeph\">TIMESTAMP</span> columns in Kudu tables, instead of representing the date and\n        time as a <span class=\"hue-doc-codeph\">BIGINT</span> value. The behavior of <span class=\"hue-doc-codeph\">TIMESTAMP</span> for\n        Kudu tables has some special considerations:\n        <ul><li><p>\n              Any nanoseconds in the original 96-bit value produced by Impala are not stored,\n              because Kudu represents date/time columns using 64-bit values. The nanosecond\n              portion of the value is rounded, not truncated. Therefore, a\n              <span class=\"hue-doc-codeph\">TIMESTAMP</span> value that you store in a Kudu table might not be\n              bit-for-bit identical to the value returned by a query.\n            </p></li><li><p>\n              The conversion between the Impala 96-bit representation and the Kudu 64-bit\n              representation introduces some performance overhead when reading or writing\n              <span class=\"hue-doc-codeph\">TIMESTAMP</span> columns. You can minimize the overhead during writes by\n              performing inserts through the Kudu API. Because the overhead during reads applies\n              to each query, you might continue to use a <span class=\"hue-doc-codeph\">BIGINT</span> column to\n              represent date/time values in performance-critical applications.\n            </p></li><li><p>\n              The Impala <span class=\"hue-doc-codeph\">TIMESTAMP</span> type has a narrower range for years than the\n              underlying Kudu data type. Impala can represent years 1400-9999. If year values\n              outside this range are written to a Kudu table by a non-Impala client, Impala\n              returns <span class=\"hue-doc-codeph\">NULL</span> by default when reading those\n              <span class=\"hue-doc-codeph\">TIMESTAMP</span> values during a query. Or, if the\n              <span class=\"hue-doc-codeph\">ABORT_ON_ERROR</span> query option is enabled, the query fails when it\n              encounters a value with an out-of-range year.\n            </p></li></ul></p><div class=\"hue-doc-codeblock\">--- Make a table representing a date/time value as TIMESTAMP.\n-- The strings representing the partition bounds are automatically\n-- cast to TIMESTAMP values.\ncreate table native_timestamp(id bigint, when_exactly timestamp, event string, primary key (id, when_exactly))\n  partition by hash (id) partitions 20,\n  range (when_exactly)\n  (\n    partition '2015-01-01' &lt;= values &lt; '2016-01-01',\n    partition '2016-01-01' &lt;= values &lt; '2017-01-01',\n    partition '2017-01-01' &lt;= values &lt; '2018-01-01'\n  )\n  stored as kudu;\n\ninsert into native_timestamp values (12345, now(), 'Working on doc examples');\n\nselect * from native_timestamp;\n+-------+-------------------------------+-------------------------+\n| id    | when_exactly                  | event                   |\n+-------+-------------------------------+-------------------------+\n| 12345 | 2017-05-31 16:27:42.667542000 | Working on doc examples |\n+-------+-------------------------------+-------------------------+\n</div><p>\n          Because Kudu tables have some performance overhead to convert <span class=\"hue-doc-codeph\">TIMESTAMP</span>\n          columns to the Impala 96-bit internal representation, for performance-critical\n          applications you might store date/time information as the number\n          of seconds, milliseconds, or microseconds since the Unix epoch date of January 1,\n          1970. Specify the column as <span class=\"hue-doc-codeph\">BIGINT</span> in the Impala <span class=\"hue-doc-codeph\">CREATE\n          TABLE</span> statement, corresponding to an 8-byte integer (an\n          <span class=\"hue-doc-codeph\">int64</span>) in the underlying Kudu table). Then use Impala date/time\n          conversion functions as necessary to produce a numeric, <span class=\"hue-doc-codeph\">TIMESTAMP</span>,\n          or <span class=\"hue-doc-codeph\">STRING</span> value depending on the context.\n        </p><p>\n          For example, the <span class=\"hue-doc-codeph\">unix_timestamp()</span> function returns an integer result\n          representing the number of seconds past the epoch. The <span class=\"hue-doc-codeph\">now()</span> function\n          produces a <span class=\"hue-doc-codeph\">TIMESTAMP</span> representing the current date and time, which can\n          be passed as an argument to <span class=\"hue-doc-codeph\">unix_timestamp()</span>. And string literals\n          representing dates and date/times can be cast to <span class=\"hue-doc-codeph\">TIMESTAMP</span>, and from there\n          converted to numeric values. The following examples show how you might store a date/time\n          column as <span class=\"hue-doc-codeph\">BIGINT</span> in a Kudu table, but still use string literals and\n          <span class=\"hue-doc-codeph\">TIMESTAMP</span> values for convenience.\n        </p><div class=\"hue-doc-codeblock\">-- now() returns a TIMESTAMP and shows the format for string literals you can cast to TIMESTAMP.\nselect now();\n+-------------------------------+\n| now()                         |\n+-------------------------------+\n| 2017-01-25 23:50:10.132385000 |\n+-------------------------------+\n\n-- unix_timestamp() accepts either a TIMESTAMP or an equivalent string literal.\nselect unix_timestamp(now());\n+------------------+\n| unix_timestamp() |\n+------------------+\n| 1485386670       |\n+------------------+\n\nselect unix_timestamp('2017-01-01');\n+------------------------------+\n| unix_timestamp('2017-01-01') |\n+------------------------------+\n| 1483228800                   |\n+------------------------------+\n\n-- Make a table representing a date/time value as BIGINT.\n-- Construct 1 range partition and 20 associated hash partitions for each year.\n-- Use date/time conversion functions to express the ranges as human-readable dates.\ncreate table time_series(id bigint, when_exactly bigint, event string, primary key (id, when_exactly))\n  partition by hash (id) partitions 20,\n  range (when_exactly)\n  (\n    partition unix_timestamp('2015-01-01') &lt;= values &lt; unix_timestamp('2016-01-01'),\n    partition unix_timestamp('2016-01-01') &lt;= values &lt; unix_timestamp('2017-01-01'),\n    partition unix_timestamp('2017-01-01') &lt;= values &lt; unix_timestamp('2018-01-01')\n  )\n  stored as kudu;\n\n-- On insert, we can transform a human-readable date/time into a numeric value.\ninsert into time_series values (12345, unix_timestamp('2017-01-25 23:24:56'), 'Working on doc examples');\n\n-- On retrieval, we can examine the numeric date/time value or turn it back into a string for readability.\nselect id, when_exactly, from_unixtime(when_exactly) as 'human-readable date/time', event\n  from time_series order by when_exactly limit 100;\n+-------+--------------+--------------------------+-------------------------+\n| id    | when_exactly | human-readable date/time | event                   |\n+-------+--------------+--------------------------+-------------------------+\n| 12345 | 1485386696   | 2017-01-25 23:24:56      | Working on doc examples |\n+-------+--------------+--------------------------+-------------------------+\n</div><div class=\"hue-doc-note\"><p>\n            If you do high-precision arithmetic involving numeric date/time values,\n            when dividing millisecond values by 1000, or microsecond values by 1 million, always\n            cast the integer numerator to a <span class=\"hue-doc-codeph\">DECIMAL</span> with sufficient precision\n            and scale to avoid any rounding or loss of precision.\n          </p></div><div class=\"hue-doc-codeblock\">-- 1 million and 1 microseconds = 1.000001 seconds.\nselect microseconds,\n  cast (microseconds as decimal(20,7)) / 1e6 as fractional_seconds\n  from table_with_microsecond_column;\n+--------------+----------------------+\n| microseconds | fractional_seconds   |\n+--------------+----------------------+\n| 1000001      | 1.000001000000000000 |\n+--------------+----------------------+\n</div></div></div><div id=\"kudu_metadata\"><div class=\"hue-doc-title\">How Impala Handles Kudu Metadata</div><div><div class=\"hue-doc-note\">This section only applies the Kudu services that are not\n          integrated with the Hive Metastore (HMS).</div><p id=\"kudu_metadata_intro\">By default, much of the metadata\n        for Kudu tables is handled by the underlying storage layer. Kudu tables\n        have less reliance on the Metastore database, and require less metadata\n        caching on the Impala side. For example, information about partitions in\n        Kudu tables is managed by Kudu, and Impala does not cache any block\n        locality metadata for Kudu tables. If the Kudu service is not integrated\n        with the Hive Metastore, Impala will manage Kudu table metadata in the\n        Hive Metastore.</p><p id=\"kudu_metadata_details\">\n        The <span class=\"hue-doc-codeph\">REFRESH</span> and <span class=\"hue-doc-codeph\">INVALIDATE METADATA</span> statements are\n        needed less frequently for Kudu tables than for HDFS-backed tables. Neither statement is\n        needed when data is added to, removed, or updated in a Kudu table, even if the changes\n        are made directly to Kudu through a client program using the Kudu API. Run\n        <span class=\"hue-doc-codeph\">REFRESH <span class=\"hue-doc-varname\">table_name</span></span> or <span class=\"hue-doc-codeph\">INVALIDATE METADATA\n        <span class=\"hue-doc-varname\">table_name</span></span> for a Kudu table only after making a change to\n        the Kudu table schema, such as adding or dropping a column.\n      </p><p> Because Kudu manages the metadata for its own tables separately from\n          the metastore database, there is a table name stored in the metastore\n          database for Impala to use, and a table name on the Kudu side, and\n          these names can be modified independently through <span class=\"hue-doc-codeph\">ALTER\n            TABLE</span> statements. </p><p> To avoid potential name conflicts, the prefix\n            <span class=\"hue-doc-codeph\">impala::</span> and the Impala database name are encoded\n          into the underlying Kudu table name: </p><div class=\"hue-doc-codeblock\">create database some_database;\nuse some_database;\n\ncreate table table_name_demo (x int primary key, y int)\n  partition by hash (x) partitions 2 stored as kudu;\n\ndescribe formatted table_name_demo;\n...\nkudu.table_name  | impala::some_database.table_name_demo\n</div><p> See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tables.xml\" data-doc-anchor-id=\"kudu_tables\">Kudu Tables</a> for examples of how to change the\n          name of the Impala table in the metastore database, the name of the\n          underlying Kudu table, or both. </p></div></div></div><div id=\"kudu_hms\"><div class=\"hue-doc-title\">Working with Kudu Integrated with Hive Metastore</div><div><p>Starting from Kudu 1.10 and Impala 3.3, Impala supports Kudu services\n        integrated with the Hive Metastore (HMS). See <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/docs/hive_metastore.html#hive_metastore\" target=\"_blank\">the HMS integration\n          documentation</a> for more details on Kudu’s Hive Metastore\n        integration.</p><p>The following are some of the changes you need to consider when working\n        with Kudu services integrated with the HMS.<ul><li> When Kudu is integrated with the Hive Metastore, Impala must be\n            configured to use the same HMS as Kudu.</li><li> Since there may be no one-to-one mapping between Kudu tables and\n            external tables, only internal tables are automatically\n            synchronized. </li><li>When you create a table in Kudu, Kudu will create an HMS entry for\n            that table with the internal table type.</li><li>When the Kudu service is integrated with the HMS, internal table\n            entries will be created automatically in the HMS when tables are\n            created in Kudu without Impala. To access these tables through\n            Impala, run <span class=\"hue-doc-codeph\">INVALIDATE METADATA</span> statement so Impala\n            picks up the latest metadata.</li></ul></p></div></div><div id=\"kudu_etl\"><div class=\"hue-doc-title\">Loading Data into Kudu Tables</div><div><p>\n        Kudu tables are well-suited to use cases where data arrives continuously, in small or\n        moderate volumes. To bring data into Kudu tables, use the Impala <span class=\"hue-doc-codeph\">INSERT</span>\n        and <span class=\"hue-doc-codeph\">UPSERT</span> statements. The <span class=\"hue-doc-codeph\">LOAD DATA</span> statement does\n        not apply to Kudu tables.\n      </p><p>\n        Because Kudu manages its own storage layer that is optimized for smaller block sizes than\n        HDFS, and performs its own housekeeping to keep data evenly distributed, it is not\n        subject to the <q>many small files</q> issue and does not need explicit reorganization\n        and compaction as the data grows over time. The partitions within a Kudu table can be\n        specified to cover a variety of possible data distributions, instead of hardcoding a new\n        partition for each new day, hour, and so on, which can lead to inefficient,\n        hard-to-scale, and hard-to-manage partition schemes with HDFS tables.\n      </p><p>\n        Your strategy for performing ETL or bulk updates on Kudu tables should take into account\n        the limitations on consistency for DML operations.\n      </p><p>\n        Make <span class=\"hue-doc-codeph\">INSERT</span>, <span class=\"hue-doc-codeph\">UPDATE</span>, and <span class=\"hue-doc-codeph\">UPSERT</span>\n        operations <span class=\"hue-doc-term\">idempotent</span>: that is, able to be applied multiple times and still\n        produce an identical result.\n      </p><p>\n        If a bulk operation is in danger of exceeding capacity limits due to timeouts or high\n        memory usage, split it into a series of smaller operations.\n      </p><p>\n        Avoid running concurrent ETL operations where the end results depend on precise\n        ordering. In particular, do not rely on an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement\n        that selects from the same table into which it is inserting, unless you include extra\n        conditions in the <span class=\"hue-doc-codeph\">WHERE</span> clause to avoid reading the newly inserted rows\n        within the same statement.\n      </p><p>\n        Because relationships between tables cannot be enforced by Impala and Kudu, and cannot\n        be committed or rolled back together, do not expect transactional semantics for\n        multi-table operations.\n      </p></div></div><div id=\"kudu_dml\"><div class=\"hue-doc-title\">Impala DML Support for Kudu Tables (INSERT, UPDATE, DELETE, UPSERT)</div><div><p>\n        Impala supports certain DML statements for Kudu tables only. The <span class=\"hue-doc-codeph\">UPDATE</span>\n        and <span class=\"hue-doc-codeph\">DELETE</span> statements let you modify data within Kudu tables without\n        rewriting substantial amounts of table data. The <span class=\"hue-doc-codeph\">UPSERT</span> statement acts\n        as a combination of <span class=\"hue-doc-codeph\">INSERT</span> and <span class=\"hue-doc-codeph\">UPDATE</span>, inserting rows\n        where the primary key does not already exist, and updating the non-primary key columns\n        where the primary key does already exist in the table.\n      </p><p>\n        The <span class=\"hue-doc-codeph\">INSERT</span> statement for Kudu tables honors the unique and <span class=\"hue-doc-codeph\">NOT\n        NULL</span> requirements for the primary key columns.\n      </p><p>\n        Because Impala and Kudu do not support transactions, the effects of any\n        <span class=\"hue-doc-codeph\">INSERT</span>, <span class=\"hue-doc-codeph\">UPDATE</span>, or <span class=\"hue-doc-codeph\">DELETE</span> statement\n        are immediately visible. For example, you cannot do a sequence of\n        <span class=\"hue-doc-codeph\">UPDATE</span> statements and only make the changes visible after all the\n        statements are finished. Also, if a DML statement fails partway through, any rows that\n        were already inserted, deleted, or changed remain in the table; there is no rollback\n        mechanism to undo the changes.\n      </p><p>\n        In particular, an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement that refers to the table\n        being inserted into might insert more rows than expected, because the\n        <span class=\"hue-doc-codeph\">SELECT</span> part of the statement sees some of the new rows being inserted\n        and processes them again.\n      </p><div class=\"hue-doc-note\"><p>\n          The <span class=\"hue-doc-codeph\">LOAD DATA</span> statement, which involves manipulation of HDFS data files,\n          does not apply to Kudu tables.\n        </p></div><p id=\"kudu_hints\">\n        Starting from Impala 2.9, the <span class=\"hue-doc-codeph\">INSERT</span> or\n        <span class=\"hue-doc-codeph\">UPSERT</span> operations into Kudu tables automatically add an exchange and a\n        sort node to the plan that partitions and sorts the rows according to the\n        partitioning/primary key scheme of the target table (unless the number of rows to be\n        inserted is small enough to trigger single node execution). Since Kudu partitions and\n        sorts rows on write, pre-partitioning and sorting takes some of the load off of Kudu and\n        helps large <span class=\"hue-doc-codeph\">INSERT</span> operations to complete without timing out. However,\n        this default behavior may slow down the end-to-end performance of the\n        <span class=\"hue-doc-codeph\">INSERT</span> or <span class=\"hue-doc-codeph\">UPSERT</span> operations. Starting\n        fromImpala 2.10, you can use the<span class=\"hue-doc-codeph\"> /*\n        +NOCLUSTERED */</span> and <span class=\"hue-doc-codeph\">/* +NOSHUFFLE */</span> hints together to disable\n        partitioning and sorting before the rows are sent to Kudu. Additionally, since sorting\n        may consume a large amount of memory, consider setting the <span class=\"hue-doc-codeph\">MEM_LIMIT</span>\n        query option for those queries.\n      </p></div></div><div id=\"kudu_consistency\"><div class=\"hue-doc-title\">Consistency Considerations for Kudu Tables</div><div><p>\n        Kudu tables have consistency characteristics such as uniqueness, controlled by the\n        primary key columns, and non-nullable columns. The emphasis for consistency is on\n        preventing duplicate or incomplete data from being stored in a table.\n      </p><p>\n        Currently, Kudu does not enforce strong consistency for order of operations, total\n        success or total failure of a multi-row statement, or data that is read while a write\n        operation is in progress. Changes are applied atomically to each row, but not applied\n        as a single unit to all rows affected by a multi-row DML statement. That is, Kudu does\n        not currently have atomic multi-row statements or isolation between statements.\n      </p><p>\n        If some rows are rejected during a DML operation because of a mismatch with duplicate\n        primary key values, <span class=\"hue-doc-codeph\">NOT NULL</span> constraints, and so on, the statement\n        succeeds with a warning. Impala still inserts, deletes, or updates the other rows that\n        are not affected by the constraint violation.\n      </p><p>\n        Consequently, the number of rows affected by a DML operation on a Kudu table might be\n        different than you expect.\n      </p><p>\n        Because there is no strong consistency guarantee for information being inserted into,\n        deleted from, or updated across multiple tables simultaneously, consider denormalizing\n        the data where practical. That is, if you run separate <span class=\"hue-doc-codeph\">INSERT</span>\n        statements to insert related rows into two different tables, one <span class=\"hue-doc-codeph\">INSERT</span>\n        might fail while the other succeeds, leaving the data in an inconsistent state. Even if\n        both inserts succeed, a join query might happen during the interval between the\n        completion of the first and second statements, and the query would encounter incomplete\n        inconsistent data. Denormalizing the data into a single wide table can reduce the\n        possibility of inconsistency due to multi-table operations.\n      </p><p>\n        Information about the number of rows affected by a DML operation is reported in\n        <span class=\"hue-doc-cmdname\">impala-shell</span> output, and in the <span class=\"hue-doc-codeph\">PROFILE</span> output, but\n        is not currently reported to HiveServer2 clients such as JDBC or ODBC applications.\n      </p></div></div><div id=\"kudu_security\"><div class=\"hue-doc-title\">Security Considerations for Kudu Tables</div><div><p>\n        Security for Kudu tables involves:\n      </p><ul><li><p>\n            Ranger authorization.\n          </p><p id=\"kudu_sentry_limitations\"> Access to Kudu tables must be granted to\n        and revoked from principal with the following considerations: <ul><li> Only users with the <span class=\"hue-doc-codeph\">ALL</span> privilege on <span class=\"hue-doc-codeph\">SERVER</span> can\n            create external Kudu tables. </li><li> The <span class=\"hue-doc-codeph\">ALL</span> privileges on <span class=\"hue-doc-codeph\">SERVER</span> is required to specify\n            the <span class=\"hue-doc-codeph\">kudu.master_addresses</span> property in the <span class=\"hue-doc-codeph\">CREATE TABLE</span>\n            statements for managed tables as well as external tables. </li><li> Access to Kudu tables is enforced at the table level and at the column level. </li><li> The <span class=\"hue-doc-codeph\">SELECT</span>- and <span class=\"hue-doc-codeph\">INSERT</span>-specific permissions are\n            supported. </li><li> The <span class=\"hue-doc-codeph\">DELETE</span>, <span class=\"hue-doc-codeph\">UPDATE</span>, and <span class=\"hue-doc-codeph\">UPSERT</span>\n            operations require the <span class=\"hue-doc-codeph\">ALL</span> privilege. </li></ul></p></li><li><p>\n            Kerberos authentication. See <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/docs/security.html\" target=\"_blank\">https://kudu.apache.org/docs/security.html</a> for details.\n          </p></li><li><p>\n            TLS encryption. See <a class=\"hue-doc-external-link\" href=\"https://kudu.apache.org/docs/security.html\" target=\"_blank\">https://kudu.apache.org/docs/security.html</a> for details.\n          </p></li><li><p>\n            Lineage tracking.\n          </p></li><li><p>\n            Auditing.\n          </p></li><li><p>\n            Redaction of sensitive information from log files.\n          </p></li></ul></div></div><div id=\"kudu_performance\"><div class=\"hue-doc-title\">Impala Query Performance for Kudu Tables</div><div><p>\n        For queries involving Kudu tables, Impala can delegate much of the work of filtering the\n        result set to Kudu, avoiding some of the I/O involved in full table scans of tables\n        containing HDFS data files. This type of optimization is especially effective for\n        partitioned Kudu tables, where the Impala query <span class=\"hue-doc-codeph\">WHERE</span> clause refers to\n        one or more primary key columns that are also used as partition key columns. For\n        example, if a partitioned Kudu table uses a <span class=\"hue-doc-codeph\">HASH</span> clause for\n        <span class=\"hue-doc-codeph\">col1</span> and a <span class=\"hue-doc-codeph\">RANGE</span> clause for <span class=\"hue-doc-codeph\">col2</span>, a\n        query using a clause such as <span class=\"hue-doc-codeph\">WHERE col1 IN (1,2,3) AND col2 &gt; 100</span>\n        can determine exactly which tablet servers contain relevant data, and therefore\n        parallelize the query very efficiently.\n      </p><p>\n        In Impala 2.11 and higher, Impala can push down additional\n        information to optimize join queries involving Kudu tables. If the join clause\n        contains predicates of the form\n        <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">column</span> = <span class=\"hue-doc-varname\">expression</span></span>,\n        after Impala constructs a hash table of possible matching values for the\n        join columns from the bigger table (either an HDFS table or a Kudu table), Impala\n        can <q>push down</q> the minimum and maximum matching column values to Kudu,\n        so that Kudu can more efficiently locate matching rows in the second (smaller) table.\n        These min/max filters are affected by the <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MODE</span>,\n        <span class=\"hue-doc-codeph\">RUNTIME_FILTER_WAIT_TIME_MS</span>, and <span class=\"hue-doc-codeph\">DISABLE_ROW_RUNTIME_FILTERING</span>\n        query options; the min/max filters are not affected by the\n        <span class=\"hue-doc-codeph\">RUNTIME_BLOOM_FILTER_SIZE</span>, <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MIN_SIZE</span>,\n        <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MAX_SIZE</span>, and <span class=\"hue-doc-codeph\">MAX_NUM_RUNTIME_FILTERS</span>\n        query options.\n      </p><p>\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_explain.xml\" data-doc-anchor-id=\"explain\">EXPLAIN Statement</a> for examples of evaluating the effectiveness of\n        the predicate pushdown for a specific query against a Kudu table.\n      </p><p id=\"tablesample_caveat\">\n        The <span class=\"hue-doc-codeph\">TABLESAMPLE</span> clause of the <span class=\"hue-doc-codeph\">SELECT</span> statement does\n        not apply to a table reference derived from a view, a subquery, or anything other than a\n        real base table. This clause only works for tables backed by HDFS or HDFS-like data\n        files, therefore it does not apply to Kudu or HBase tables.\n      </p></div><div style=\"display:none;\" id=\"kudu_vs_parquet\"><div class=\"hue-doc-title\">How Kudu Works with Column-Oriented Operations</div><div><p>\n          For immutable data, Impala is often used with Parquet tables due to the efficiency of\n          the column-oriented Parquet layout. This section describes how Kudu stores and\n          retrieves columnar data, to help you understand performance and storage considerations\n          of Kudu tables as compared with Parquet tables.\n        </p></div></div><div style=\"display:none;\" id=\"kudu_memory\"><div class=\"hue-doc-title\">Memory Usage for Operations on Kudu Tables</div><div><p>\n          The Apache Kudu architecture, topology, and data storage techniques result in\n          different patterns of memory usage for Impala statements than with HDFS-backed tables.\n        </p></div></div></div></div></div>","title":"Using Impala to Query Kudu Tables"}