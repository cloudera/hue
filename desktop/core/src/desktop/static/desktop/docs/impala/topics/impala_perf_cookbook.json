{"body":"<div><div id=\"perf_cookbook\"><div class=\"hue-doc-title\">Impala Performance Guidelines and Best Practices</div><div><p>\n      Here are performance guidelines and best practices that you can use during planning, experimentation, and\n      performance tuning for an Impala-enabled CDH cluster. All of this information is also available in more\n      detail elsewhere in the Impala documentation; it is gathered together here to serve as a cookbook and\n      emphasize which performance techniques typically provide the highest return on investment\n    </p><p/><div class=\"hue-doc-section\" id=\"perf_cookbook_file_format\"><div class=\"hue-doc-title\">Choose the appropriate file format for the data</div><p>\n        Typically, for large volumes of data (multiple gigabytes per table or partition), the Parquet file format\n        performs best because of its combination of columnar storage layout, large I/O request size, and\n        compression and encoding. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_file_formats.xml\" data-doc-anchor-id=\"file_formats\">How Impala Works with Hadoop File Formats</a> for comparisons of all\n        file formats supported by Impala, and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_parquet.xml\" data-doc-anchor-id=\"parquet\">Using the Parquet File Format with Impala Tables</a> for details about the\n        Parquet file format.\n      </p><div class=\"hue-doc-note\">        For smaller volumes of data, a few gigabytes or less for each table or partition, you might not see\n        significant performance differences between file formats. At small data volumes, reduced I/O from an\n        efficient compressed file format can be counterbalanced by reduced opportunity for parallel execution. When\n        planning for a production deployment or conducting benchmarks, always use realistic data volumes to get a\n        true picture of performance and scalability.\n      </div></div><div class=\"hue-doc-section\" id=\"perf_cookbook_small_files\"><div class=\"hue-doc-title\">Avoid data ingestion processes that produce many small files</div><p>\n        When producing data files outside of Impala, prefer either text format or Avro, where you can build up the\n        files row by row. Once the data is in Impala, you can convert it to the more efficient Parquet format and\n        split into multiple data files using a single <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement. Or, if you have\n        the infrastructure to produce multi-megabyte Parquet files as part of your data preparation process, do\n        that and skip the conversion step inside Impala.\n      </p><p>\n        Always use <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> to copy significant volumes of data from table to table\n        within Impala. Avoid <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> for any substantial volume of data or\n        performance-critical tables, because each such statement produces a separate tiny data file. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_insert.xml\" data-doc-anchor-id=\"insert\">INSERT Statement</a> for examples of the <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> syntax.\n      </p><p>\n        For example, if you have thousands of partitions in a Parquet table, each with less than\n        <span class=\"hue-doc-ph\">256 MB</span> of data, consider partitioning in a less granular way, such as by\n        year / month rather than year / month / day. If an inefficient data ingestion process produces thousands of\n        data files in the same table or partition, consider compacting the data by performing an <span class=\"hue-doc-codeph\">INSERT ...\n        SELECT</span> to copy all the data to a different table; the data will be reorganized into a smaller\n        number of larger files by this process.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_partitioning\"><div class=\"hue-doc-title\">Choose partitioning granularity based on actual data volume</div><p>\n        Partitioning is a technique that physically divides the data based on values of one or more columns, such\n        as by year, month, day, region, city, section of a web site, and so on. When you issue queries that request\n        a specific value or range of values for the partition key columns, Impala can avoid reading the irrelevant\n        data, potentially yielding a huge savings in disk I/O.\n      </p><p>\n        When deciding which column(s) to use for partitioning, choose the right level of granularity. For example,\n        should you partition by year, month, and day, or only by year and month? Choose a partitioning strategy\n        that puts at least <span class=\"hue-doc-ph\">256 MB</span> of data in each partition, to take advantage of\n        HDFS bulk I/O and Impala distributed queries.\n      </p><p>\n        Over-partitioning can also cause query planning to take longer than necessary, as Impala prunes the\n        unnecessary partitions. Ideally, keep the number of partitions in the table under 30 thousand.\n      </p><p>\n        When preparing data files to go in a partition directory, create several large files rather than many small\n        ones. If you receive data in the form of many small files and have no control over the input format,\n        consider using the <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> syntax to copy data from one table or partition to\n        another, which compacts the files into a relatively small number (based on the number of nodes in the\n        cluster).\n      </p><p>\n        If you need to reduce the overall number of partitions and increase the amount of data in each partition,\n        first look for partition key columns that are rarely referenced or are referenced in non-critical queries\n        (not subject to an SLA). For example, your web site log data might be partitioned by year, month, day, and\n        hour, but if most queries roll up the results by day, perhaps you only need to partition by year, month,\n        and day.\n      </p><p>\n        If you need to reduce the granularity even more, consider creating <q>buckets</q>, computed values\n        corresponding to different sets of partition key values. For example, you can use the\n        <span class=\"hue-doc-codeph\">TRUNC()</span> function with a <span class=\"hue-doc-codeph\">TIMESTAMP</span> column to group date and time values\n        based on intervals such as week or quarter. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_datetime_functions.xml\" data-doc-anchor-id=\"datetime_functions\">Impala Date and Time Functions</a> for details.\n      </p><p>\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"partitioning\">Partitioning for Impala Tables</a> for full details and performance considerations for\n        partitioning.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_partition_keys\"><div class=\"hue-doc-title\">Use smallest appropriate integer types for partition key columns</div><p>\n        Although it is tempting to use strings for partition key columns, since those values are turned into HDFS\n        directory names anyway, you can minimize memory usage by using numeric values for common partition key\n        fields such as <span class=\"hue-doc-codeph\">YEAR</span>, <span class=\"hue-doc-codeph\">MONTH</span>, and <span class=\"hue-doc-codeph\">DAY</span>. Use the smallest\n        integer type that holds the appropriate range of values, typically <span class=\"hue-doc-codeph\">TINYINT</span> for\n        <span class=\"hue-doc-codeph\">MONTH</span> and <span class=\"hue-doc-codeph\">DAY</span>, and <span class=\"hue-doc-codeph\">SMALLINT</span> for <span class=\"hue-doc-codeph\">YEAR</span>.\n        Use the <span class=\"hue-doc-codeph\">EXTRACT()</span> function to pull out individual date and time fields from a\n        <span class=\"hue-doc-codeph\">TIMESTAMP</span> value, and <span class=\"hue-doc-codeph\">CAST()</span> the return value to the appropriate integer\n        type.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_parquet_block_size\"><div class=\"hue-doc-title\">Choose an appropriate Parquet block size</div><p>\n        By default, the Impala <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement creates Parquet files with a 256 MB\n        block size. (This default was changed in Impala 2.0. Formerly, the limit was 1 GB, but Impala made\n        conservative estimates about compression, resulting in files that were smaller than 1 GB.)\n      </p><p>\n        Each Parquet file written by Impala is a single block, allowing the whole file to be processed as a unit by a single host.\n        As you copy Parquet files into HDFS or between HDFS filesystems, use <span class=\"hue-doc-codeph\">hdfs dfs -pb</span> to preserve the original\n        block size.\n      </p><p>\n        If there is only one or a few data block in your Parquet table, or in a partition that is the only one\n        accessed by a query, then you might experience a slowdown for a different reason: not enough data to take\n        advantage of Impala's parallel distributed queries. Each data block is processed by a single core on one of\n        the DataNodes. In a 100-node cluster of 16-core machines, you could potentially process thousands of data\n        files simultaneously. You want to find a sweet spot between <q>many tiny files</q> and <q>single giant\n        file</q> that balances bulk I/O and parallel processing. You can set the <span class=\"hue-doc-codeph\">PARQUET_FILE_SIZE</span>\n        query option before doing an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement to reduce the size of each\n        generated Parquet file. <span class=\"hue-doc-ph\">(Specify the file size as an absolute number of bytes, or in Impala\n        2.0 and later, in units ending with <span class=\"hue-doc-codeph\">m</span> for megabytes or <span class=\"hue-doc-codeph\">g</span> for\n        gigabytes.)</span> Run benchmarks with different file sizes to find the right balance point for your\n        particular data volume.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_stats\"><div class=\"hue-doc-title\">Gather statistics for all tables used in performance-critical or high-volume join queries</div><p>\n        Gather the statistics with the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_perf_joins.xml\" data-doc-anchor-id=\"perf_joins\">Performance Considerations for Join Queries</a> for details.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_network\"><div class=\"hue-doc-title\">Minimize the overhead of transmitting results back to the client</div><p>\n        Use techniques such as:\n      </p><ul><li>\n          Aggregation. If you need to know how many rows match a condition, the total values of matching values\n          from some column, the lowest or highest matching value, and so on, call aggregate functions such as\n          <span class=\"hue-doc-codeph\">COUNT()</span>, <span class=\"hue-doc-codeph\">SUM()</span>, and <span class=\"hue-doc-codeph\">MAX()</span> in the query rather than\n          sending the result set to an application and doing those computations there. Remember that the size of an\n          unaggregated result set could be huge, requiring substantial time to transmit across the network.\n        </li><li>\n          Filtering. Use all applicable tests in the <span class=\"hue-doc-codeph\">WHERE</span> clause of a query to eliminate rows\n          that are not relevant, rather than producing a big result set and filtering it using application logic.\n        </li><li><span class=\"hue-doc-codeph\">LIMIT</span> clause. If you only need to see a few sample values from a result set, or the top\n          or bottom values from a query using <span class=\"hue-doc-codeph\">ORDER BY</span>, include the <span class=\"hue-doc-codeph\">LIMIT</span> clause\n          to reduce the size of the result set rather than asking for the full result set and then throwing most of\n          the rows away.\n        </li><li>\n          Avoid overhead from pretty-printing the result set and displaying it on the screen. When you retrieve the\n          results through <span class=\"hue-doc-cmdname\">impala-shell</span>, use <span class=\"hue-doc-cmdname\">impala-shell</span> options such as\n          <span class=\"hue-doc-codeph\">-B</span> and <span class=\"hue-doc-codeph\">--output_delimiter</span> to produce results without special\n          formatting, and redirect output to a file rather than printing to the screen. Consider using\n          <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> to write the results directly to new files in HDFS. See\n          <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_shell_options.xml\" data-doc-anchor-id=\"shell_options\">impala-shell Configuration Options</a> for details about the\n          <span class=\"hue-doc-cmdname\">impala-shell</span> command-line options.\n        </li></ul></div><div class=\"hue-doc-section\" id=\"perf_cookbook_explain\"><div class=\"hue-doc-title\">Verify that your queries are planned in an efficient logical manner</div><p>\n        Examine the <span class=\"hue-doc-codeph\">EXPLAIN</span> plan for a query before actually running it. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_explain.xml\" data-doc-anchor-id=\"explain\">EXPLAIN Statement</a> and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_explain_plan.xml\" data-doc-anchor-id=\"perf_explain\">Using the EXPLAIN Plan for Performance Tuning</a> for\n        details.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_profile\"><div class=\"hue-doc-title\">Verify performance characteristics of queries</div><p>\n        Verify that the low-level aspects of I/O, memory usage, network bandwidth, CPU utilization, and so on are\n        within expected ranges by examining the query profile for a query after running it. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_explain_plan.xml\" data-doc-anchor-id=\"perf_profile\">Using the Query Profile for Performance Tuning</a> for details.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_os\"><div class=\"hue-doc-title\">Use appropriate operating system settings</div><p>\n        See \n    the documentation for your Apache Hadoop distribution\n   for recommendations about operating system\n        settings that you can change to influence Impala performance. In particular, you might find\n        that changing the <span class=\"hue-doc-codeph\">vm.swappiness</span> Linux kernel setting to a non-zero value improves\n        overall performance.\n      </p></div><div class=\"hue-doc-section\" id=\"perf_cookbook_hotspot\"><div class=\"hue-doc-title\">Hotspot analysis</div><p>\n        In the context of Impala, a hotspot is defined as “an Impala daemon\n        that for a single query or a workload is spending a far greater amount\n        of time processing data relative to its neighbours”.\n      </p><p>\n        Before discussing the options to tackle this issue some background is\n        first required to understand how this problem can occur.\n      </p><p>\n        By default, the scheduling of scan based plan fragments is\n        deterministic. This means that for multiple queries needing to read the\n        same block of data, the same node will be picked to host the scan. The\n        default scheduling logic does not take into account node workload from\n        prior queries. The complexity of materializing a tuple depends on a few\n        factors, namely: decoding and decompression. If the tuples are densely\n        packed into data pages due to good encoding/compression ratios, there\n        will be more work required when reconstructing the data. Each\n        compression codec offers different performance tradeoffs and should be\n        considered before writing the data. Due to the deterministic nature of\n        the scheduler, single nodes can become bottlenecks for highly concurrent\n        queries that use the same tables.\n      </p><p>\n        If, for example, a Parquet based dataset is tiny, e.g. a small\n        dimension table, such that it fits into a single HDFS block (Impala by\n        default will create 256 MB blocks when Parquet is used, each containing\n        a single row group) then there are a number of options that can be\n        considered to resolve the potential scheduling hotspots when querying\n        this data:\n      </p><ul><li>\n          In Impala 2.5 and higher, the scheduler’s\n          deterministic behaviour can be changed using the following query\n          options: <span class=\"hue-doc-codeph\">REPLICA_PREFERENCE</span> and\n            <span class=\"hue-doc-codeph\">RANDOM_REPLICA</span>. For a detailed description of each\n          of these modes see IMPALA-2696.\n        </li><li>\n          HDFS caching can be used to cache block replicas. This will cause\n          the Impala scheduler to randomly pick (from Impala 2.2 and higher) a node that is hosting a cached block replica for the\n          scan. Note, although HDFS caching has benefits, it serves only to help\n          with the reading of raw block data and not cached tuple data, but with\n          the right number of cached replicas (by default, HDFS only caches one\n          replica), even load distribution can be achieved for smaller\n          datasets.\n        </li><li>\n          Do not compress the table data. The uncompressed table data spans more\n          nodes and eliminates skew caused by compression.\n        </li><li>\n          Reduce the Parquet file size via the\n            <span class=\"hue-doc-codeph\">PARQUET_FILE_SIZE</span> query option when writing the\n          table data. Using this approach the data will span more nodes. However\n          it’s not recommended to drop the size below 32 MB.\n        </li></ul></div></div></div></div>","title":"Impala Performance Guidelines and Best Practices"}