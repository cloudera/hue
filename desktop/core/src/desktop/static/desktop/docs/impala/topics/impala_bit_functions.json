{"body":"<div><div><div class=\"hue-doc-title\">Impala Bit Functions</div><div><p>\n      Bit manipulation functions perform bitwise operations involved in scientific processing or computer science algorithms.\n      For example, these functions include setting, clearing, or testing bits within an integer value, or changing the\n      positions of bits with or without wraparound.\n    </p><p>\n      If a function takes two integer arguments that are required to be of the same type, the smaller argument is promoted\n      to the type of the larger one if required. For example, <span class=\"hue-doc-codeph\">BITAND(1,4096)</span> treats both arguments as\n      <span class=\"hue-doc-codeph\">SMALLINT</span>, because 1 can be represented as a <span class=\"hue-doc-codeph\">TINYINT</span> but 4096 requires a <span class=\"hue-doc-codeph\">SMALLINT</span>.\n    </p><p>\n     Remember that all Impala integer values are signed. Therefore, when dealing with binary values where the most significant\n     bit is 1, the specified or returned values might be negative when represented in base 10.\n    </p><p>\n      Whenever any argument is <span class=\"hue-doc-codeph\">NULL</span>, either the input value, bit position, or number of shift or rotate positions,\n      the return value from any of these functions is also <span class=\"hue-doc-codeph\">NULL</span></p><p><b>Related information:</b></p><p>\n      The bit functions operate on all the integral data types: <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_int.xml\" data-doc-anchor-id=\"int\">INT Data Type</a>,\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_bigint.xml\" data-doc-anchor-id=\"bigint\">BIGINT Data Type</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_smallint.xml\" data-doc-anchor-id=\"smallint\">SMALLINT Data Type</a>, and\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tinyint.xml\" data-doc-anchor-id=\"tinyint\">TINYINT Data Type</a>.\n    </p><p><b>Function reference:</b></p><p>\n      Impala supports the following bit functions:\n    </p><dl><dt><span class=\"hue-doc-codeph\">bitand(integer_type a, same_type b)</span></dt><dd><b>Purpose:</b> Returns an integer value representing the bits that are set to 1 in both of the arguments.\n          If the arguments are of different sizes, the smaller is promoted to the type of the larger.\n          <p><b>Usage notes:</b> The <span class=\"hue-doc-codeph\">bitand()</span> function is equivalent to the <span class=\"hue-doc-codeph\">&amp;</span> binary operator.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            The following examples show the results of ANDing integer values.\n            255 contains all 1 bits in its lowermost 7 bits.\n            32767 contains all 1 bits in its lowermost 15 bits.\n            \n            You can use the <span class=\"hue-doc-codeph\">bin()</span> function to check the binary representation of any\n            integer value, although the result is always represented as a 64-bit value.\n            If necessary, the smaller argument is promoted to the\n            type of the larger one.\n          </p><div class=\"hue-doc-codeblock\">select bitand(255, 32767); /* 0000000011111111 &amp; 0111111111111111 */\n+--------------------+\n| bitand(255, 32767) |\n+--------------------+\n| 255                |\n+--------------------+\n\nselect bitand(32767, 1); /* 0111111111111111 &amp; 0000000000000001 */\n+------------------+\n| bitand(32767, 1) |\n+------------------+\n| 1                |\n+------------------+\n\nselect bitand(32, 16); /* 00010000 &amp; 00001000 */\n+----------------+\n| bitand(32, 16) |\n+----------------+\n| 0              |\n+----------------+\n\nselect bitand(12,5); /* 00001100 &amp; 00000101 */\n+---------------+\n| bitand(12, 5) |\n+---------------+\n| 4             |\n+---------------+\n\nselect bitand(-1,15); /* 11111111 &amp; 00001111 */\n+----------------+\n| bitand(-1, 15) |\n+----------------+\n| 15             |\n+----------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">bitnot(integer_type a)</span></dt><dd><b>Purpose:</b> Inverts all the bits of the input argument.\n          <p><b>Usage notes:</b> The <span class=\"hue-doc-codeph\">bitnot()</span> function is equivalent to the <span class=\"hue-doc-codeph\">~</span> unary operator.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            These examples illustrate what happens when you flip all the bits of an integer value.\n            The sign always changes. The decimal representation is one different between the positive and\n            negative values.\n            </p><div class=\"hue-doc-codeblock\">select bitnot(127); /* 01111111 -&gt; 10000000 */\n+-------------+\n| bitnot(127) |\n+-------------+\n| -128        |\n+-------------+\n\nselect bitnot(16); /* 00010000 -&gt; 11101111 */\n+------------+\n| bitnot(16) |\n+------------+\n| -17        |\n+------------+\n\nselect bitnot(0); /* 00000000 -&gt; 11111111 */\n+-----------+\n| bitnot(0) |\n+-----------+\n| -1        |\n+-----------+\n\nselect bitnot(-128); /* 10000000 -&gt; 01111111 */\n+--------------+\n| bitnot(-128) |\n+--------------+\n| 127          |\n+--------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">bitor(integer_type a, same_type b)</span></dt><dd><b>Purpose:</b> Returns an integer value representing the bits that are set to 1 in either of the arguments.\n          If the arguments are of different sizes, the smaller is promoted to the type of the larger.\n          <p><b>Usage notes:</b> The <span class=\"hue-doc-codeph\">bitor()</span> function is equivalent to the <span class=\"hue-doc-codeph\">|</span> binary operator.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            The following examples show the results of ORing integer values.\n          </p><div class=\"hue-doc-codeblock\">select bitor(1,4); /* 00000001 | 00000100 */\n+-------------+\n| bitor(1, 4) |\n+-------------+\n| 5           |\n+-------------+\n\nselect bitor(16,48); /* 00001000 | 00011000 */\n+---------------+\n| bitor(16, 48) |\n+---------------+\n| 48            |\n+---------------+\n\nselect bitor(0,7); /* 00000000 | 00000111 */\n+-------------+\n| bitor(0, 7) |\n+-------------+\n| 7           |\n+-------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">bitxor(integer_type a, same_type b)</span></dt><dd><b>Purpose:</b> Returns an integer value representing the bits that are set to 1 in one but not both of the arguments.\n          If the arguments are of different sizes, the smaller is promoted to the type of the larger.\n          <p><b>Usage notes:</b> The <span class=\"hue-doc-codeph\">bitxor()</span> function is equivalent to the <span class=\"hue-doc-codeph\">^</span> binary operator.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            The following examples show the results of XORing integer values.\n            XORing a non-zero value with zero returns the non-zero value.\n            XORing two identical values returns zero, because all the 1 bits from the first argument are also 1 bits in the second argument.\n            XORing different non-zero values turns off some bits and leaves others turned on, based on whether the same bit is set in both arguments.\n          </p><div class=\"hue-doc-codeblock\">select bitxor(0,15); /* 00000000 ^ 00001111 */\n+---------------+\n| bitxor(0, 15) |\n+---------------+\n| 15            |\n+---------------+\n\nselect bitxor(7,7); /* 00000111 ^ 00000111 */\n+--------------+\n| bitxor(7, 7) |\n+--------------+\n| 0            |\n+--------------+\n\nselect bitxor(8,4); /* 00001000 ^ 00000100 */\n+--------------+\n| bitxor(8, 4) |\n+--------------+\n| 12           |\n+--------------+\n\nselect bitxor(3,7); /* 00000011 ^ 00000111 */\n+--------------+\n| bitxor(3, 7) |\n+--------------+\n| 4            |\n+--------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">countset(integer_type a [, int zero_or_one])</span></dt><dd><b>Purpose:</b> By default, returns the number of 1 bits in the specified integer value.\n          If the optional second argument is set to zero, it returns the number of 0 bits instead.\n          <p><b>Usage notes:</b></p><p>\n            In discussions of information theory, this operation is referred to as the\n            <q><a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">population count</a></q>\n            or <q>popcount</q>.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            The following examples show how to count the number of 1 bits in an integer value.\n          </p><div class=\"hue-doc-codeblock\">select countset(1); /* 00000001 */\n+-------------+\n| countset(1) |\n+-------------+\n| 1           |\n+-------------+\n\nselect countset(3); /* 00000011 */\n+-------------+\n| countset(3) |\n+-------------+\n| 2           |\n+-------------+\n\nselect countset(16); /* 00010000 */\n+--------------+\n| countset(16) |\n+--------------+\n| 1            |\n+--------------+\n\nselect countset(17); /* 00010001 */\n+--------------+\n| countset(17) |\n+--------------+\n| 2            |\n+--------------+\n\nselect countset(7,1); /* 00000111 = 3 1 bits; the function counts 1 bits by default */\n+----------------+\n| countset(7, 1) |\n+----------------+\n| 3              |\n+----------------+\n\nselect countset(7,0); /* 00000111 = 5 0 bits; third argument can only be 0 or 1 */\n+----------------+\n| countset(7, 0) |\n+----------------+\n| 5              |\n+----------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">getbit(integer_type a, int position)</span></dt><dd><b>Purpose:</b> Returns a 0 or 1 representing the bit at a\n          specified position. The positions are numbered right to left, starting at zero.\n          The position argument cannot be negative.\n          <p><b>Usage notes:</b></p><p>\n            When you use a literal input value, it is treated as an 8-bit, 16-bit,\n            and so on value, the smallest type that is appropriate.\n            The type of the input value limits the range of the positions.\n            Cast the input value to the appropriate type if you need to\n            ensure it is treated as a 64-bit, 32-bit, and so on value.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><p>\n            The following examples show how to test a specific bit within an integer value.\n          </p><div class=\"hue-doc-codeblock\">select getbit(1,0); /* 00000001 */\n+--------------+\n| getbit(1, 0) |\n+--------------+\n| 1            |\n+--------------+\n\nselect getbit(16,1) /* 00010000 */\n+---------------+\n| getbit(16, 1) |\n+---------------+\n| 0             |\n+---------------+\n\nselect getbit(16,4) /* 00010000 */\n+---------------+\n| getbit(16, 4) |\n+---------------+\n| 1             |\n+---------------+\n\nselect getbit(16,5) /* 00010000 */\n+---------------+\n| getbit(16, 5) |\n+---------------+\n| 0             |\n+---------------+\n\nselect getbit(-1,3); /* 11111111 */\n+---------------+\n| getbit(-1, 3) |\n+---------------+\n| 1             |\n+---------------+\n\nselect getbit(-1,25); /* 11111111 */\nERROR: Invalid bit position: 25\n\nselect getbit(cast(-1 as int),25); /* 11111111111111111111111111111111 */\n+-----------------------------+\n| getbit(cast(-1 as int), 25) |\n+-----------------------------+\n| 1                           |\n+-----------------------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">rotateleft(integer_type a, int positions)</span></dt><dd><b>Purpose:</b> Rotates an integer value left by a specified number of bits.\n          As the most significant bit is taken out of the original value,\n          if it is a 1 bit, it is <q>rotated</q> back to the least significant bit.\n          Therefore, the final value has the same number of 1 bits as the original value,\n          just in different positions.\n          In computer science terms, this operation is a\n          <q><a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Circular_shift\" target=\"_blank\">circular shift</a></q>.\n          <p><b>Usage notes:</b></p><p>\n            Specifying a second argument of zero leaves the original value unchanged.\n            Rotating a -1 value by any number of positions still returns -1,\n            because the original value has all 1 bits and all the 1 bits are\n            preserved during rotation.\n            Similarly, rotating a 0 value by any number of positions still returns 0.\n            Rotating a value by the same number of bits as in the value returns the same value.\n            Because this is a circular operation, the number of positions is not limited\n            to the number of bits in the input value.\n            For example, rotating an 8-bit value by 1, 9, 17, and so on positions returns an\n            identical result in each case.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select rotateleft(1,4); /* 00000001 -&gt; 00010000 */\n+------------------+\n| rotateleft(1, 4) |\n+------------------+\n| 16               |\n+------------------+\n\nselect rotateleft(-1,155); /* 11111111 -&gt; 11111111 */\n+---------------------+\n| rotateleft(-1, 155) |\n+---------------------+\n| -1                  |\n+---------------------+\n\nselect rotateleft(-128,1); /* 10000000 -&gt; 00000001 */\n+---------------------+\n| rotateleft(-128, 1) |\n+---------------------+\n| 1                   |\n+---------------------+\n\nselect rotateleft(-127,3); /* 10000001 -&gt; 00001100 */\n+---------------------+\n| rotateleft(-127, 3) |\n+---------------------+\n| 12                  |\n+---------------------+\n\n</div></dd><dt><span class=\"hue-doc-codeph\">rotateright(integer_type a, int positions)</span></dt><dd><b>Purpose:</b> Rotates an integer value right by a specified number of bits.\n          As the least significant bit is taken out of the original value,\n          if it is a 1 bit, it is <q>rotated</q> back to the most significant bit.\n          Therefore, the final value has the same number of 1 bits as the original value,\n          just in different positions.\n          In computer science terms, this operation is a\n          <q><a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Circular_shift\" target=\"_blank\">circular shift</a></q>.\n          <p><b>Usage notes:</b></p><p>\n            Specifying a second argument of zero leaves the original value unchanged.\n            Rotating a -1 value by any number of positions still returns -1,\n            because the original value has all 1 bits and all the 1 bits are\n            preserved during rotation.\n            Similarly, rotating a 0 value by any number of positions still returns 0.\n            Rotating a value by the same number of bits as in the value returns the same value.\n            Because this is a circular operation, the number of positions is not limited\n            to the number of bits in the input value.\n            For example, rotating an 8-bit value by 1, 9, 17, and so on positions returns an\n            identical result in each case.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select rotateright(16,4); /* 00010000 -&gt; 00000001 */\n+--------------------+\n| rotateright(16, 4) |\n+--------------------+\n| 1                  |\n+--------------------+\n\nselect rotateright(-1,155); /* 11111111 -&gt; 11111111 */\n+----------------------+\n| rotateright(-1, 155) |\n+----------------------+\n| -1                   |\n+----------------------+\n\nselect rotateright(-128,1); /* 10000000 -&gt; 01000000 */\n+----------------------+\n| rotateright(-128, 1) |\n+----------------------+\n| 64                   |\n+----------------------+\n\nselect rotateright(-127,3); /* 10000001 -&gt; 00110000 */\n+----------------------+\n| rotateright(-127, 3) |\n+----------------------+\n| 48                   |\n+----------------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">setbit(integer_type a, int position [, int zero_or_one])</span></dt><dd><b>Purpose:</b> By default, changes a bit at a specified position to a 1, if it is not already.\n          If the optional third argument is set to zero, the specified bit is set to 0 instead.\n          <p><b>Usage notes:</b></p>\n          If the bit at the specified position was already 1 (by default)\n          or 0 (with a third argument of zero), the return value is\n          the same as the first argument.\n          The positions are numbered right to left, starting at zero.\n          (Therefore, the return value could be different from the first argument\n          even if the position argument is zero.)\n          The position argument cannot be negative.\n          <p>\n            When you use a literal input value, it is treated as an 8-bit, 16-bit,\n            and so on value, the smallest type that is appropriate.\n            The type of the input value limits the range of the positions.\n            Cast the input value to the appropriate type if you need to\n            ensure it is treated as a 64-bit, 32-bit, and so on value.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select setbit(0,0); /* 00000000 -&gt; 00000001 */\n+--------------+\n| setbit(0, 0) |\n+--------------+\n| 1            |\n+--------------+\n\nselect setbit(0,3); /* 00000000 -&gt; 00001000 */\n+--------------+\n| setbit(0, 3) |\n+--------------+\n| 8            |\n+--------------+\n\nselect setbit(7,3); /* 00000111 -&gt; 00001111 */\n+--------------+\n| setbit(7, 3) |\n+--------------+\n| 15           |\n+--------------+\n\nselect setbit(15,3); /* 00001111 -&gt; 00001111 */\n+---------------+\n| setbit(15, 3) |\n+---------------+\n| 15            |\n+---------------+\n\nselect setbit(0,32); /* By default, 0 is a TINYINT with only 8 bits. */\nERROR: Invalid bit position: 32\n\nselect setbit(cast(0 as bigint),32); /* For BIGINT, the position can be 0..63. */\n+-------------------------------+\n| setbit(cast(0 as bigint), 32) |\n+-------------------------------+\n| 4294967296                    |\n+-------------------------------+\n\nselect setbit(7,3,1); /* 00000111 -&gt; 00001111; setting to 1 is the default */\n+-----------------+\n| setbit(7, 3, 1) |\n+-----------------+\n| 15              |\n+-----------------+\n\nselect setbit(7,2,0); /* 00000111 -&gt; 00000011; third argument of 0 clears instead of sets */\n+-----------------+\n| setbit(7, 2, 0) |\n+-----------------+\n| 3               |\n+-----------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">shiftleft(integer_type a, int positions)</span></dt><dd><b>Purpose:</b> Shifts an integer value left by a specified number of bits.\n          As the most significant bit is taken out of the original value,\n          it is discarded and the least significant bit becomes 0.\n          In computer science terms, this operation is a <q><a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Logical_shift\" target=\"_blank\">logical shift</a></q>.\n          <p><b>Usage notes:</b></p><p>\n            The final value has either the same number of 1 bits as the original value, or fewer.\n            Shifting an 8-bit value by 8 positions, a 16-bit value by 16 positions, and so on produces\n            a result of zero.\n          </p><p>\n            Specifying a second argument of zero leaves the original value unchanged.\n            Shifting any value by 0 returns the original value.\n            Shifting any value by 1 is the same as multiplying it by 2,\n            as long as the value is small enough; larger values eventually\n            become negative when shifted, as the sign bit is set.\n            Starting with the value 1 and shifting it left by N positions gives\n            the same result as 2 to the Nth power, or <span class=\"hue-doc-codeph\">pow(2,<span class=\"hue-doc-varname\">N</span>)</span>.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select shiftleft(1,0); /* 00000001 -&gt; 00000001 */\n+-----------------+\n| shiftleft(1, 0) |\n+-----------------+\n| 1               |\n+-----------------+\n\nselect shiftleft(1,3); /* 00000001 -&gt; 00001000 */\n+-----------------+\n| shiftleft(1, 3) |\n+-----------------+\n| 8               |\n+-----------------+\n\nselect shiftleft(8,2); /* 00001000 -&gt; 00100000 */\n+-----------------+\n| shiftleft(8, 2) |\n+-----------------+\n| 32              |\n+-----------------+\n\nselect shiftleft(127,1); /* 01111111 -&gt; 11111110 */\n+-------------------+\n| shiftleft(127, 1) |\n+-------------------+\n| -2                |\n+-------------------+\n\nselect shiftleft(127,5); /* 01111111 -&gt; 11100000 */\n+-------------------+\n| shiftleft(127, 5) |\n+-------------------+\n| -32               |\n+-------------------+\n\nselect shiftleft(-1,4); /* 11111111 -&gt; 11110000 */\n+------------------+\n| shiftleft(-1, 4) |\n+------------------+\n| -16              |\n+------------------+\n</div></dd><dt><span class=\"hue-doc-codeph\">shiftright(integer_type a, int positions)</span></dt><dd><b>Purpose:</b> Shifts an integer value right by a specified number of bits.\n          As the least significant bit is taken out of the original value,\n          it is discarded and the most significant bit becomes 0.\n          In computer science terms, this operation is a <q><a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Logical_shift\" target=\"_blank\">logical shift</a></q>.\n          <p><b>Usage notes:</b></p><p>\n          Therefore, the final value has either the same number of 1 bits as the original value, or fewer.\n          Shifting an 8-bit value by 8 positions, a 16-bit value by 16 positions, and so on produces\n          a result of zero.\n          </p><p>\n            Specifying a second argument of zero leaves the original value unchanged.\n            Shifting any value by 0 returns the original value.\n            Shifting any positive value right by 1 is the same as dividing it by 2.\n            Negative values become positive when shifted right.\n          </p><p><b>Return type:</b> Same as the input value\n      </p><p><b>Added in:</b>Impala 2.3.0</p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select shiftright(16,0); /* 00010000 -&gt; 00010000 */\n+-------------------+\n| shiftright(16, 0) |\n+-------------------+\n| 16                |\n+-------------------+\n\nselect shiftright(16,4); /* 00010000 -&gt; 00000001 */\n+-------------------+\n| shiftright(16, 4) |\n+-------------------+\n| 1                 |\n+-------------------+\n\nselect shiftright(16,5); /* 00010000 -&gt; 00000000 */\n+-------------------+\n| shiftright(16, 5) |\n+-------------------+\n| 0                 |\n+-------------------+\n\nselect shiftright(-1,1); /* 11111111 -&gt; 01111111 */\n+-------------------+\n| shiftright(-1, 1) |\n+-------------------+\n| 127               |\n+-------------------+\n\nselect shiftright(-1,5); /* 11111111 -&gt; 00000111 */\n+-------------------+\n| shiftright(-1, 5) |\n+-------------------+\n| 7                 |\n+-------------------+\n</div></dd></dl></div></div></div>","title":"Impala Bit Functions"}