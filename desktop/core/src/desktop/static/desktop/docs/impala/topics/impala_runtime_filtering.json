{"body":"<div><div id=\"runtime_filtering\"><div class=\"hue-doc-title\" id=\"runtime_filters\">Runtime Filtering for Impala Queries (Impala 2.5 or higher only)</div><div><p><span class=\"hue-doc-term\">Runtime filtering</span> is a wide-ranging optimization feature available in\n      Impala 2.5 and higher. When only a fraction of the data in a table is\n      needed for a query against a partitioned table or to evaluate a join condition,\n      Impala determines the appropriate conditions while the query is running, and\n      broadcasts that information to all the <span class=\"hue-doc-cmdname\">impalad</span> nodes that are reading the table\n      so that they can avoid unnecessary I/O to read partition data, and avoid\n      unnecessary network transmission by sending only the subset of rows that match the join keys\n      across the network.\n    </p><p>\n      This feature is primarily used to optimize queries against large partitioned tables\n      (under the name <span class=\"hue-doc-term\">dynamic partition pruning</span>) and joins of large tables.\n      The information in this section includes concepts, internals, and troubleshooting\n      information for the entire runtime filtering feature.\n      For specific tuning steps for partitioned tables,\n      \n      see\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"dynamic_partition_pruning\">Dynamic Partition Pruning</a>.\n      </p><div class=\"hue-doc-note\"><p>\n        When this feature made its debut in Impala 2.5,\n        the default setting was <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MODE=LOCAL</span>.\n        Now the default is <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MODE=GLOBAL</span> in Impala 2.6 and higher,\n        which enables more wide-ranging and ambitious query optimization without requiring you to\n        explicitly set any query options.\n      </p></div><p/></div><div id=\"runtime_filtering_concepts\"><div class=\"hue-doc-title\">Background Information for Runtime Filtering</div><div><p>\n        To understand how runtime filtering works at a detailed level, you must\n        be familiar with some terminology from the field of distributed database technology:\n      </p><ul><li><p> What a <span class=\"hue-doc-term\">plan fragment</span> is. Impala decomposes each query\n            into smaller units of work that are distributed across the cluster.\n            Wherever possible, a data block is read, filtered, and aggregated by\n            plan fragments executing on the same host. For some operations, such\n            as joins and combining intermediate results into a final result set,\n            data is transmitted across the network from one Impala daemon to\n            another. </p></li><li><p>\n            What <span class=\"hue-doc-codeph\">SCAN</span> and <span class=\"hue-doc-codeph\">HASH JOIN</span> plan nodes are, and their role in computing query results:\n          </p><p>\n            In the Impala query plan, a <span class=\"hue-doc-term\">scan node</span> performs the I/O to read from the underlying data files.\n            Although this is an expensive operation from the traditional database perspective, Hadoop clusters and Impala are\n            optimized to do this kind of I/O in a highly parallel fashion. The major potential cost savings come from using\n            the columnar Parquet format (where Impala can avoid reading data for unneeded columns) and partitioned tables\n            (where Impala can avoid reading data for unneeded partitions).\n          </p><p>\n            Most Impala joins use the\n            <a class=\"hue-doc-external-link\" href=\"https://en.wikipedia.org/wiki/Hash_join\" target=\"_blank\"><span class=\"hue-doc-term\">hash join</span></a>\n            mechanism. (It is only fairly recently that Impala\n            started using the nested-loop join technique, for certain kinds of non-equijoin queries.)\n            In a hash join, when evaluating join conditions from two tables, Impala constructs a hash table in memory with all\n            the different column values from the table on one side of the join.\n            Then, for each row from the table on the other side of the join, Impala tests whether the relevant column values\n            are in this hash table or not.\n          </p><p>\n            A <span class=\"hue-doc-term\">hash join node</span> constructs such an in-memory hash table, then performs the comparisons to\n            identify which rows match the relevant join conditions\n            and should be included in the result set (or at least sent on to the subsequent intermediate stage of\n            query processing). Because some of the input for a hash join might be transmitted across the network from another host,\n            it is especially important from a performance perspective to prune out ahead of time any data that is known to be\n            irrelevant.\n          </p><p>\n            The more distinct values are in the columns used as join keys, the larger the in-memory hash table and\n            thus the more memory required to process the query.\n          </p></li><li><p>\n            The difference between a <span class=\"hue-doc-term\">broadcast join</span> and a <span class=\"hue-doc-term\">shuffle join</span>.\n            (The Hadoop notion of a shuffle join is sometimes referred to in Impala as a <span class=\"hue-doc-term\">partitioned join</span>.)\n            In a broadcast join, the table from one side of the join (typically the smaller table)\n            is sent in its entirety to all the hosts involved in the query. Then each host can compare its\n            portion of the data from the other (larger) table against the full set of possible join keys.\n            In a shuffle join, there is no obvious <q>smaller</q> table, and so the contents of both tables\n            are divided up, and corresponding portions of the data are transmitted to each host involved in the query.\n            See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_hints.xml\" data-doc-anchor-id=\"hints\">Optimizer Hints</a> for information about how these different kinds of\n            joins are processed.\n          </p></li><li><p>\n            The notion of the build phase and probe phase when Impala processes a join query.\n            The <span class=\"hue-doc-term\">build phase</span> is where the rows containing the join key columns, typically for the smaller table,\n            are transmitted across the network and built into an in-memory hash table data structure on one or\n            more destination nodes.\n            The <span class=\"hue-doc-term\">probe phase</span> is where data is read locally (typically from the larger table) and the join key columns\n            are compared to the values in the in-memory hash table.\n            The corresponding input sources (tables, subqueries, and so on) for these\n            phases are referred to as the <span class=\"hue-doc-term\">build side</span> and the <span class=\"hue-doc-term\">probe side</span>.\n          </p></li><li><p>\n            How to set Impala query options: interactively within an <span class=\"hue-doc-cmdname\">impala-shell</span> session through\n            the <span class=\"hue-doc-codeph\">SET</span> command, for a JDBC or ODBC application through the <span class=\"hue-doc-codeph\">SET</span> statement, or\n            globally for all <span class=\"hue-doc-cmdname\">impalad</span> daemons through the <span class=\"hue-doc-codeph\">default_query_options</span> configuration\n            setting.\n          </p></li></ul></div></div><div id=\"runtime_filtering_internals\"><div class=\"hue-doc-title\">Runtime Filtering Internals</div><div><p>\n        The <span class=\"hue-doc-term\">filter</span> that is transmitted between plan fragments is essentially a list\n        of values for join key columns. When this list of values is transmitted in time to a scan node,\n        Impala can filter out non-matching values immediately after reading them, rather than transmitting\n        the raw data to another host to compare against the in-memory hash table on that host.\n      </p><p>\n        For HDFS-based tables, this data structure is implemented as a <span class=\"hue-doc-term\">Bloom filter</span>, which uses\n        a probability-based algorithm to determine all possible matching values. (The probability-based aspects\n        means that the filter might include some non-matching values, but if so, that does not cause any inaccuracy\n        in the final results.)\n      </p><p>\n        Another kind of filter is the <q>min-max</q> filter. It currently only applies to Kudu tables. The\n        filter is a data structure representing a minimum and maximum value. These filters are passed to\n        Kudu to reduce the number of rows returned to Impala when scanning the probe side of the join.\n      </p><p>\n        There are different kinds of filters to match the different kinds of joins (partitioned and broadcast).\n        A broadcast filter reflects the complete list of relevant values and can be immediately evaluated by a scan node.\n        A partitioned filter reflects only the values processed by one host in the\n        cluster; all the partitioned filters must be combined into one (by the coordinator node) before the\n        scan nodes can use the results to accurately filter the data as it is read from storage.\n      </p><p>\n        Broadcast filters are also classified as local or global. With a local broadcast filter, the information\n        in the filter is used by a subsequent query fragment that is running on the same host that produced the filter.\n        A non-local broadcast filter must be transmitted across the network to a query fragment that is running on a\n        different host. Impala designates 3 hosts to each produce non-local broadcast filters, to guard against the\n        possibility of a single slow host taking too long. Depending on the setting of the <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MODE</span> query option\n        (<span class=\"hue-doc-codeph\">LOCAL</span> or <span class=\"hue-doc-codeph\">GLOBAL</span>), Impala either uses a conservative optimization\n        strategy where filters are only consumed on the same host that produced them, or a more aggressive strategy\n        where filters are eligible to be transmitted across the network.\n      </p><div class=\"hue-doc-note\">        In Impala 2.6 and higher, the default for runtime filtering is the <span class=\"hue-doc-codeph\">GLOBAL</span> setting.\n      </div></div></div><div id=\"runtime_filtering_file_formats\"><div class=\"hue-doc-title\">File Format Considerations for Runtime Filtering</div><div><p>\n        Parquet tables get the most benefit from\n        the runtime filtering optimizations. Runtime filtering can speed up\n        join queries against partitioned or unpartitioned Parquet tables,\n        and single-table queries against partitioned Parquet tables.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_parquet.xml\" data-doc-anchor-id=\"parquet\">Using the Parquet File Format with Impala Tables</a> for information about\n        using Parquet tables with Impala.\n      </p><p>\n        For other file formats (text, Avro, RCFile, and SequenceFile),\n        runtime filtering speeds up queries against partitioned tables only.\n        Because partitioned tables can use a mixture of formats, Impala produces\n        the filters in all cases, even if they are not ultimately used to\n        optimize the query.\n      </p></div></div><div id=\"runtime_filtering_timing\"><div class=\"hue-doc-title\">Wait Intervals for Runtime Filters</div><div><p>\n        Because it takes time to produce runtime filters, especially for\n        partitioned filters that must be combined by the coordinator node,\n        there is a time interval above which it is more efficient for\n        the scan nodes to go ahead and construct their intermediate result sets,\n        even if that intermediate data is larger than optimal. If it only takes\n        a few seconds to produce the filters, it is worth the extra time if pruning\n        the unnecessary data can save minutes in the overall query time.\n        You can specify the maximum wait time in milliseconds using the\n        <span class=\"hue-doc-codeph\">RUNTIME_FILTER_WAIT_TIME_MS</span> query option.\n      </p><p>\n        By default, each scan node waits for up to 1 second (1000 milliseconds)\n        for filters to arrive. If all filters have not arrived within the\n        specified interval, the scan node proceeds, using whatever filters\n        did arrive to help avoid reading unnecessary data. If a filter arrives\n        after the scan node begins reading data, the scan node applies that\n        filter to the data that is read after the filter arrives, but not to\n        the data that was already read.\n      </p><p>\n        If the cluster is relatively busy and your workload contains many\n        resource-intensive or long-running queries, consider increasing the wait time\n        so that complicated queries do not miss opportunities for optimization.\n        If the cluster is lightly loaded and your workload contains many small queries\n        taking only a few seconds, consider decreasing the wait time to avoid the\n        1 second delay for each query.\n      </p></div></div><div id=\"runtime_filtering_query_options\"><div class=\"hue-doc-title\">Query Options for Runtime Filtering</div><div><p>\n        See the following sections for information about the query options that control runtime filtering:\n      </p><ul><li><p>\n            The first query option adjusts the <q>sensitivity</q> of this feature.\n            <span class=\"hue-doc-ph\">By default, it is set to the highest level (<span class=\"hue-doc-codeph\">GLOBAL</span>).\n            (This default applies to Impala 2.6 and higher.\n            In previous releases, the default was <span class=\"hue-doc-codeph\">LOCAL</span>.)</span></p><ul><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_filter_mode.xml\" data-doc-anchor-id=\"runtime_filter_mode\">RUNTIME_FILTER_MODE Query Option (Impala 2.5 or higher only)</a></p></li></ul></li><li><p>\n            The other query options are tuning knobs that you typically only adjust after doing\n            performance testing, and that you might want to change only for the duration of a single\n            expensive query:\n          </p><ul><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_max_num_runtime_filters.xml\" data-doc-anchor-id=\"max_num_runtime_filters\">MAX_NUM_RUNTIME_FILTERS Query Option (Impala 2.5 or higher only)</a></p></li><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_disable_row_runtime_filtering.xml\" data-doc-anchor-id=\"disable_row_runtime_filtering\">DISABLE_ROW_RUNTIME_FILTERING Query Option (Impala 2.5 or higher only)</a></p></li><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_filter_max_size.xml\" data-doc-anchor-id=\"runtime_filter_max_size\">RUNTIME_FILTER_MAX_SIZE Query Option (Impala 2.6 or higher only)</a></p></li><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_filter_min_size.xml\" data-doc-anchor-id=\"runtime_filter_min_size\">RUNTIME_FILTER_MIN_SIZE Query Option (Impala 2.6 or higher only)</a></p></li><li><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_bloom_filter_size.xml\" data-doc-anchor-id=\"runtime_bloom_filter_size\">RUNTIME_BLOOM_FILTER_SIZE Query Option (Impala 2.5 or higher only)</a>;\n                in Impala 2.6 and higher, this setting acts as a fallback when\n                statistics are not available, rather than as a directive.\n              </p></li></ul></li></ul></div></div><div id=\"runtime_filtering_explain_plan\"><div class=\"hue-doc-title\">Runtime Filtering and Query Plans</div><div><p>\n        In the same way the query plan displayed by the\n        <span class=\"hue-doc-codeph\">EXPLAIN</span> statement includes information\n        about predicates used by each plan fragment, it also\n        includes annotations showing whether a plan fragment\n        produces or consumes a runtime filter.\n        A plan fragment that produces a filter includes an\n        annotation such as\n        <span class=\"hue-doc-codeph\">runtime filters: <span class=\"hue-doc-varname\">filter_id</span> &lt;- <span class=\"hue-doc-varname\">table</span>.<span class=\"hue-doc-varname\">column</span></span>,\n        while a plan fragment that consumes a filter includes an annotation such as\n        <span class=\"hue-doc-codeph\">runtime filters: <span class=\"hue-doc-varname\">filter_id</span> -&gt; <span class=\"hue-doc-varname\">table</span>.<span class=\"hue-doc-varname\">column</span></span>.\n        <span class=\"hue-doc-ph\">Setting the query option <span class=\"hue-doc-codeph\">EXPLAIN_LEVEL=2</span> adds additional\n        annotations showing the type of the filter, either <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">filter_id</span>[bloom]</span>\n        (for HDFS-based tables) or <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">filter_id</span>[min_max]</span> (for Kudu tables).</span></p><p>\n        The following example shows a query that uses a single runtime filter,\n        labeled <span class=\"hue-doc-codeph\">RF000</span>, to prune the partitions based on\n        evaluating the result set of a subquery at runtime:\n      </p><div class=\"hue-doc-codeblock\" id=\"simple_dpp_example\">CREATE TABLE yy (s STRING) PARTITIONED BY (year INT);\nINSERT INTO yy PARTITION (year) VALUES ('1999', 1999), ('2000', 2000),\n  ('2001', 2001), ('2010', 2010), ('2018', 2018);\nCOMPUTE STATS yy;\n\nCREATE TABLE yy2 (s STRING, year INT);\nINSERT INTO yy2 VALUES ('1999', 1999), ('2000', 2000), ('2001', 2001);\nCOMPUTE STATS yy2;\n\n-- The following query reads an unknown number of partitions, whose key values\n-- are only known at run time. The <b>runtime filters</b> line shows the\n-- information used in query fragment 02 to decide which partitions to skip.\n\nEXPLAIN SELECT s FROM yy WHERE year IN (SELECT year FROM yy2);\n+--------------------------------------------------------------------------+\n| PLAN-ROOT SINK                                                           |\n| |                                                                        |\n| 04:EXCHANGE [UNPARTITIONED]                                              |\n| |                                                                        |\n| 02:HASH JOIN [LEFT SEMI JOIN, BROADCAST]                                 |\n| |  hash predicates: year = year                                          |\n| |  <b>runtime filters: RF000 &lt;- year</b>                                   |\n| |                                                                        |\n| |--03:EXCHANGE [BROADCAST]                                               |\n| |  |                                                                     |\n| |  01:SCAN HDFS [default.yy2]                                            |\n| |     partitions=1/1 files=1 size=620B                                   |\n| |                                                                        |\n| 00:SCAN HDFS [default.yy]                                                |\n|    <b>partitions=5/5</b> files=5 size=1.71KB                               |\n|    runtime filters: RF000 -&gt; year                                        |\n+--------------------------------------------------------------------------+\n\nSELECT s FROM yy WHERE year IN (SELECT year FROM yy2); -- Returns 3 rows from yy\nPROFILE;\n</div><p>\n        The query profile (displayed by the <span class=\"hue-doc-codeph\">PROFILE</span> command\n        in <span class=\"hue-doc-cmdname\">impala-shell</span>) contains both the\n          <span class=\"hue-doc-codeph\">EXPLAIN</span> plan and more detailed information about the\n        internal workings of the query. The profile output includes the\n          <span class=\"hue-doc-codeph\">Filter routing table</span> section with information about\n        each filter based on its ID.\n      </p></div></div><div id=\"runtime_filtering_queries\"><div class=\"hue-doc-title\">Examples of Queries that Benefit from Runtime Filtering</div><div><p>\n        In this example, Impala would normally do extra work to interpret the columns\n        <span class=\"hue-doc-codeph\">C1</span>, <span class=\"hue-doc-codeph\">C2</span>, <span class=\"hue-doc-codeph\">C3</span>, and <span class=\"hue-doc-codeph\">ID</span>\n        for each row in <span class=\"hue-doc-codeph\">HUGE_T1</span>, before checking the <span class=\"hue-doc-codeph\">ID</span>\n        value against the in-memory hash table constructed from all the <span class=\"hue-doc-codeph\">TINY_T2.ID</span>\n        values. By producing a filter containing all the <span class=\"hue-doc-codeph\">TINY_T2.ID</span> values\n        even before the query starts scanning the <span class=\"hue-doc-codeph\">HUGE_T1</span> table, Impala\n        can skip the unnecessary work to parse the column info as soon as it determines\n        that an <span class=\"hue-doc-codeph\">ID</span> value does not match any of the values from the other table.\n      </p><p>\n        The example shows <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statements for both the tables (even\n        though that is a one-time operation after loading data into those tables) because\n        Impala relies on up-to-date statistics to\n        determine which one has more distinct <span class=\"hue-doc-codeph\">ID</span> values than the other.\n        That information lets Impala make effective decisions about which table to use to\n        construct the in-memory hash table, and which table to read from disk and\n        compare against the entries in the hash table.\n      </p><div class=\"hue-doc-codeblock\">COMPUTE STATS huge_t1;\nCOMPUTE STATS tiny_t2;\nSELECT c1, c2, c3 FROM huge_t1 JOIN tiny_t2 WHERE huge_t1.id = tiny_t2.id;\n</div><p>\n        In this example, <span class=\"hue-doc-codeph\">T1</span> is a table partitioned by year. The subquery\n        on <span class=\"hue-doc-codeph\">T2</span> produces multiple values, and transmits those values as a filter to the plan\n        fragments that are reading from <span class=\"hue-doc-codeph\">T1</span>. Any non-matching partitions in <span class=\"hue-doc-codeph\">T1</span>\n        are skipped.\n      </p><div class=\"hue-doc-codeblock\">select c1 from t1 where year in (select distinct year from t2);\n</div><p>\n        Now the <span class=\"hue-doc-codeph\">WHERE</span> clause contains an additional test that does not apply to\n        the partition key column.\n        A filter on a column that is not a partition key is called a per-row filter.\n        Because per-row filters only apply for Parquet, <span class=\"hue-doc-codeph\">T1</span> must be a Parquet table.\n      </p><p>\n        The subqueries result in two filters being transmitted to\n        the scan nodes that read from <span class=\"hue-doc-codeph\">T1</span>. The filter on <span class=\"hue-doc-codeph\">YEAR</span> helps the query eliminate\n        entire partitions based on non-matching years. The filter on <span class=\"hue-doc-codeph\">C2</span> lets Impala discard\n        rows with non-matching <span class=\"hue-doc-codeph\">C2</span> values immediately after reading them. Without runtime filtering,\n        Impala would have to keep the non-matching values in memory, assemble <span class=\"hue-doc-codeph\">C1</span>, <span class=\"hue-doc-codeph\">C2</span>,\n        and <span class=\"hue-doc-codeph\">C3</span> into rows in the intermediate result set, and transmit all the intermediate rows\n        back to the coordinator node, where they would be eliminated only at the very end of the query.\n      </p><div class=\"hue-doc-codeblock\">select c1, c2, c3 from t1\n  where year in (select distinct year from t2)\n    and c2 in (select other_column from t3);\n</div><p>\n        This example involves a broadcast join.\n        The fact that the <span class=\"hue-doc-codeph\">ON</span> clause would\n        return a small number of matching rows (because there\n        are not very many rows in <span class=\"hue-doc-codeph\">TINY_T2</span>)\n        means that the corresponding filter is very selective.\n        Therefore, runtime filtering will probably be effective\n        in optimizing this query.\n      </p><div class=\"hue-doc-codeblock\">select c1 from huge_t1 join [broadcast] tiny_t2\n  on huge_t1.id = tiny_t2.id\n  where huge_t1.year in (select distinct year from tiny_t2)\n    and c2 in (select other_column from t3);\n</div><p>\n        This example involves a shuffle or partitioned join.\n        Assume that most rows in <span class=\"hue-doc-codeph\">HUGE_T1</span>\n        have a corresponding row in <span class=\"hue-doc-codeph\">HUGE_T2</span>.\n        The fact that the <span class=\"hue-doc-codeph\">ON</span> clause could\n        return a large number of matching rows means that\n        the corresponding filter would not be very selective.\n        Therefore, runtime filtering might be less effective\n        in optimizing this query.\n      </p><div class=\"hue-doc-codeblock\">select c1 from huge_t1 join [shuffle] huge_t2\n  on huge_t1.id = huge_t2.id\n  where huge_t1.year in (select distinct year from huge_t2)\n    and c2 in (select other_column from t3);\n</div></div></div><div id=\"runtime_filtering_tuning\"><div class=\"hue-doc-title\">Tuning and Troubleshooting Queries that Use Runtime Filtering</div><div><p>\n        These tuning and troubleshooting procedures apply to queries that are\n        resource-intensive enough, long-running enough, and frequent enough\n        that you can devote special attention to optimizing them individually.\n      </p><p>\n        Use the <span class=\"hue-doc-codeph\">EXPLAIN</span> statement and examine the <span class=\"hue-doc-codeph\">runtime filters:</span>\n        lines to determine whether runtime filters are being applied to the <span class=\"hue-doc-codeph\">WHERE</span> predicates\n        and join clauses that you expect. For example, runtime filtering does not apply to queries that use\n        the nested loop join mechanism due to non-equijoin operators.\n      </p><p>\n        Make sure statistics are up-to-date for all tables involved in the queries.\n        Use the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement after loading data into non-partitioned tables,\n        and <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span> after adding new partitions to partitioned tables.\n      </p><p>\n        If join queries involving large tables use unique columns as the join keys,\n        for example joining a primary key column with a foreign key column, the overhead of\n        producing and transmitting the filter might outweigh the performance benefit because\n        not much data could be pruned during the early stages of the query.\n        For such queries, consider setting the query option <span class=\"hue-doc-codeph\">RUNTIME_FILTER_MODE=OFF</span>.\n      </p></div></div><div id=\"runtime_filtering_limits\"><div class=\"hue-doc-title\">Limitations and Restrictions for Runtime Filtering</div><div><p>\n        The runtime filtering feature is most effective for the Parquet file formats.\n        For other file formats, filtering only applies for partitioned tables.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_filtering.xml\" data-doc-anchor-id=\"runtime_filtering_file_formats\">File Format Considerations for Runtime Filtering</a>.\n        For the ways in which runtime filtering works for Kudu tables, see\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_kudu.xml\" data-doc-anchor-id=\"kudu_performance\">Impala Query Performance for Kudu Tables</a>.\n      </p><p>\n        When the spill-to-disk mechanism is activated on a particular host during a query,\n        that host does not produce any filters while processing that query.\n        This limitation does not affect the correctness of results; it only reduces the\n        amount of optimization that can be applied to the query.\n      </p></div></div></div></div>","title":"Runtime Filtering for Impala Queries (Impala 2.5 or higher only)"}