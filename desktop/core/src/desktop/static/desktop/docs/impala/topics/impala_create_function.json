{"body":"<div><div id=\"create_function\"><div class=\"hue-doc-title\">CREATE FUNCTION Statement</div><div><p>\n      Creates a user-defined function (UDF), which you can use to implement custom logic during\n      <span class=\"hue-doc-codeph\">SELECT</span> or <span class=\"hue-doc-codeph\">INSERT</span> operations.\n    </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><p>\n      The syntax is different depending on whether you create a scalar UDF, which is called once for each row and\n      implemented by a single function, or a user-defined aggregate function (UDA), which is implemented by\n      multiple functions that compute intermediate results across sets of rows.\n    </p><p>\n      In Impala 2.5 and higher, the syntax is also different for creating or dropping scalar Java-based UDFs.\n      The statements for Java UDFs use a new syntax, without any argument types or return type specified. Java-based UDFs\n      created using the new syntax persist across restarts of the Impala catalog server, and can be shared transparently\n      between Impala and Hive.\n    </p><p>\n      To create a persistent scalar C++ UDF with <span class=\"hue-doc-codeph\">CREATE FUNCTION</span>:\n    </p><div class=\"hue-doc-codeblock\">CREATE FUNCTION [IF NOT EXISTS] [<span class=\"hue-doc-varname\">db_name</span>.]<span class=\"hue-doc-varname\">function_name</span>([<span class=\"hue-doc-varname\">arg_type</span>[, <span class=\"hue-doc-varname\">arg_type</span>...])\n  RETURNS <span class=\"hue-doc-varname\">return_type</span>\n  LOCATION '<span class=\"hue-doc-varname\">hdfs_path_to_dot_so</span>'\n  SYMBOL='<span class=\"hue-doc-varname\">symbol_name</span>'</div><p>\n      To create a persistent Java UDF with <span class=\"hue-doc-codeph\">CREATE FUNCTION</span>:\n<div class=\"hue-doc-codeblock\">CREATE FUNCTION [IF NOT EXISTS] [<span class=\"hue-doc-varname\">db_name</span>.]<span class=\"hue-doc-varname\">function_name</span>\n  LOCATION '<span class=\"hue-doc-varname\">hdfs_path_to_jar</span>'\n  SYMBOL='<span class=\"hue-doc-varname\">class_name</span>'</div></p><p>\n      To create a persistent UDA, which must be written in C++, issue a <span class=\"hue-doc-codeph\">CREATE AGGREGATE FUNCTION</span> statement:\n    </p><div class=\"hue-doc-codeblock\">CREATE [AGGREGATE] FUNCTION [IF NOT EXISTS] [<span class=\"hue-doc-varname\">db_name</span>.]<span class=\"hue-doc-varname\">function_name</span>([<span class=\"hue-doc-varname\">arg_type</span>[, <span class=\"hue-doc-varname\">arg_type</span>...])\n  RETURNS <span class=\"hue-doc-varname\">return_type</span>\n  LOCATION '<span class=\"hue-doc-varname\">hdfs_path</span>'\n  [INIT_FN='<span class=\"hue-doc-varname\">function</span>]\n  UPDATE_FN='<span class=\"hue-doc-varname\">function</span>\n  MERGE_FN='<span class=\"hue-doc-varname\">function</span>\n  [PREPARE_FN='<span class=\"hue-doc-varname\">function</span>]\n  [CLOSEFN='<span class=\"hue-doc-varname\">function</span>]\n  <span class=\"hue-doc-ph\">[SERIALIZE_FN='<span class=\"hue-doc-varname\">function</span>]</span>\n  [FINALIZE_FN='<span class=\"hue-doc-varname\">function</span>]\n  <span class=\"hue-doc-ph\">[INTERMEDIATE <span class=\"hue-doc-varname\">type_spec</span>]</span></div><p id=\"ddl_blurb\"><b>Statement type:</b> DDL\n      </p><p><b>Varargs notation:</b></p><div class=\"hue-doc-note\"><p>\n        Variable-length argument lists are supported for C++ UDFs, but currently not for Java UDFs.\n      </p></div><p>\n      If the underlying implementation of your function accepts a variable number of arguments:\n    </p><ul><li>\n        The variable arguments must go last in the argument list.\n      </li><li>\n        The variable arguments must all be of the same type.\n      </li><li>\n        You must include at least one instance of the variable arguments in every function call invoked from SQL.\n      </li><li>\n        You designate the variable portion of the argument list in the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement\n        by including <span class=\"hue-doc-codeph\">...</span> immediately after the type name of the first variable argument. For\n        example, to create a function that accepts an <span class=\"hue-doc-codeph\">INT</span> argument, followed by a\n        <span class=\"hue-doc-codeph\">BOOLEAN</span>, followed by one or more <span class=\"hue-doc-codeph\">STRING</span> arguments, your <span class=\"hue-doc-codeph\">CREATE\n        FUNCTION</span> statement would look like:\n<div class=\"hue-doc-codeblock\">CREATE FUNCTION <span class=\"hue-doc-varname\">func_name</span> (INT, BOOLEAN, STRING ...)\n  RETURNS <span class=\"hue-doc-varname\">type</span> LOCATION '<span class=\"hue-doc-varname\">path</span>' SYMBOL='<span class=\"hue-doc-varname\">entry_point</span>';\n</div></li></ul><p>\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udf_varargs\">Variable-Length Argument Lists</a> for how to code a C++ UDF to accept\n      variable-length argument lists.\n    </p><p><b>Scalar and aggregate functions:</b></p><p>\n      The simplest kind of user-defined function returns a single scalar value each time it is called, typically\n      once for each row in the result set. This general kind of function is what is usually meant by UDF.\n      User-defined aggregate functions (UDAs) are a specialized kind of UDF that produce a single value based on\n      the contents of multiple rows. You usually use UDAs in combination with a <span class=\"hue-doc-codeph\">GROUP BY</span> clause to\n      condense a large result set into a smaller one, or even a single row summarizing column values across an\n      entire table.\n    </p><p>\n      You create UDAs by using the <span class=\"hue-doc-codeph\">CREATE AGGREGATE FUNCTION</span> syntax. The clauses\n      <span class=\"hue-doc-codeph\">INIT_FN</span>, <span class=\"hue-doc-codeph\">UPDATE_FN</span>, <span class=\"hue-doc-codeph\">MERGE_FN</span>,\n      <span class=\"hue-doc-ph\"><span class=\"hue-doc-codeph\">SERIALIZE_FN</span>,</span><span class=\"hue-doc-codeph\">FINALIZE_FN</span>, and\n      <span class=\"hue-doc-codeph\">INTERMEDIATE</span> only apply when you create a UDA rather than a scalar UDF.\n    </p><p>\n      The <span class=\"hue-doc-codeph\">*_FN</span> clauses specify functions to call at different phases of function processing.\n    </p><ul><li><b>Initialize:</b> The function you specify with the <span class=\"hue-doc-codeph\">INIT_FN</span> clause does any initial\n        setup, such as initializing member variables in internal data structures. This function is often a stub for\n        simple UDAs. You can omit this clause and a default (no-op) function will be used.\n      </li><li><b>Update:</b> The function you specify with the <span class=\"hue-doc-codeph\">UPDATE_FN</span> clause is called once for each\n        row in the original result set, that is, before any <span class=\"hue-doc-codeph\">GROUP BY</span> clause is applied. A separate\n        instance of the function is called for each different value returned by the <span class=\"hue-doc-codeph\">GROUP BY</span>\n        clause. The final argument passed to this function is a pointer, to which you write an updated value based\n        on its original value and the value of the first argument.\n      </li><li><b>Merge:</b> The function you specify with the <span class=\"hue-doc-codeph\">MERGE_FN</span> clause is called an arbitrary\n        number of times, to combine intermediate values produced by different nodes or different threads as Impala\n        reads and processes data files in parallel. The final argument passed to this function is a pointer, to\n        which you write an updated value based on its original value and the value of the first argument.\n      </li><li><b>Serialize:</b> The function you specify with the <span class=\"hue-doc-codeph\">SERIALIZE_FN</span> clause frees memory\n        allocated to intermediate results. It is required if any memory was allocated by the Allocate function in\n        the Init, Update, or Merge functions, or if the intermediate type contains any pointers. See\n        \n    uda-sample.cc\n   for details.\n      </li><li><b>Finalize:</b> The function you specify with the <span class=\"hue-doc-codeph\">FINALIZE_FN</span> clause does any required\n        teardown for resources acquired by your UDF, such as freeing memory, closing file handles if you explicitly\n        opened any files, and so on. This function is often a stub for simple UDAs. You can omit this clause and a\n        default (no-op) function will be used. It is required in UDAs where the final return type is different than\n        the intermediate type. or if any memory was allocated by the Allocate function in the Init, Update, or\n        Merge functions. See \n    uda-sample.cc\n   for details.\n      </li></ul><p>\n      If you use a consistent naming convention for each of the underlying functions, Impala can automatically\n      determine the names based on the first such clause, so the others are optional.\n    </p><p>\n      For end-to-end examples of UDAs, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">Impala User-Defined Functions (UDFs)</a>.\n    </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"udfs_no_complex_types\">\n        Currently, Impala UDFs cannot accept arguments or return values of the Impala complex types\n        (<span class=\"hue-doc-codeph\">STRUCT</span>, <span class=\"hue-doc-codeph\">ARRAY</span>, or <span class=\"hue-doc-codeph\">MAP</span>).\n      </p><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><ul><li>\n        You can write Impala UDFs in either C++ or Java. C++ UDFs are new to Impala, and are the recommended format\n        for high performance utilizing native code. Java-based UDFs are compatible between Impala and Hive, and are\n        most suited to reusing existing Hive UDFs. (Impala can run Java-based Hive UDFs but not Hive UDAs.)\n      </li><li>Impala 2.5 introduces UDF improvements to persistence for both C++ and Java UDFs,\n        and better compatibility between Impala and Hive for Java UDFs.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">Impala User-Defined Functions (UDFs)</a> for details.\n      </li><li>\n        The body of the UDF is represented by a <span class=\"hue-doc-codeph\">.so</span> or <span class=\"hue-doc-codeph\">.jar</span> file, which you store\n        in HDFS and the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement distributes to each Impala node.\n      </li><li>\n        Impala calls the underlying code during SQL statement evaluation, as many times as needed to process all\n        the rows from the result set. All UDFs are assumed to be deterministic, that is, to always return the same\n        result when passed the same argument values. Impala might or might not skip some invocations of a UDF if\n        the result value is already known from a previous call. Therefore, do not rely on the UDF being called a\n        specific number of times, and do not return different result values based on some external factor such as\n        the current time, a random number function, or an external data source that could be updated while an\n        Impala query is in progress.\n      </li><li>\n        The names of the function arguments in the UDF are not significant, only their number, positions, and data\n        types.\n      </li><li>\n        You can overload the same function name by creating multiple versions of the function, each with a\n        different argument signature. For security reasons, you cannot make a UDF with the same name as any\n        built-in function.\n      </li><li>\n        In the UDF code, you represent the function return result as a <span class=\"hue-doc-codeph\">struct</span>. This\n        <span class=\"hue-doc-codeph\">struct</span> contains 2 fields. The first field is a <span class=\"hue-doc-codeph\">boolean</span> representing\n        whether the value is <span class=\"hue-doc-codeph\">NULL</span> or not. (When this field is <span class=\"hue-doc-codeph\">true</span>, the return\n        value is interpreted as <span class=\"hue-doc-codeph\">NULL</span>.) The second field is the same type as the specified function\n        return type, and holds the return value when the function returns something other than\n        <span class=\"hue-doc-codeph\">NULL</span>.\n      </li><li>\n        In the UDF code, you represent the function arguments as an initial pointer to a UDF context structure,\n        followed by references to zero or more <span class=\"hue-doc-codeph\">struct</span>s, corresponding to each of the arguments.\n        Each <span class=\"hue-doc-codeph\">struct</span> has the same 2 fields as with the return value, a <span class=\"hue-doc-codeph\">boolean</span>\n        field representing whether the argument is <span class=\"hue-doc-codeph\">NULL</span>, and a field of the appropriate type\n        holding any non-<span class=\"hue-doc-codeph\">NULL</span> argument value.\n      </li><li>\n        For sample code and build instructions for UDFs,\n        see \n    the udf_samples github repo\n  .\n      </li><li>\n        Because the file representing the body of the UDF is stored in HDFS, it is automatically available to all\n        the Impala nodes. You do not need to manually copy any UDF-related files between servers.\n      </li><li>\n        Because Impala currently does not have any <span class=\"hue-doc-codeph\">ALTER FUNCTION</span> statement, if you need to rename\n        a function, move it to a different database, or change its signature or other properties, issue a\n        <span class=\"hue-doc-codeph\">DROP FUNCTION</span> statement for the original function followed by a <span class=\"hue-doc-codeph\">CREATE\n        FUNCTION</span> with the desired properties.\n      </li><li>\n        Because each UDF is associated with a particular database, either issue a <span class=\"hue-doc-codeph\">USE</span> statement\n        before doing any <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statements, or specify the name of the function as\n        <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">db_name</span>.<span class=\"hue-doc-varname\">function_name</span></span>.\n      </li></ul><p id=\"sync_ddl_blurb\">\n        If you connect to different Impala nodes within an <span class=\"hue-doc-cmdname\">impala-shell</span> session for\n        load-balancing purposes, you can enable the <span class=\"hue-doc-codeph\">SYNC_DDL</span> query option to make each DDL\n        statement wait before returning, until the new or changed metadata has been received by all the Impala\n        nodes. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_sync_ddl.xml\" data-doc-anchor-id=\"sync_ddl\">SYNC_DDL Query Option</a> for details.\n      </p><p id=\"compatibility_blurb\"><b>Compatibility:</b></p><p>\n      Impala can run UDFs that were created through Hive, as long as they refer to Impala-compatible data types\n      (not composite or nested column types). Hive can run Java-based UDFs that were created through Impala, but\n      not Impala UDFs written in C++.\n    </p><p id=\"current_user_caveat\">\n        The Hive <span class=\"hue-doc-codeph\">current_user()</span> function cannot be\n        called from a Java UDF through Impala.\n      </p><p><b>Persistence:</b></p><p id=\"udf_persistence_restriction\">\n        In Impala 2.5 and higher, Impala UDFs and UDAs written in C++ are persisted in the metastore database.\n        Java UDFs are also persisted, if they were created with the new <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax for Java UDFs,\n        where the Java function argument and return types are omitted.\n        Java-based UDFs created with the old <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax do not persist across restarts\n        because they are held in the memory of the <span class=\"hue-doc-cmdname\">catalogd</span> daemon.\n        Until you re-create such Java UDFs using the new <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax,\n        you must reload those Java-based UDFs by running the original <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statements again each time\n        you restart the <span class=\"hue-doc-cmdname\">catalogd</span> daemon.\n        Prior to Impala 2.5 the requirement to reload functions after a restart applied to both C++ and Java functions.\n      </p><p id=\"cancel_blurb_no\"><b>Cancellation:</b> Cannot be cancelled.\n      </p><p id=\"permissions_blurb_no\"><b>HDFS permissions:</b> This statement does not touch any HDFS files or directories,\n        therefore no HDFS permissions are required.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n      For additional examples of all kinds of user-defined functions, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">Impala User-Defined Functions (UDFs)</a>.\n    </p><p>\n      The following example shows how to take a Java jar file and make all the functions inside one of its classes\n      into UDFs under a single (overloaded) function name in Impala. Each <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> or\n      <span class=\"hue-doc-codeph\">DROP FUNCTION</span> statement applies to all the overloaded Java functions with the same name.\n      This example uses the signatureless syntax for <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> and <span class=\"hue-doc-codeph\">DROP FUNCTION</span>,\n      which is available in Impala 2.5 and higher.\n    </p><p>\n      At the start, the jar file is in the local filesystem. Then it is copied into HDFS, so that it is\n      available for Impala to reference through the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement and\n      queries that refer to the Impala function name.\n    </p><div class=\"hue-doc-codeblock\">$ jar -tvf udf-examples.jar\n     0 Mon Feb 22 04:06:50 PST 2016 META-INF/\n   122 Mon Feb 22 04:06:48 PST 2016 META-INF/MANIFEST.MF\n     0 Mon Feb 22 04:06:46 PST 2016 org/\n     0 Mon Feb 22 04:06:46 PST 2016 org/apache/\n     0 Mon Feb 22 04:06:46 PST 2016 org/apache/impala/\n  2460 Mon Feb 22 04:06:46 PST 2016 org/apache/impala/IncompatibleUdfTest.class\n   541 Mon Feb 22 04:06:46 PST 2016 org/apache/impala/TestUdfException.class\n  3438 Mon Feb 22 04:06:46 PST 2016 org/apache/impala/JavaUdfTest.class\n  5872 Mon Feb 22 04:06:46 PST 2016 org/apache/impala/TestUdf.class\n...\n$ hdfs dfs -put udf-examples.jar /user/impala/udfs\n$ hdfs dfs -ls /user/impala/udfs\nFound 2 items\n-rw-r--r--   3 jrussell supergroup        853 2015-10-09 14:05 /user/impala/udfs/hello_world.jar\n-rw-r--r--   3 jrussell supergroup       7366 2016-06-08 14:25 /user/impala/udfs/udf-examples.jar\n</div><p>\n      In <span class=\"hue-doc-cmdname\">impala-shell</span>, the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> refers to the HDFS path of the jar file\n      and the fully qualified class name inside the jar. Each of the functions inside the class becomes an\n      Impala function, each one overloaded under the specified Impala function name.\n    </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create function testudf location '/user/impala/udfs/udf-examples.jar' symbol='org.apache.impala.TestUdf';\n[localhost:21000] &gt; show functions;\n+-------------+---------------------------------------+-------------+---------------+\n| return type | signature                             | binary type | is persistent |\n+-------------+---------------------------------------+-------------+---------------+\n| BIGINT      | testudf(BIGINT)                       | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN)                      | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN, BOOLEAN)             | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN, BOOLEAN, BOOLEAN)    | JAVA        | true          |\n| DOUBLE      | testudf(DOUBLE)                       | JAVA        | true          |\n| DOUBLE      | testudf(DOUBLE, DOUBLE)               | JAVA        | true          |\n| DOUBLE      | testudf(DOUBLE, DOUBLE, DOUBLE)       | JAVA        | true          |\n| FLOAT       | testudf(FLOAT)                        | JAVA        | true          |\n| FLOAT       | testudf(FLOAT, FLOAT)                 | JAVA        | true          |\n| FLOAT       | testudf(FLOAT, FLOAT, FLOAT)          | JAVA        | true          |\n| INT         | testudf(INT)                          | JAVA        | true          |\n| DOUBLE      | testudf(INT, DOUBLE)                  | JAVA        | true          |\n| INT         | testudf(INT, INT)                     | JAVA        | true          |\n| INT         | testudf(INT, INT, INT)                | JAVA        | true          |\n| SMALLINT    | testudf(SMALLINT)                     | JAVA        | true          |\n| SMALLINT    | testudf(SMALLINT, SMALLINT)           | JAVA        | true          |\n| SMALLINT    | testudf(SMALLINT, SMALLINT, SMALLINT) | JAVA        | true          |\n| STRING      | testudf(STRING)                       | JAVA        | true          |\n| STRING      | testudf(STRING, STRING)               | JAVA        | true          |\n| STRING      | testudf(STRING, STRING, STRING)       | JAVA        | true          |\n| TINYINT     | testudf(TINYINT)                      | JAVA        | true          |\n+-------------+---------------------------------------+-------------+---------------+\n</div><p>\n      These are all simple functions that return their single arguments, or\n      sum, concatenate, and so on their multiple arguments. Impala determines which\n      overloaded function to use based on the number and types of the arguments.\n    </p><div class=\"hue-doc-codeblock\">insert into bigint_x values (1), (2), (4), (3);\nselect testudf(x) from bigint_x;\n+-----------------+\n| udfs.testudf(x) |\n+-----------------+\n| 1               |\n| 2               |\n| 4               |\n| 3               |\n+-----------------+\n\ninsert into int_x values (1), (2), (4), (3);\nselect testudf(x, x+1, x*x) from int_x;\n+-------------------------------+\n| udfs.testudf(x, x + 1, x * x) |\n+-------------------------------+\n| 4                             |\n| 9                             |\n| 25                            |\n| 16                            |\n+-------------------------------+\n\nselect testudf(x) from string_x;\n+-----------------+\n| udfs.testudf(x) |\n+-----------------+\n| one             |\n| two             |\n| four            |\n| three           |\n+-----------------+\nselect testudf(x,x) from string_x;\n+--------------------+\n| udfs.testudf(x, x) |\n+--------------------+\n| oneone             |\n| twotwo             |\n| fourfour           |\n| threethree         |\n+--------------------+\n</div><p>\n      The previous example used the same Impala function name as the name of the class.\n      This example shows how the Impala function name is independent of the underlying\n      Java class or function names. A second <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement\n      results in a set of overloaded functions all named <span class=\"hue-doc-codeph\">my_func</span>,\n      to go along with the overloaded functions all named <span class=\"hue-doc-codeph\">testudf</span>.\n    </p><div class=\"hue-doc-codeblock\">create function my_func location '/user/impala/udfs/udf-examples.jar'\n  symbol='org.apache.impala.TestUdf';\n\nshow functions;\n+-------------+---------------------------------------+-------------+---------------+\n| return type | signature                             | binary type | is persistent |\n+-------------+---------------------------------------+-------------+---------------+\n| BIGINT      | my_func(BIGINT)                       | JAVA        | true          |\n| BOOLEAN     | my_func(BOOLEAN)                      | JAVA        | true          |\n| BOOLEAN     | my_func(BOOLEAN, BOOLEAN)             | JAVA        | true          |\n...\n| BIGINT      | testudf(BIGINT)                       | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN)                      | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN, BOOLEAN)             | JAVA        | true          |\n...\n</div><p>\n      The corresponding <span class=\"hue-doc-codeph\">DROP FUNCTION</span> statement with no signature\n      drops all the overloaded functions with that name.\n    </p><div class=\"hue-doc-codeblock\">drop function my_func;\nshow functions;\n+-------------+---------------------------------------+-------------+---------------+\n| return type | signature                             | binary type | is persistent |\n+-------------+---------------------------------------+-------------+---------------+\n| BIGINT      | testudf(BIGINT)                       | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN)                      | JAVA        | true          |\n| BOOLEAN     | testudf(BOOLEAN, BOOLEAN)             | JAVA        | true          |\n...\n</div><p>\n      The signatureless <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax for Java UDFs ensures that\n      the functions shown in this example remain available after the Impala service\n      (specifically, the Catalog Server) are restarted.\n    </p><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udfs\">Impala User-Defined Functions (UDFs)</a> for more background information, usage instructions, and examples for\n      Impala UDFs; <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_drop_function.xml\" data-doc-anchor-id=\"drop_function\">DROP FUNCTION Statement</a></p></div></div></div>","title":"CREATE FUNCTION Statement"}