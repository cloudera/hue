{"body":"<div><div id=\"impala_hbase\"><div class=\"hue-doc-title\" id=\"hbase\">Using Impala to Query HBase Tables</div><div><p>\n      You can use Impala to query HBase tables. This is useful for accessing any of\n      your existing HBase tables via SQL and performing analytics over them. HDFS\n      and Kudu tables are preferred over HBase for analytic workloads and offer\n      superior performance. Kudu supports efficient inserts, updates and deletes\n      of small numbers of rows and can replace HBase for most analytics-oriented use\n      cases.  See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_kudu.xml\" data-doc-anchor-id=\"impala_kudu\">Using Impala to Query Kudu Tables</a> for information on using\n      Impala with Kudu.\n    </p><p>\n      From the perspective of an Impala user, coming from an RDBMS background, HBase is a kind of key-value store\n      where the value consists of multiple fields. The key is mapped to one column in the Impala table, and the\n      various fields of the value are mapped to the other columns in the Impala table.\n    </p><p>\n      For background information on HBase, see <a class=\"hue-doc-external-link\" href=\"https://hbase.apache.org/book.html\" target=\"_blank\">https://hbase.apache.org/book.html</a>.\n    </p><p/></div><div id=\"hbase_using\"><div class=\"hue-doc-title\">Overview of Using HBase with Impala</div><div><p>\n        When you use Impala with HBase:\n      </p><ul><li>\n          You create the tables on the Impala side using the Hive shell, because the Impala <span class=\"hue-doc-codeph\">CREATE\n          TABLE</span> statement currently does not support custom SerDes and some other syntax needed for these\n          tables:\n          <ul><li>\n              You designate it as an HBase table using the <span class=\"hue-doc-codeph\">STORED BY\n              'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span> clause on the Hive <span class=\"hue-doc-codeph\">CREATE\n              TABLE</span> statement.\n            </li><li>\n              You map these specially created tables to corresponding tables that exist in HBase, with the clause\n              <span class=\"hue-doc-codeph\">TBLPROPERTIES(\"hbase.table.name\" = \"<span class=\"hue-doc-varname\">table_name_in_hbase</span>\")</span> on the\n              Hive <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement.\n            </li><li>\n              See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_hbase.xml\" data-doc-anchor-id=\"hbase_queries\">Examples of Querying HBase Tables from Impala</a> for a full example.\n            </li></ul></li><li>\n          You define the column corresponding to the HBase row key as a string with the <span class=\"hue-doc-codeph\">#string</span>\n          keyword, or map it to a <span class=\"hue-doc-codeph\">STRING</span> column.\n        </li><li>\n          Because Impala and Hive share the same metastore database, once you create the table in Hive, you can\n          query or insert into it through Impala. (After creating a new table through Hive, issue the\n          <span class=\"hue-doc-codeph\">INVALIDATE METADATA</span> statement in <span class=\"hue-doc-cmdname\">impala-shell</span> to make Impala aware of\n          the new table.)\n        </li><li> You issue queries against the Impala tables. For efficient queries,\n          use the <span class=\"hue-doc-codeph\">WHERE</span> clause to find a single key value or a\n          range of key values wherever practical, by testing the Impala column\n          corresponding to the HBase row key. Avoid queries that do full-table\n          scans, which are efficient for regular Impala tables but inefficient\n          in HBase. </li></ul><p>\n        To work with an HBase table from Impala, ensure that the <span class=\"hue-doc-codeph\">impala</span> user has read/write\n        privileges for the HBase table, using the <span class=\"hue-doc-codeph\">GRANT</span> command in the HBase shell. For details\n        about HBase security, see <a class=\"hue-doc-external-link\" href=\"https://hbase.apache.org/book.html#security\" target=\"_blank\">https://hbase.apache.org/book.html#security</a>.\n      </p></div></div><div id=\"hbase_config\"><div class=\"hue-doc-title\">Configuring HBase for Use with Impala</div><div><p>\n        HBase works out of the box with Impala. There is no mandatory configuration needed to use these two\n        components together.\n      </p><p>\n        To avoid delays if HBase is unavailable during Impala startup or after an <span class=\"hue-doc-codeph\">INVALIDATE\n        METADATA</span> statement, set timeout values similar to the following in\n        <span class=\"hue-doc-filepath\">/etc/impala/conf/hbase-site.xml</span>:\n      </p><div class=\"hue-doc-codeblock\">&lt;property&gt;\n  &lt;name&gt;hbase.client.retries.number&lt;/name&gt;\n  &lt;value&gt;3&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n  &lt;name&gt;hbase.rpc.timeout&lt;/name&gt;\n  &lt;value&gt;3000&lt;/value&gt;\n&lt;/property&gt;\n</div></div></div><div id=\"hbase_types\"><div class=\"hue-doc-title\">Supported Data Types for HBase Columns</div><div><p>\n        To understand how Impala column data types are mapped to fields in HBase, you should have some background\n        knowledge about HBase first. You set up the mapping by running the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement\n        in the Hive shell. See\n        <a class=\"hue-doc-external-link\" href=\"https://cwiki.apache.org/confluence/display/Hive/HBaseIntegration\" target=\"_blank\">the\n        Hive wiki</a> for a starting point, and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_hbase.xml\" data-doc-anchor-id=\"hbase_queries\">Examples of Querying HBase Tables from Impala</a> for examples.\n      </p><p>\n        HBase works as a kind of <q>bit bucket</q>, in the sense that HBase does not enforce any typing for the\n        key or value fields. All the type enforcement is done on the Impala side.\n      </p><p> For best performance of Impala queries against HBase tables, most\n        queries will perform comparisons in the <span class=\"hue-doc-codeph\">WHERE</span> clause\n        against the column that corresponds to the HBase row key. When creating\n        the table through the Hive shell, use the <span class=\"hue-doc-codeph\">STRING</span> data\n        type for the column that corresponds to the HBase row key. Impala can\n        translate predicates (through operators such as <span class=\"hue-doc-codeph\">=</span>,\n          <span class=\"hue-doc-codeph\">&lt;</span>, and <span class=\"hue-doc-codeph\">BETWEEN</span>) against this\n        column into fast lookups in HBase, but this optimization (<q>predicate\n          pushdown</q>) only works when that column is defined as\n          <span class=\"hue-doc-codeph\">STRING</span>. </p><p>\n        Starting in Impala 1.1, Impala also supports reading and writing to columns that are defined in the Hive\n        <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement using binary data types, represented in the Hive table definition\n        using the <span class=\"hue-doc-codeph\">#binary</span> keyword, often abbreviated as <span class=\"hue-doc-codeph\">#b</span>. Defining numeric\n        columns as binary can reduce the overall data volume in the HBase tables. You should still define the\n        column that corresponds to the HBase row key as a <span class=\"hue-doc-codeph\">STRING</span>, to allow fast lookups using\n        those columns.\n      </p></div></div><div id=\"hbase_performance\"><div class=\"hue-doc-title\">Performance Considerations for the Impala-HBase Integration</div><div><p>\n        To understand the performance characteristics of SQL queries against data stored in HBase, you should have\n        some background knowledge about how HBase interacts with SQL-oriented systems first. See\n        <a class=\"hue-doc-external-link\" href=\"https://cwiki.apache.org/confluence/display/Hive/HBaseIntegration\" target=\"_blank\">the\n        Hive wiki</a> for a starting point; because Impala shares the same metastore database as Hive, the\n        information about mapping columns from Hive tables to HBase tables is generally applicable to Impala too.\n      </p><p>\n        Impala uses the HBase client API via Java Native Interface (JNI) to query data stored in HBase. This\n        querying does not read HFiles directly. The extra communication overhead makes it important to choose what\n        data to store in HBase or in HDFS, and construct efficient queries that can retrieve the HBase data\n        efficiently:\n      </p><ul><li>\n          Use HBase table for queries that return a single row or a small range of rows,\n          not queries that perform a full table scan of an entire table. (If a query has\n          a HBase table and no <span class=\"hue-doc-codeph\">WHERE</span> clause referencing that table,\n          that is a strong indicator that it is an inefficient query for an HBase table.)\n        </li><li>\n          HBase may offer acceptable performance for storing small dimension tables where\n          the table is small enough that executing a full table scan for every query is\n          efficient enough. However, Kudu is almost always a superior alternative for\n          storing dimension tables. HDFS tables are also appropriate for dimension\n          tables that do not need to support update queries, delete queries or insert\n          queries with small numbers of rows.\n        </li></ul><p>\n        Query predicates are applied to row keys as start and stop keys, thereby limiting the scope of a particular\n        lookup. If row keys are not mapped to string columns, then ordering is typically incorrect and comparison\n        operations do not work. For example, if row keys are not mapped to string columns, evaluating for greater\n        than (&gt;) or less than (&lt;) cannot be completed.\n      </p><p>\n        Predicates on non-key columns can be sent to HBase to scan as <span class=\"hue-doc-codeph\">SingleColumnValueFilters</span>,\n        providing some performance gains. In such a case, HBase returns fewer rows than if those same predicates\n        were applied using Impala. While there is some improvement, it is not as great when start and stop rows are\n        used. This is because the number of rows that HBase must examine is not limited as it is when start and\n        stop rows are used. As long as the row key predicate only applies to a single row, HBase will locate and\n        return that row. Conversely, if a non-key predicate is used, even if it only applies to a single row, HBase\n        must still scan the entire table to find the correct result.\n      </p><div class=\"hue-doc-example\"><div class=\"hue-doc-title\">Interpreting EXPLAIN Output for HBase Queries</div><p>\n          For example, here are some queries against the following Impala table, which is mapped to an HBase table.\n          The examples show excerpts from the output of the <span class=\"hue-doc-codeph\">EXPLAIN</span> statement, demonstrating what\n          things to look for to indicate an efficient or inefficient query against an HBase table.\n        </p><p>\n          The first column (<span class=\"hue-doc-codeph\">cust_id</span>) was specified as the key column in the <span class=\"hue-doc-codeph\">CREATE\n          EXTERNAL TABLE</span> statement; for performance, it is important to declare this column as\n          <span class=\"hue-doc-codeph\">STRING</span>. Other columns, such as <span class=\"hue-doc-codeph\">BIRTH_YEAR</span> and\n          <span class=\"hue-doc-codeph\">NEVER_LOGGED_ON</span>, are also declared as <span class=\"hue-doc-codeph\">STRING</span>, rather than their\n          <q>natural</q> types of <span class=\"hue-doc-codeph\">INT</span> or <span class=\"hue-doc-codeph\">BOOLEAN</span>, because Impala can optimize\n          those types more effectively in HBase tables. For comparison, we leave one column,\n          <span class=\"hue-doc-codeph\">YEAR_REGISTERED</span>, as <span class=\"hue-doc-codeph\">INT</span> to show that filtering on this column is\n          inefficient.\n        </p><div class=\"hue-doc-codeblock\">describe hbase_table;\nQuery: describe hbase_table\n+-----------------------+--------+---------+\n| name                  | type   | comment |\n+-----------------------+--------+---------+\n| cust_id               | <b>string</b> |         |\n| birth_year            | <b>string</b> |         |\n| never_logged_on       | <b>string</b> |         |\n| private_email_address | string |         |\n| year_registered       | <b>int</b>    |         |\n+-----------------------+--------+---------+\n</div><p>\n          The best case for performance involves a single row lookup using an equality comparison on the column\n          defined as the row key:\n        </p><div class=\"hue-doc-codeblock\">explain select count(*) from hbase_table where cust_id = 'some_user@example.com';\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=1.01GB VCores=1                            |\n| WARNING: The following tables are missing relevant table and/or column statistics. |\n| hbase.hbase_table                                                                  |\n|                                                                                    |\n| 03:AGGREGATE [MERGE FINALIZE]                                                      |\n| |  output: sum(count(*))                                                           |\n| |                                                                                  |\n| 02:EXCHANGE [PARTITION=UNPARTITIONED]                                              |\n| |                                                                                  |\n| 01:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    start key: some_user@example.com                                                |</b><b>|    stop key: some_user@example.com\\0                                               |</b>\n+------------------------------------------------------------------------------------+\n</div><p>\n          Another type of efficient query involves a range lookup on the row key column, using SQL operators such\n          as greater than (or equal), less than (or equal), or <span class=\"hue-doc-codeph\">BETWEEN</span>. This example also includes\n          an equality test on a non-key column; because that column is a <span class=\"hue-doc-codeph\">STRING</span>, Impala can let\n          HBase perform that test, indicated by the <span class=\"hue-doc-codeph\">hbase filters:</span> line in the\n          <span class=\"hue-doc-codeph\">EXPLAIN</span> output. Doing the filtering within HBase is more efficient than transmitting all\n          the data to Impala and doing the filtering on the Impala side.\n        </p><div class=\"hue-doc-codeblock\">explain select count(*) from hbase_table where cust_id between 'a' and 'b'\n  and never_logged_on = 'true';\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n...\n\n| 01:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    start key: a                                                                    |</b><b>|    stop key: b\\0                                                                   |</b><b>|    hbase filters: cols:never_logged_on EQUAL 'true'                                |</b>\n+------------------------------------------------------------------------------------+\n</div><p>\n          The query is less efficient if Impala has to evaluate any of the predicates, because Impala must scan the\n          entire HBase table. Impala can only push down predicates to HBase for columns declared as\n          <span class=\"hue-doc-codeph\">STRING</span>. This example tests a column declared as <span class=\"hue-doc-codeph\">INT</span>, and the\n          <span class=\"hue-doc-codeph\">predicates:</span> line in the <span class=\"hue-doc-codeph\">EXPLAIN</span> output indicates that the test is\n          performed after the data is transmitted to Impala.\n        </p><div class=\"hue-doc-codeblock\">explain select count(*) from hbase_table where year_registered = 2010;\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n...\n\n| 01:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    predicates: year_registered = 2010                                              |</b>\n+------------------------------------------------------------------------------------+\n</div><p>\n          The same inefficiency applies if the key column is compared to any non-constant value. Here, even though\n          the key column is a <span class=\"hue-doc-codeph\">STRING</span>, and is tested using an equality operator, Impala must scan\n          the entire HBase table because the key column is compared to another column value rather than a constant.\n        </p><div class=\"hue-doc-codeblock\">explain select count(*) from hbase_table where cust_id = private_email_address;\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n...\n\n| 01:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    predicates: cust_id = private_email_address                                    |</b>\n+------------------------------------------------------------------------------------+\n</div><p>\n          Currently, tests on the row key using <span class=\"hue-doc-codeph\">OR</span> or <span class=\"hue-doc-codeph\">IN</span> clauses are not\n          optimized into direct lookups either. Such limitations might be lifted in the future, so always check the\n          <span class=\"hue-doc-codeph\">EXPLAIN</span> output to be sure whether a particular SQL construct results in an efficient\n          query or not for HBase tables.\n        </p><div class=\"hue-doc-codeblock\">explain select count(*) from hbase_table where\n  cust_id = 'some_user@example.com' or cust_id = 'other_user@example.com';\n+----------------------------------------------------------------------------------------+\n| Explain String                                                                         |\n+----------------------------------------------------------------------------------------+\n...\n\n| 01:AGGREGATE                                                                           |\n| |  output: count(*)                                                                    |\n| |                                                                                      |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                      |</b><b>|    predicates: cust_id = 'some_user@example.com' OR cust_id = 'other_user@example.com' |</b>\n+----------------------------------------------------------------------------------------+\n\nexplain select count(*) from hbase_table where\n  cust_id in ('some_user@example.com', 'other_user@example.com');\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n...\n\n| 01:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 00:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    predicates: cust_id IN ('some_user@example.com', 'other_user@example.com')      |</b>\n+------------------------------------------------------------------------------------+\n</div><p>\n          Either rewrite into separate queries for each value and combine the results in the application, or\n          combine the single-row queries using UNION ALL:\n        </p><div class=\"hue-doc-codeblock\">select count(*) from hbase_table where cust_id = 'some_user@example.com';\nselect count(*) from hbase_table where cust_id = 'other_user@example.com';\n\nexplain\n  select count(*) from hbase_table where cust_id = 'some_user@example.com'\n  union all\n  select count(*) from hbase_table where cust_id = 'other_user@example.com';\n+------------------------------------------------------------------------------------+\n| Explain String                                                                     |\n+------------------------------------------------------------------------------------+\n...\n\n| |  04:AGGREGATE                                                                    |\n| |  |  output: count(*)                                                             |\n| |  |                                                                               |\n<b>| |  03:SCAN HBASE [hbase.hbase_table]                                               |</b><b>| |     start key: other_user@example.com                                            |</b><b>| |     stop key: other_user@example.com\\0                                           |</b>\n| |                                                                                  |\n| 10:MERGE                                                                           |\n...\n\n| 02:AGGREGATE                                                                       |\n| |  output: count(*)                                                                |\n| |                                                                                  |\n<b>| 01:SCAN HBASE [hbase.hbase_table]                                                  |</b><b>|    start key: some_user@example.com                                                |</b><b>|    stop key: some_user@example.com\\0                                               |</b>\n+------------------------------------------------------------------------------------+\n</div></div><div class=\"hue-doc-example\"><div class=\"hue-doc-title\">Configuration Options for Java HBase Applications</div><p> If you have an HBase Java application that calls the\n            <span class=\"hue-doc-codeph\">setCacheBlocks</span> or <span class=\"hue-doc-codeph\">setCaching</span>\n          methods of the class <a class=\"hue-doc-external-link\" href=\"http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html\" target=\"_blank\">org.apache.hadoop.hbase.client.Scan</a>, you can set these same\n          caching behaviors through Impala query options, to control the memory\n          pressure on the HBase RegionServer. For example, when doing queries in\n          HBase that result in full-table scans (which by default are\n          inefficient for HBase), you can reduce memory usage and speed up the\n          queries by turning off the <span class=\"hue-doc-codeph\">HBASE_CACHE_BLOCKS</span> setting\n          and specifying a large number for the <span class=\"hue-doc-codeph\">HBASE_CACHING</span>\n          setting.\n        </p><p>\n          To set these options, issue commands like the following in <span class=\"hue-doc-cmdname\">impala-shell</span>:\n        </p><div class=\"hue-doc-codeblock\">-- Same as calling setCacheBlocks(true) or setCacheBlocks(false).\nset hbase_cache_blocks=true;\nset hbase_cache_blocks=false;\n\n-- Same as calling setCaching(rows).\nset hbase_caching=1000;\n</div><p>\n          Or update the <span class=\"hue-doc-cmdname\">impalad</span> defaults file <span class=\"hue-doc-filepath\">/etc/default/impala</span> and\n          include settings for <span class=\"hue-doc-codeph\">HBASE_CACHE_BLOCKS</span> and/or <span class=\"hue-doc-codeph\">HBASE_CACHING</span> in the\n          <span class=\"hue-doc-codeph\">-default_query_options</span> setting for <span class=\"hue-doc-codeph\">IMPALA_SERVER_ARGS</span>. See\n          <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_config_options.html#config_options\" target=\"_blank\">Modifying Impala Startup Options</a> for details.\n        </p><div class=\"hue-doc-note\">          In Impala 2.0 and later, these options are settable through the JDBC or ODBC interfaces using the\n          <span class=\"hue-doc-codeph\">SET</span> statement.\n        </div></div></div></div><div id=\"hbase_scenarios\"><div class=\"hue-doc-title\">Use Cases for Querying HBase through Impala</div><div><p>\n        The following are representative use cases for using Impala to query HBase tables:\n      </p><ul><li>\n          Using HBase to store rapidly incrementing counters, such as how many times a web page has been viewed, or\n          on a social network, how many connections a user has or how many votes a post received. HBase is\n          efficient for capturing such changeable data: the append-only storage mechanism is efficient for writing\n          each change to disk, and a query always returns the latest value. An application could query specific\n          totals like these from HBase, and combine the results with a broader set of data queried from Impala.\n        </li><li><p>\n            Storing very wide tables in HBase. Wide tables have many columns, possibly thousands, typically\n            recording many attributes for an important subject such as a user of an online service. These tables\n            are also often sparse, that is, most of the columns values are <span class=\"hue-doc-codeph\">NULL</span>, 0,\n            <span class=\"hue-doc-codeph\">false</span>, empty string, or other blank or placeholder value. (For example, any particular\n            web site user might have never used some site feature, filled in a certain field in their profile,\n            visited a particular part of the site, and so on.) A typical query against this kind of table is to\n            look up a single row to retrieve all the information about a specific subject, rather than summing,\n            averaging, or filtering millions of rows as in typical Impala-managed tables.\n          </p></li></ul></div></div><div style=\"display:none;\" id=\"hbase_create_new\"><div class=\"hue-doc-title\">Creating a New HBase Table for Impala to Use</div><div><p>\n        You can create an HBase-backed table through a <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement in the Hive shell,\n        without going into the HBase shell at all:\n      </p></div></div><div style=\"display:none;\" id=\"hbase_reuse_existing\"><div class=\"hue-doc-title\">Associate Impala with an Existing HBase Table</div><div><p>\n        If you already have some HBase tables created through the HBase shell, you can make them accessible to\n        Impala through a <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement in the Hive shell:\n      </p></div></div><div style=\"display:none;\" id=\"hbase_column_families\"><div class=\"hue-doc-title\">Map HBase Columns and Column Families to Impala Columns</div><div><p/></div></div><div id=\"hbase_loading\"><div class=\"hue-doc-title\">Loading Data into an HBase Table</div><div><p>\n        The Impala <span class=\"hue-doc-codeph\">INSERT</span> statement works for HBase tables. The <span class=\"hue-doc-codeph\">INSERT ... VALUES</span>\n        syntax is ideally suited to HBase tables, because inserting a single row is an efficient operation for an\n        HBase table. (For regular Impala tables, with data files in HDFS, the tiny data files produced by\n        <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> are extremely inefficient, so you would not use that technique with\n        tables containing any significant data volume.)\n      </p><p>\n        When you use the <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> syntax, the result in the HBase table could be fewer\n        rows than you expect. HBase only stores the most recent version of each unique row key, so if an\n        <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement copies over multiple rows containing the same value for the\n        key column, subsequent queries will only return one row with each key column value:\n      </p><p>\n        Although Impala does not have an <span class=\"hue-doc-codeph\">UPDATE</span> statement, you can achieve the same effect by\n        doing successive <span class=\"hue-doc-codeph\">INSERT</span> statements using the same value for the key column each time:\n      </p></div></div><div id=\"hbase_limitations\"><div class=\"hue-doc-title\">Limitations and Restrictions of the Impala and HBase Integration</div><div><p>\n        The Impala integration with HBase has the following limitations and restrictions, some inherited from the\n        integration between HBase and Hive, and some unique to Impala:\n      </p><ul><li><p>\n            If you issue a <span class=\"hue-doc-codeph\">DROP TABLE</span> for an internal (Impala-managed) table that is mapped to an\n            HBase table, the underlying table is not removed in HBase. The Hive <span class=\"hue-doc-codeph\">DROP TABLE</span>\n            statement also removes the HBase table in this case.\n          </p></li><li><p>\n            The <span class=\"hue-doc-codeph\">INSERT OVERWRITE</span> statement is not available for HBase tables. You can insert new\n            data, or modify an existing row by inserting a new row with the same key value, but not replace the\n            entire contents of the table. You can do an <span class=\"hue-doc-codeph\">INSERT OVERWRITE</span> in Hive if you need this\n            capability.\n          </p></li><li><p>\n            If you issue a <span class=\"hue-doc-codeph\">CREATE TABLE LIKE</span> statement for a table mapped to an HBase table, the\n            new table is also an HBase table, but inherits the same underlying HBase table name as the original.\n            The new table is effectively an alias for the old one, not a new table with identical column structure.\n            Avoid using <span class=\"hue-doc-codeph\">CREATE TABLE LIKE</span> for HBase tables, to avoid any confusion.\n          </p></li><li><p>\n            Copying data into an HBase table using the Impala <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> syntax might\n            produce fewer new rows than are in the query result set. If the result set contains multiple rows with\n            the same value for the key column, each row supercedes any previous rows with the same key value.\n            Because the order of the inserted rows is unpredictable, you cannot rely on this technique to preserve\n            the <q>latest</q> version of a particular key value.\n          </p></li><li><p>\n            Because the complex data types (<span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, and <span class=\"hue-doc-codeph\">MAP</span>)\n            available in Impala 2.3 and higher are currently only supported in Parquet tables, you cannot\n            use these types in HBase tables that are queried through Impala.\n          </p></li><li><p id=\"hbase_no_load_data\">\n        The <span class=\"hue-doc-codeph\">LOAD DATA</span> statement cannot be used with HBase tables.\n      </p></li><li><p id=\"tablesample_caveat\">\n        The <span class=\"hue-doc-codeph\">TABLESAMPLE</span> clause of the <span class=\"hue-doc-codeph\">SELECT</span> statement does\n        not apply to a table reference derived from a view, a subquery, or anything other than a\n        real base table. This clause only works for tables backed by HDFS or HDFS-like data\n        files, therefore it does not apply to Kudu or HBase tables.\n      </p></li></ul></div></div><div id=\"hbase_queries\"><div class=\"hue-doc-title\">Examples of Querying HBase Tables from Impala</div><div><p>\n        The following examples create an HBase table with four column families,\n        create a corresponding table through Hive,\n        then insert and query the table through Impala.\n      </p><p>\n        In HBase shell, the table\n        name is quoted in <span class=\"hue-doc-codeph\">CREATE</span> and <span class=\"hue-doc-codeph\">DROP</span> statements. Tables created in HBase\n        begin in <q>enabled</q> state; before dropping them through the HBase shell, you must issue a\n        <span class=\"hue-doc-codeph\">disable '<span class=\"hue-doc-varname\">table_name</span>'</span> statement.\n      </p><div class=\"hue-doc-codeblock\">$ hbase shell\n15/02/10 16:07:45\nHBase Shell; enter 'help&lt;RETURN&gt;' for list of supported commands.\nType \"exit&lt;RETURN&gt;\" to leave the HBase Shell\n...\n\nhbase(main):001:0&gt; create 'hbasealltypessmall', 'boolsCF', 'intsCF', 'floatsCF', 'stringsCF'\n0 row(s) in 4.6520 seconds\n\n=&gt; Hbase::Table - hbasealltypessmall\nhbase(main):006:0&gt; quit\n</div><p>\n          Issue the following <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement in the Hive shell. (The Impala <span class=\"hue-doc-codeph\">CREATE\n          TABLE</span> statement currently does not support the <span class=\"hue-doc-codeph\">STORED BY</span> clause, so you switch into Hive to\n          create the table, then back to Impala and the <span class=\"hue-doc-cmdname\">impala-shell</span> interpreter to issue the\n          queries.)\n        </p><p>\n          This example creates an external table mapped to the HBase table, usable by both Impala and Hive. It is\n          defined as an external table so that when dropped by Impala or Hive, the original HBase table is not touched at all.\n        </p><p>\n          The <span class=\"hue-doc-codeph\">WITH SERDEPROPERTIES</span> clause\n          specifies that the first column (<span class=\"hue-doc-codeph\">ID</span>) represents the row key, and maps the remaining\n          columns of the SQL table to HBase column families. The mapping relies on the ordinal order of the\n          columns in the table, not the column names in the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement.\n          The first column is defined to be the lookup key; the\n          <span class=\"hue-doc-codeph\">STRING</span> data type produces the fastest key-based lookups for HBase tables.\n        </p><div class=\"hue-doc-note\">          For Impala with HBase tables, the most important aspect to ensure good performance is to use a\n          <span class=\"hue-doc-codeph\">STRING</span> column as the row key, as shown in this example.\n        </div><div class=\"hue-doc-codeblock\">$ hive\n...\nhive&gt; use hbase;\nOK\nTime taken: 4.095 seconds\nhive&gt; CREATE EXTERNAL TABLE hbasestringids (\n    &gt;   id string,\n    &gt;   bool_col boolean,\n    &gt;   tinyint_col tinyint,\n    &gt;   smallint_col smallint,\n    &gt;   int_col int,\n    &gt;   bigint_col bigint,\n    &gt;   float_col float,\n    &gt;   double_col double,\n    &gt;   date_string_col string,\n    &gt;   string_col string,\n    &gt;   timestamp_col timestamp)\n    &gt; STORED BY 'org.apache.hadoop.hive.hbase.HBaseStorageHandler'\n    &gt; WITH SERDEPROPERTIES (\n    &gt;   \"hbase.columns.mapping\" =\n    &gt;   \":key,boolsCF:bool_col,intsCF:tinyint_col,intsCF:smallint_col,intsCF:int_col,intsCF:\\\n    &gt;   bigint_col,floatsCF:float_col,floatsCF:double_col,stringsCF:date_string_col,\\\n    &gt;   stringsCF:string_col,stringsCF:timestamp_col\"\n    &gt; )\n    &gt; TBLPROPERTIES(\"hbase.table.name\" = \"hbasealltypessmall\");\nOK\nTime taken: 2.879 seconds\nhive&gt; quit;\n</div><p>\n          Once you have established the mapping to an HBase table, you can issue DML statements and queries\n          from Impala. The following example shows a series of <span class=\"hue-doc-codeph\">INSERT</span>\n          statements followed by a query.\n          The ideal kind of query from a performance standpoint\n          retrieves a row from the table based on a row key\n          mapped to a string column.\n          An initial <span class=\"hue-doc-codeph\">INVALIDATE METADATA <span class=\"hue-doc-varname\">table_name</span></span>\n          statement makes the table created through Hive visible to Impala.\n        </p><div class=\"hue-doc-codeblock\">$ impala-shell -i localhost -d hbase\nStarting Impala Shell without Kerberos authentication\nConnected to localhost:21000\n...\nQuery: use `hbase`\n[localhost:21000] &gt; invalidate metadata hbasestringids;\nFetched 0 row(s) in 0.09s\n[localhost:21000] &gt; desc hbasestringids;\n+-----------------+-----------+---------+\n| name            | type      | comment |\n+-----------------+-----------+---------+\n| id              | string    |         |\n| bool_col        | boolean   |         |\n| double_col      | double    |         |\n| float_col       | float     |         |\n| bigint_col      | bigint    |         |\n| int_col         | int       |         |\n| smallint_col    | smallint  |         |\n| tinyint_col     | tinyint   |         |\n| date_string_col | string    |         |\n| string_col      | string    |         |\n| timestamp_col   | timestamp |         |\n+-----------------+-----------+---------+\nFetched 11 row(s) in 0.02s\n[localhost:21000] &gt; insert into hbasestringids values ('0001',true,3.141,9.94,1234567,32768,4000,76,'2014-12-31','Hello world',now());\nInserted 1 row(s) in 0.26s\n[localhost:21000] &gt; insert into hbasestringids values ('0002',false,2.004,6.196,1500,8000,129,127,'2014-01-01','Foo bar',now());\nInserted 1 row(s) in 0.12s\n[localhost:21000] &gt; select * from hbasestringids where id = '0001';\n+------+----------+------------+-------------------+------------+---------+--------------+-------------+-----------------+-------------+-------------------------------+\n| id   | bool_col | double_col | float_col         | bigint_col | int_col | smallint_col | tinyint_col | date_string_col | string_col  | timestamp_col                 |\n+------+----------+------------+-------------------+------------+---------+--------------+-------------+-----------------+-------------+-------------------------------+\n| 0001 | true     | 3.141      | 9.939999580383301 | 1234567    | 32768   | 4000         | 76          | 2014-12-31      | Hello world | 2015-02-10 16:36:59.764838000 |\n+------+----------+------------+-------------------+------------+---------+--------------+-------------+-----------------+-------------+-------------------------------+\nFetched 1 row(s) in 0.54s\n</div><div class=\"hue-doc-note\" id=\"invalidate_metadata_hbase\">        After you create a table in Hive, such as the HBase mapping table in this example, issue\n        an <span class=\"hue-doc-codeph\">INVALIDATE METADATA <span class=\"hue-doc-varname\">table_name</span></span> statement the next\n        time you connect to Impala, make Impala aware of the new table. (Prior to Impala 1.2.4,\n        you could not specify the table name if Impala was not aware of the table yet; in Impala\n        1.2.4 and higher, specifying the table name avoids reloading the metadata for other\n        tables that are not changed.)\n      </div></div></div></div></div>","title":"Using Impala to Query HBase Tables"}