{"body":"<div><div id=\"group_by\"><div class=\"hue-doc-title\">GROUP BY Clause</div><div><p>\n      Specify the <span class=\"hue-doc-codeph\">GROUP BY</span> clause in queries that use aggregation functions, such as\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_count.xml\" data-doc-anchor-id=\"count\">COUNT()</a></span>,\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_sum.xml\" data-doc-anchor-id=\"sum\">SUM()</a></span>,\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_avg.xml\" data-doc-anchor-id=\"avg\">AVG()</a></span>,\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_min.xml\" data-doc-anchor-id=\"min\">MIN()</a></span>, and\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_max.xml\" data-doc-anchor-id=\"max\">MAX()</a></span>. Specify in the\n      <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_group_by.xml\" data-doc-anchor-id=\"group_by\">GROUP BY</a></span> clause the names of all the\n      columns that do not participate in the aggregation operation.\n    </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p>\n      In Impala 2.3 and higher, the complex data types <span class=\"hue-doc-codeph\">STRUCT</span>,\n      <span class=\"hue-doc-codeph\">ARRAY</span>, and <span class=\"hue-doc-codeph\">MAP</span> are available. These columns cannot\n      be referenced directly in the <span class=\"hue-doc-codeph\">ORDER BY</span> clause.\n      When you query a complex type column, you use join notation to <q>unpack</q> the elements\n      of the complex type, and within the join query you can include an <span class=\"hue-doc-codeph\">ORDER BY</span>\n      clause to control the order in the result set of the scalar elements from the complex type.\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about Impala support for complex types.\n    </p><p id=\"zero_length_strings\"><b>Zero-length strings:</b> For purposes of clauses such as <span class=\"hue-doc-codeph\">DISTINCT</span>\n        and <span class=\"hue-doc-codeph\">GROUP BY</span>, Impala considers zero-length strings\n        (<span class=\"hue-doc-codeph\">\"\"</span>), <span class=\"hue-doc-codeph\">NULL</span>, and space to all be different values.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n      For example, the following query finds the 5 items that sold the highest total quantity (using the\n      <span class=\"hue-doc-codeph\">SUM()</span> function, and also counts the number of sales transactions for those items (using the\n      <span class=\"hue-doc-codeph\">COUNT()</span> function). Because the column representing the item IDs is not used in any\n      aggregation functions, we specify that column in the <span class=\"hue-doc-codeph\">GROUP BY</span> clause.\n    </p><div class=\"hue-doc-codeblock\">select\n  <b>ss_item_sk</b> as Item,\n  <b>count</b>(ss_item_sk) as Times_Purchased,\n  <b>sum</b>(ss_quantity) as Total_Quantity_Purchased\nfrom store_sales\n  <b>group by ss_item_sk</b>\n  order by sum(ss_quantity) desc\n  limit 5;\n+-------+-----------------+--------------------------+\n| item  | times_purchased | total_quantity_purchased |\n+-------+-----------------+--------------------------+\n| 9325  | 372             | 19072                    |\n| 4279  | 357             | 18501                    |\n| 7507  | 371             | 18475                    |\n| 5953  | 369             | 18451                    |\n| 16753 | 375             | 18446                    |\n+-------+-----------------+--------------------------+</div><p>\n      The <span class=\"hue-doc-codeph\">HAVING</span> clause lets you filter the results of aggregate functions, because you cannot\n      refer to those expressions in the <span class=\"hue-doc-codeph\">WHERE</span> clause. For example, to find the 5 lowest-selling\n      items that were included in at least 100 sales transactions, we could use this query:\n    </p><div class=\"hue-doc-codeblock\">select\n  <b>ss_item_sk</b> as Item,\n  <b>count</b>(ss_item_sk) as Times_Purchased,\n  <b>sum</b>(ss_quantity) as Total_Quantity_Purchased\nfrom store_sales\n  <b>group by ss_item_sk</b><b>having times_purchased &gt;= 100</b>\n  order by sum(ss_quantity)\n  limit 5;\n+-------+-----------------+--------------------------+\n| item  | times_purchased | total_quantity_purchased |\n+-------+-----------------+--------------------------+\n| 13943 | 105             | 4087                     |\n| 2992  | 101             | 4176                     |\n| 4773  | 107             | 4204                     |\n| 14350 | 103             | 4260                     |\n| 11956 | 102             | 4275                     |\n+-------+-----------------+--------------------------+</div><p>\n      When performing calculations involving scientific or financial data, remember that columns with type\n      <span class=\"hue-doc-codeph\">FLOAT</span> or <span class=\"hue-doc-codeph\">DOUBLE</span> are stored as true floating-point numbers, which cannot\n      precisely represent every possible fractional value. Thus, if you include a <span class=\"hue-doc-codeph\">FLOAT</span> or\n      <span class=\"hue-doc-codeph\">DOUBLE</span> column in a <span class=\"hue-doc-codeph\">GROUP BY</span> clause, the results might not precisely match\n      literal values in your query or from an original Text data file. Use rounding operations, the\n      <span class=\"hue-doc-codeph\">BETWEEN</span> operator, or another arithmetic technique to match floating-point values that are\n      <q>near</q> literal values you expect. For example, this query on the <span class=\"hue-doc-codeph\">ss_wholesale_cost</span>\n      column returns cost values that are close but not identical to the original figures that were entered as\n      decimal fractions.\n    </p><div class=\"hue-doc-codeblock\">select ss_wholesale_cost, avg(ss_quantity * ss_sales_price) as avg_revenue_per_sale\n  from sales\n  group by ss_wholesale_cost\n  order by avg_revenue_per_sale desc\n  limit 5;\n+-------------------+----------------------+\n| ss_wholesale_cost | avg_revenue_per_sale |\n+-------------------+----------------------+\n| 96.94000244140625 | 4454.351539300434    |\n| 95.93000030517578 | 4423.119941283189    |\n| 98.37999725341797 | 4332.516490316291    |\n| 97.97000122070312 | 4330.480601655014    |\n| 98.52999877929688 | 4291.316953108634    |\n+-------------------+----------------------+</div><p>\n      Notice how wholesale cost values originally entered as decimal fractions such as <span class=\"hue-doc-codeph\">96.94</span> and\n      <span class=\"hue-doc-codeph\">98.38</span> are slightly larger or smaller in the result set, due to precision limitations in the\n      hardware floating-point types. The imprecise representation of <span class=\"hue-doc-codeph\">FLOAT</span> and\n      <span class=\"hue-doc-codeph\">DOUBLE</span> values is why financial data processing systems often store currency using data types\n      that are less space-efficient but avoid these types of rounding errors.\n    </p><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_select.xml\" data-doc-anchor-id=\"select\">SELECT Statement</a>,\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_aggregate_functions.xml\" data-doc-anchor-id=\"aggregate_functions\">Impala Aggregate Functions</a></p></div></div></div>","title":"GROUP BY Clause"}