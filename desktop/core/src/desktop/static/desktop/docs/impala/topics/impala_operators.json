{"body":"<div><div id=\"operators\"><div class=\"hue-doc-title\">SQL Operators</div><div><p>\n      SQL operators are a class of comparison functions that are widely used within the <span class=\"hue-doc-codeph\">WHERE</span> clauses of\n      <span class=\"hue-doc-codeph\">SELECT</span> statements.\n    </p><p/></div><div id=\"arithmetic_operators\"><div class=\"hue-doc-title\">Arithmetic Operators</div><div><p>\n        The arithmetic operators use expressions with a left-hand argument, the operator, and then (in most cases) a right-hand argument.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">left_hand_arg</span><span class=\"hue-doc-varname\">binary_operator</span><span class=\"hue-doc-varname\">right_hand_arg</span><span class=\"hue-doc-varname\">unary_operator</span><span class=\"hue-doc-varname\">single_arg</span></div><ul><li><span class=\"hue-doc-codeph\">+</span> and <span class=\"hue-doc-codeph\">-</span>: Can be used either as unary or binary operators.\n          <ul><li><p>\n                With unary notation, such as <span class=\"hue-doc-codeph\">+5</span>, <span class=\"hue-doc-codeph\">-2.5</span>, or <span class=\"hue-doc-codeph\">-<span class=\"hue-doc-varname\">col_name</span></span>,\n                they multiply their single numeric argument by <span class=\"hue-doc-codeph\">+1</span> or <span class=\"hue-doc-codeph\">-1</span>. Therefore, unary\n                <span class=\"hue-doc-codeph\">+</span> returns its argument unchanged, while unary <span class=\"hue-doc-codeph\">-</span> flips the sign of its argument. Although\n                you can double up these operators in expressions such as <span class=\"hue-doc-codeph\">++5</span> (always positive) or <span class=\"hue-doc-codeph\">-+2</span> or\n                <span class=\"hue-doc-codeph\">+-2</span> (both always negative), you cannot double the unary minus operator because <span class=\"hue-doc-codeph\">--</span> is\n                interpreted as the start of a comment. (You can use a double unary minus operator if you separate the <span class=\"hue-doc-codeph\">-</span>\n                characters, for example with a space or parentheses.)\n              </p></li><li><p>\n                With binary notation, such as <span class=\"hue-doc-codeph\">2+2</span>, <span class=\"hue-doc-codeph\">5-2.5</span>, or <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">col1</span> +\n                <span class=\"hue-doc-varname\">col2</span></span>, they add or subtract respectively the right-hand argument to (or from) the left-hand\n                argument. Both arguments must be of numeric types.\n              </p></li></ul></li><li><p><span class=\"hue-doc-codeph\">*</span> and <span class=\"hue-doc-codeph\">/</span>: Multiplication and division respectively. Both arguments must be of numeric types.\n          </p><p>\n            When multiplying, the shorter argument is promoted if necessary (such as <span class=\"hue-doc-codeph\">SMALLINT</span> to <span class=\"hue-doc-codeph\">INT</span> or\n            <span class=\"hue-doc-codeph\">BIGINT</span>, or <span class=\"hue-doc-codeph\">FLOAT</span> to <span class=\"hue-doc-codeph\">DOUBLE</span>), and then the result is promoted again to the\n            next larger type. Thus, multiplying a <span class=\"hue-doc-codeph\">TINYINT</span> and an <span class=\"hue-doc-codeph\">INT</span> produces a <span class=\"hue-doc-codeph\">BIGINT</span>\n            result. Multiplying a <span class=\"hue-doc-codeph\">FLOAT</span> and a <span class=\"hue-doc-codeph\">FLOAT</span> produces a <span class=\"hue-doc-codeph\">DOUBLE</span> result. Multiplying\n            a <span class=\"hue-doc-codeph\">FLOAT</span> and a <span class=\"hue-doc-codeph\">DOUBLE</span> or a <span class=\"hue-doc-codeph\">DOUBLE</span> and a <span class=\"hue-doc-codeph\">DOUBLE</span> produces a\n            <span class=\"hue-doc-codeph\">DECIMAL(38,17)</span>, because <span class=\"hue-doc-codeph\">DECIMAL</span> values can represent much larger and more precise values than\n            <span class=\"hue-doc-codeph\">DOUBLE</span>.\n          </p><p>\n            When dividing, Impala always treats the arguments and result as <span class=\"hue-doc-codeph\">DOUBLE</span> values to avoid losing precision. If you\n            need to insert the results of a division operation into a <span class=\"hue-doc-codeph\">FLOAT</span> column, use the <span class=\"hue-doc-codeph\">CAST()</span>\n            function to convert the result to the correct type.\n          </p></li><li id=\"div\"><p><span class=\"hue-doc-codeph\">DIV</span>: Integer division. Arguments are not promoted to a floating-point type, and any fractional result\n            is discarded. For example, <span class=\"hue-doc-codeph\">13 DIV 7</span> returns 1, <span class=\"hue-doc-codeph\">14 DIV 7</span> returns 2, and\n            <span class=\"hue-doc-codeph\">15 DIV 7</span> returns 2. This operator is the same as the <span class=\"hue-doc-codeph\">QUOTIENT()</span> function.\n          </p></li><li><p><span class=\"hue-doc-codeph\">%</span>: Modulo operator. Returns the remainder of the left-hand argument divided by the right-hand argument. Both\n            arguments must be of one of the integer types.\n          </p></li><li><p><span class=\"hue-doc-codeph\">&amp;</span>, <span class=\"hue-doc-codeph\">|</span>, <span class=\"hue-doc-codeph\">~</span>, and <span class=\"hue-doc-codeph\">^</span>: Bitwise operators that return the\n            logical AND, logical OR, <span class=\"hue-doc-codeph\">NOT</span>, or logical XOR (exclusive OR) of their argument values. Both arguments must be of\n            one of the integer types. If the arguments are of different type, the argument with the smaller type is implicitly extended to\n            match the argument with the longer type.\n          </p></li></ul><p>\n        You can chain a sequence of arithmetic expressions, optionally grouping them with parentheses.\n      </p><p>\n        The arithmetic operators generally do not have equivalent calling conventions using functional notation. For example, prior to\n        Impala 2.2, there is no <span class=\"hue-doc-codeph\">MOD()</span> function equivalent to the <span class=\"hue-doc-codeph\">%</span> modulo operator.\n        Conversely, there are some arithmetic functions that do not have a corresponding operator. For example, for exponentiation you use\n        the <span class=\"hue-doc-codeph\">POW()</span> function, but there is no <span class=\"hue-doc-codeph\">**</span> exponentiation operator. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_math_functions.xml\" data-doc-anchor-id=\"math_functions\">Impala Mathematical Functions</a> for the arithmetic functions you can use.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_aggregation_explanation\">\n        To access a column with a complex type (<span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>,\n        or <span class=\"hue-doc-codeph\">MAP</span>) in an aggregation function, you unpack the individual elements\n        using join notation in the query, and then apply the function to the final scalar item,\n        field, key, or value at the bottom of any nested type hierarchy in the column. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about using\n        complex types in Impala.\n      </p><p id=\"complex_types_aggregation_example\">\n        The following example demonstrates calls to several aggregation functions using values\n        from a column containing nested complex types (an <span class=\"hue-doc-codeph\">ARRAY</span> of\n        <span class=\"hue-doc-codeph\">STRUCT</span> items). The array is unpacked inside the query using join\n        notation. The array elements are referenced using the <span class=\"hue-doc-codeph\">ITEM</span>\n        pseudocolumn, and the structure fields inside the array elements are referenced using\n        dot notation. Numeric values such as <span class=\"hue-doc-codeph\">SUM()</span> and <span class=\"hue-doc-codeph\">AVG()</span>\n        are computed using the numeric <span class=\"hue-doc-codeph\">R_NATIONKEY</span> field, and the\n        general-purpose <span class=\"hue-doc-codeph\">MAX()</span> and <span class=\"hue-doc-codeph\">MIN()</span> values are computed\n        from the string <span class=\"hue-doc-codeph\">N_NAME</span> field.\n<div class=\"hue-doc-codeblock\">describe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\nselect r_name, r_nations.item.n_nationkey\n  from region, region.r_nations as r_nations\norder by r_name, r_nations.item.n_nationkey;\n+-------------+------------------+\n| r_name      | item.n_nationkey |\n+-------------+------------------+\n| AFRICA      | 0                |\n| AFRICA      | 5                |\n| AFRICA      | 14               |\n| AFRICA      | 15               |\n| AFRICA      | 16               |\n| AMERICA     | 1                |\n| AMERICA     | 2                |\n| AMERICA     | 3                |\n| AMERICA     | 17               |\n| AMERICA     | 24               |\n| ASIA        | 8                |\n| ASIA        | 9                |\n| ASIA        | 12               |\n| ASIA        | 18               |\n| ASIA        | 21               |\n| EUROPE      | 6                |\n| EUROPE      | 7                |\n| EUROPE      | 19               |\n| EUROPE      | 22               |\n| EUROPE      | 23               |\n| MIDDLE EAST | 4                |\n| MIDDLE EAST | 10               |\n| MIDDLE EAST | 11               |\n| MIDDLE EAST | 13               |\n| MIDDLE EAST | 20               |\n+-------------+------------------+\n\nselect\n  r_name,\n  count(r_nations.item.n_nationkey) as count,\n  sum(r_nations.item.n_nationkey) as sum,\n  avg(r_nations.item.n_nationkey) as avg,\n  min(r_nations.item.n_name) as minimum,\n  max(r_nations.item.n_name) as maximum,\n  ndv(r_nations.item.n_nationkey) as distinct_vals\nfrom\n  region, region.r_nations as r_nations\ngroup by r_name\norder by r_name;\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |\n| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |\n| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |\n| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |\n| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n</div></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p>\n        The following example shows how to do an arithmetic operation using a numeric field of a <span class=\"hue-doc-codeph\">STRUCT</span> type that is an\n        item within an <span class=\"hue-doc-codeph\">ARRAY</span> column. Once the scalar numeric value <span class=\"hue-doc-codeph\">R_NATIONKEY</span> is extracted, it can be\n        used in an arithmetic expression, such as multiplying by 10:\n      </p><div class=\"hue-doc-codeblock\">-- The SMALLINT is a field within an array of structs.\ndescribe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\n-- When we refer to the scalar value using dot notation,\n-- we can use arithmetic and comparison operators on it\n-- like any other number.\nselect r_name, nation.item.n_name, nation.item.n_nationkey * 10\n  from region, region.r_nations as nation\nwhere nation.item.n_nationkey &lt; 5;\n+-------------+-------------+------------------------------+\n| r_name      | item.n_name | nation.item.n_nationkey * 10 |\n+-------------+-------------+------------------------------+\n| AMERICA     | CANADA      | 30                           |\n| AMERICA     | BRAZIL      | 20                           |\n| AMERICA     | ARGENTINA   | 10                           |\n| MIDDLE EAST | EGYPT       | 40                           |\n| AFRICA      | ALGERIA     | 0                            |\n+-------------+-------------+------------------------------+\n</div></div></div><div id=\"between\"><div class=\"hue-doc-title\">BETWEEN Operator</div><div><p>\n        In a <span class=\"hue-doc-codeph\">WHERE</span> clause, compares an expression to both a lower and upper bound. The comparison is successful is the\n        expression is greater than or equal to the lower bound, and less than or equal to the upper bound. If the bound values are switched,\n        so the lower bound is greater than the upper bound, does not match any values.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">expression</span> BETWEEN <span class=\"hue-doc-varname\">lower_bound</span> AND <span class=\"hue-doc-varname\">upper_bound</span></div><p><b>Data types:</b> Typically used with numeric data types. Works with any data type, although not very practical for\n        <span class=\"hue-doc-codeph\">BOOLEAN</span> values. (<span class=\"hue-doc-codeph\">BETWEEN false AND true</span> will match all <span class=\"hue-doc-codeph\">BOOLEAN</span> values.) Use\n        <span class=\"hue-doc-codeph\">CAST()</span> if necessary to ensure the lower and upper bound values are compatible types. Call string or date/time\n        functions if necessary to extract or transform the relevant portion to compare, especially if the value can be transformed into a\n        number.\n      </p><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Be careful when using short string operands. A longer string that starts with the upper bound value will not be included, because it\n        is considered greater than the upper bound. For example, <span class=\"hue-doc-codeph\">BETWEEN 'A' and 'M'</span> would not match the string value\n        <span class=\"hue-doc-codeph\">'Midway'</span>. Use functions such as <span class=\"hue-doc-codeph\">upper()</span>, <span class=\"hue-doc-codeph\">lower()</span>, <span class=\"hue-doc-codeph\">substr()</span>,\n        <span class=\"hue-doc-codeph\">trim()</span>, and so on if necessary to ensure the comparison works as expected.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-codeblock\">-- Retrieve data for January through June, inclusive.\nselect c1 from t1 where month <b>between 1 and 6</b>;\n\n-- Retrieve data for names beginning with 'A' through 'M' inclusive.\n-- Only test the first letter to ensure all the values starting with 'M' are matched.\n-- Do a case-insensitive comparison to match names with various capitalization conventions.\nselect last_name from customers where upper(substr(last_name,1,1)) <b>between 'A' and 'M'</b>;\n\n-- Retrieve data for only the first week of each month.\nselect count(distinct visitor_id)) from web_traffic where dayofmonth(when_viewed) <b>between 1 and 7</b>;</div><p>\n        The following example shows how to do a <span class=\"hue-doc-codeph\">BETWEEN</span> comparison using a numeric field of a <span class=\"hue-doc-codeph\">STRUCT</span> type\n        that is an item within an <span class=\"hue-doc-codeph\">ARRAY</span> column. Once the scalar numeric value <span class=\"hue-doc-codeph\">R_NATIONKEY</span> is extracted, it\n        can be used in a comparison operator:\n      </p><div class=\"hue-doc-codeblock\">-- The SMALLINT is a field within an array of structs.\ndescribe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\n-- When we refer to the scalar value using dot notation,\n-- we can use arithmetic and comparison operators on it\n-- like any other number.\nselect r_name, nation.item.n_name, nation.item.n_nationkey\nfrom region, region.r_nations as nation\nwhere nation.item.n_nationkey between 3 and 5\n+-------------+-------------+------------------+\n| r_name      | item.n_name | item.n_nationkey |\n+-------------+-------------+------------------+\n| AMERICA     | CANADA      | 3                |\n| MIDDLE EAST | EGYPT       | 4                |\n| AFRICA      | ETHIOPIA    | 5                |\n+-------------+-------------+------------------+\n</div></div></div><div id=\"comparison_operators\"><div class=\"hue-doc-title\">Comparison Operators</div><div><p>\n        Impala supports the familiar comparison operators for checking equality and sort order for the column data types:\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">left_hand_expression</span><span class=\"hue-doc-varname\">comparison_operator</span><span class=\"hue-doc-varname\">right_hand_expression</span></div><ul><li><span class=\"hue-doc-codeph\">=</span>, <span class=\"hue-doc-codeph\">!=</span>, <span class=\"hue-doc-codeph\">&lt;&gt;</span>: apply to all types.\n        </li><li><span class=\"hue-doc-codeph\">&lt;</span>, <span class=\"hue-doc-codeph\">&lt;=</span>, <span class=\"hue-doc-codeph\">&gt;</span>, <span class=\"hue-doc-codeph\">&gt;=</span>: apply to all types; for\n          <span class=\"hue-doc-codeph\">BOOLEAN</span>, <span class=\"hue-doc-codeph\">TRUE</span> is considered greater than <span class=\"hue-doc-codeph\">FALSE</span>.\n        </li></ul><p><b>Alternatives:</b></p><p>\n        The <span class=\"hue-doc-codeph\">IN</span> and <span class=\"hue-doc-codeph\">BETWEEN</span> operators provide shorthand notation for expressing combinations of equality,\n        less than, and greater than comparisons with a single operator.\n      </p><p>\n        Because comparing any value to <span class=\"hue-doc-codeph\">NULL</span> produces <span class=\"hue-doc-codeph\">NULL</span> rather than <span class=\"hue-doc-codeph\">TRUE</span> or\n        <span class=\"hue-doc-codeph\">FALSE</span>, use the <span class=\"hue-doc-codeph\">IS NULL</span> and <span class=\"hue-doc-codeph\">IS NOT NULL</span> operators to check if a value is\n        <span class=\"hue-doc-codeph\">NULL</span> or not.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p>\n        The following example shows how to do an arithmetic operation using a numeric field of a <span class=\"hue-doc-codeph\">STRUCT</span> type that is an\n        item within an <span class=\"hue-doc-codeph\">ARRAY</span> column. Once the scalar numeric value <span class=\"hue-doc-codeph\">R_NATIONKEY</span> is extracted, it can be\n        used with a comparison operator such as <span class=\"hue-doc-codeph\">&lt;</span>:\n      </p><div class=\"hue-doc-codeblock\">-- The SMALLINT is a field within an array of structs.\ndescribe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\n-- When we refer to the scalar value using dot notation,\n-- we can use arithmetic and comparison operators on it\n-- like any other number.\nselect r_name, nation.item.n_name, nation.item.n_nationkey\nfrom region, region.r_nations as nation\nwhere nation.item.n_nationkey &lt; 5\n+-------------+-------------+------------------+\n| r_name      | item.n_name | item.n_nationkey |\n+-------------+-------------+------------------+\n| AMERICA     | CANADA      | 3                |\n| AMERICA     | BRAZIL      | 2                |\n| AMERICA     | ARGENTINA   | 1                |\n| MIDDLE EAST | EGYPT       | 4                |\n| AFRICA      | ALGERIA     | 0                |\n+-------------+-------------+------------------+\n</div></div></div><div style=\"display:none;\" id=\"except\"><div class=\"hue-doc-title\">EXCEPT Operator</div><div><p/></div></div><div id=\"exists\"><div class=\"hue-doc-title\">EXISTS Operator</div><div><p>\n        The <span class=\"hue-doc-codeph\">EXISTS</span> operator tests whether a subquery returns any results. You typically use it to find values from one\n        table that have corresponding values in another table.\n      </p><p>\n        The converse, <span class=\"hue-doc-codeph\">NOT EXISTS</span>, helps to find all the values from one table that do not have any corresponding values in\n        another table.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\">EXISTS (<span class=\"hue-doc-varname\">subquery</span>)\nNOT EXISTS (<span class=\"hue-doc-varname\">subquery</span>)\n</div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        The subquery can refer to a different table than the outer query block, or the same table. For example, you might use\n        <span class=\"hue-doc-codeph\">EXISTS</span> or <span class=\"hue-doc-codeph\">NOT EXISTS</span> to check the existence of parent/child relationships between two columns of\n        the same table.\n      </p><p>\n        You can also use operators and function calls within the subquery to test for other kinds of relationships other than strict\n        equality. For example, you might use a call to <span class=\"hue-doc-codeph\">COUNT()</span> in the subquery to check whether the number of matching\n        values is higher or lower than some limit. You might call a UDF in the subquery to check whether values in one table matches a\n        hashed representation of those same values in a different table.\n      </p><p id=\"null_blurb\"><b>NULL considerations:</b></p><p>\n        If the subquery returns any value at all (even <span class=\"hue-doc-codeph\">NULL</span>), <span class=\"hue-doc-codeph\">EXISTS</span> returns <span class=\"hue-doc-codeph\">TRUE</span> and\n        <span class=\"hue-doc-codeph\">NOT EXISTS</span> returns false.\n      </p><p>\n        The following example shows how even when the subquery returns only <span class=\"hue-doc-codeph\">NULL</span> values, <span class=\"hue-doc-codeph\">EXISTS</span> still\n        returns <span class=\"hue-doc-codeph\">TRUE</span> and thus matches all the rows from the table in the outer query block.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table all_nulls (x int);\n[localhost:21000] &gt; insert into all_nulls values (null), (null), (null);\n[localhost:21000] &gt; select y from t2 where exists (select x from all_nulls);\n+---+\n| y |\n+---+\n| 2 |\n| 4 |\n| 6 |\n+---+\n</div><p>\n        However, if the table in the subquery is empty and so the subquery returns an empty result set, <span class=\"hue-doc-codeph\">EXISTS</span> returns\n        <span class=\"hue-doc-codeph\">FALSE</span>:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table empty (x int);\n[localhost:21000] &gt; select y from t2 where exists (select x from empty);\n[localhost:21000] &gt;\n</div><p id=\"added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"restrictions_blurb\"><b>Restrictions:</b></p><p id=\"subquery_no_limit\">\n        Correlated subqueries used in <span class=\"hue-doc-codeph\">EXISTS</span> and <span class=\"hue-doc-codeph\">IN</span> operators\n        cannot include a <span class=\"hue-doc-codeph\">LIMIT</span> clause.\n      </p><p>\n        Prior to Impala 2.6,\n        the <span class=\"hue-doc-codeph\">NOT EXISTS</span> operator required a correlated subquery.\n        In Impala 2.6 and higher, <span class=\"hue-doc-codeph\">NOT EXISTS</span> works with\n        uncorrelated queries also.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        The following examples refer to these simple tables containing small sets of integers or strings:\n<div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table t1 (x int);\n[localhost:21000] &gt; insert into t1 values (1), (2), (3), (4), (5), (6);\n\n[localhost:21000] &gt; create table t2 (y int);\n[localhost:21000] &gt; insert into t2 values (2), (4), (6);\n\n[localhost:21000] &gt; create table t3 (z int);\n[localhost:21000] &gt; insert into t3 values (1), (3), (5);\n\n[localhost:21000] &gt; create table month_names (m string);\n[localhost:21000] &gt; insert into month_names values\n                  &gt; ('January'), ('February'), ('March'),\n                  &gt; ('April'), ('May'), ('June'), ('July'),\n                  &gt; ('August'), ('September'), ('October'),\n                  &gt; ('November'), ('December');\n</div></p><p>\n        The following example shows a correlated subquery that finds all the values in one table that exist in another table. For each value\n        <span class=\"hue-doc-codeph\">X</span> from <span class=\"hue-doc-codeph\">T1</span>, the query checks if the <span class=\"hue-doc-codeph\">Y</span> column of <span class=\"hue-doc-codeph\">T2</span> contains an\n        identical value, and the <span class=\"hue-doc-codeph\">EXISTS</span> operator returns <span class=\"hue-doc-codeph\">TRUE</span> or <span class=\"hue-doc-codeph\">FALSE</span> as appropriate in\n        each case.\n      </p><div class=\"hue-doc-codeblock\">localhost:21000] &gt; select x from t1 where exists (select y from t2 where t1.x = y);\n+---+\n| x |\n+---+\n| 2 |\n| 4 |\n| 6 |\n+---+\n</div><p>\n        An uncorrelated query is less interesting in this case. Because the subquery always returns <span class=\"hue-doc-codeph\">TRUE</span>, all rows from\n        <span class=\"hue-doc-codeph\">T1</span> are returned. If the table contents where changed so that the subquery did not match any rows, none of the rows\n        from <span class=\"hue-doc-codeph\">T1</span> would be returned.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select x from t1 where exists (select y from t2 where y &gt; 5);\n+---+\n| x |\n+---+\n| 1 |\n| 2 |\n| 3 |\n| 4 |\n| 5 |\n| 6 |\n+---+\n</div><p>\n        The following example shows how an uncorrelated subquery can test for the existence of some condition within a table. By using\n        <span class=\"hue-doc-codeph\">LIMIT 1</span> or an aggregate function, the query returns a single result or no result based on whether the subquery\n        matches any rows. Here, we know that <span class=\"hue-doc-codeph\">T1</span> and <span class=\"hue-doc-codeph\">T2</span> contain some even numbers, but <span class=\"hue-doc-codeph\">T3</span>\n        does not.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select \"contains an even number\" from t1 where exists (select x from t1 where x % 2 = 0) limit 1;\n+---------------------------+\n| 'contains an even number' |\n+---------------------------+\n| contains an even number   |\n+---------------------------+\n[localhost:21000] &gt; select \"contains an even number\" as assertion from t1 where exists (select x from t1 where x % 2 = 0) limit 1;\n+-------------------------+\n| assertion               |\n+-------------------------+\n| contains an even number |\n+-------------------------+\n[localhost:21000] &gt; select \"contains an even number\" as assertion from t2 where exists (select x from t2 where y % 2 = 0) limit 1;\nERROR: AnalysisException: couldn't resolve column reference: 'x'\n[localhost:21000] &gt; select \"contains an even number\" as assertion from t2 where exists (select y from t2 where y % 2 = 0) limit 1;\n+-------------------------+\n| assertion               |\n+-------------------------+\n| contains an even number |\n+-------------------------+\n[localhost:21000] &gt; select \"contains an even number\" as assertion from t3 where exists (select z from t3 where z % 2 = 0) limit 1;\n[localhost:21000] &gt;\n</div><p>\n        The following example finds numbers in one table that are 1 greater than numbers from another table. The <span class=\"hue-doc-codeph\">EXISTS</span>\n        notation is simpler than an equivalent <span class=\"hue-doc-codeph\">CROSS JOIN</span> between the tables. (The example then also illustrates how the\n        same test could be performed using an <span class=\"hue-doc-codeph\">IN</span> operator.)\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select x from t1 where exists (select y from t2 where x = y + 1);\n+---+\n| x |\n+---+\n| 3 |\n| 5 |\n+---+\n[localhost:21000] &gt; select x from t1 where x in (select y + 1 from t2);\n+---+\n| x |\n+---+\n| 3 |\n| 5 |\n+---+\n</div><p>\n        The following example finds values from one table that do not exist in another table.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select x from t1 where not exists (select y from t2 where x = y);\n+---+\n| x |\n+---+\n| 1 |\n| 3 |\n| 5 |\n+---+\n</div><p>\n        The following example uses the <span class=\"hue-doc-codeph\">NOT EXISTS</span> operator to find all the leaf nodes in tree-structured data. This\n        simplified <q>tree of life</q> has multiple levels (class, order, family, and so on), with each item pointing upward through a\n        <span class=\"hue-doc-codeph\">PARENT</span> pointer. The example runs an outer query and a subquery on the same table, returning only those items whose\n        <span class=\"hue-doc-codeph\">ID</span> value is <i>not</i> referenced by the <span class=\"hue-doc-codeph\">PARENT</span> of any other item.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table tree (id int, parent int, name string);\n[localhost:21000] &gt; insert overwrite tree values\n                  &gt; (0, null, \"animals\"),\n                  &gt; (1, 0, \"placentals\"),\n                  &gt; (2, 0, \"marsupials\"),\n                  &gt; (3, 1, \"bats\"),\n                  &gt; (4, 1, \"cats\"),\n                  &gt; (5, 2, \"kangaroos\"),\n                  &gt; (6, 4, \"lions\"),\n                  &gt; (7, 4, \"tigers\"),\n                  &gt; (8, 5, \"red kangaroo\"),\n                  &gt; (9, 2, \"wallabies\");\n[localhost:21000] &gt; select name as \"leaf node\" from tree one\n                  &gt; where not exists (select parent from tree two where one.id = two.parent);\n+--------------+\n| leaf node    |\n+--------------+\n| bats         |\n| lions        |\n| tigers       |\n| red kangaroo |\n| wallabies    |\n+--------------+\n</div><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_subqueries.xml\" data-doc-anchor-id=\"subqueries\">Subqueries in Impala SELECT Statements</a></p></div></div><div id=\"ilike\"><div class=\"hue-doc-title\">ILIKE Operator</div><div><p>\n        A case-insensitive comparison operator for <span class=\"hue-doc-codeph\">STRING</span> data, with basic wildcard capability using <span class=\"hue-doc-codeph\">_</span> to match a single\n        character and <span class=\"hue-doc-codeph\">%</span> to match multiple characters. The argument expression must match the entire string value.\n        Typically, it is more efficient to put any <span class=\"hue-doc-codeph\">%</span> wildcard match at the end of the string.\n      </p><p>\n        This operator, available in Impala 2.5 and higher, is the equivalent of the <span class=\"hue-doc-codeph\">LIKE</span> operator,\n        but with case-insensitive comparisons.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">string_expression</span> ILIKE <span class=\"hue-doc-varname\">wildcard_expression</span><span class=\"hue-doc-varname\">string_expression</span> NOT ILIKE <span class=\"hue-doc-varname\">wildcard_expression</span></div><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        In the following examples, strings that are the same except for differences in uppercase\n        and lowercase match successfully with <span class=\"hue-doc-codeph\">ILIKE</span>, but do not match\n        with <span class=\"hue-doc-codeph\">LIKE</span>:\n      </p><div class=\"hue-doc-codeblock\">select 'fooBar' ilike 'FOOBAR';\n+-------------------------+\n| 'foobar' ilike 'foobar' |\n+-------------------------+\n| true                    |\n+-------------------------+\n\nselect 'fooBar' like 'FOOBAR';\n+------------------------+\n| 'foobar' like 'foobar' |\n+------------------------+\n| false                  |\n+------------------------+\n\nselect 'FOOBAR' ilike 'f%';\n+---------------------+\n| 'foobar' ilike 'f%' |\n+---------------------+\n| true                |\n+---------------------+\n\nselect 'FOOBAR' like 'f%';\n+--------------------+\n| 'foobar' like 'f%' |\n+--------------------+\n| false              |\n+--------------------+\n\nselect 'ABCXYZ' not ilike 'ab_xyz';\n+-----------------------------+\n| not 'abcxyz' ilike 'ab_xyz' |\n+-----------------------------+\n| false                       |\n+-----------------------------+\n\nselect 'ABCXYZ' not like 'ab_xyz';\n+----------------------------+\n| not 'abcxyz' like 'ab_xyz' |\n+----------------------------+\n| true                       |\n+----------------------------+\n</div><p id=\"related_info\"><b>Related information:</b></p><p>\n        For case-sensitive comparisons, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"like\">LIKE Operator</a>.\n        For a more general kind of search operator using regular expressions, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a>\n        or its case-insensitive counterpart <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"iregexp\">IREGEXP Operator</a>.\n      </p></div></div><div id=\"in\"><div class=\"hue-doc-title\">IN Operator</div><div><p>\n        The <span class=\"hue-doc-codeph\">IN</span> operator compares an argument value to a set of values, and returns <span class=\"hue-doc-codeph\">TRUE</span> if the argument\n        matches any value in the set. The <span class=\"hue-doc-codeph\">NOT IN</span> operator reverses the comparison, and checks if the argument value is not\n        part of a set of values.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">expression</span> IN (<span class=\"hue-doc-varname\">expression</span> [, <span class=\"hue-doc-varname\">expression</span>])\n<span class=\"hue-doc-varname\">expression</span> IN (<span class=\"hue-doc-varname\">subquery</span>)\n\n<span class=\"hue-doc-varname\">expression</span> NOT IN (<span class=\"hue-doc-varname\">expression</span> [, <span class=\"hue-doc-varname\">expression</span>])\n<span class=\"hue-doc-varname\">expression</span> NOT IN (<span class=\"hue-doc-varname\">subquery</span>)\n</div><p>\n        The left-hand expression and the set of comparison values must be of compatible types.\n      </p><p>\n        The left-hand expression must consist only of a single value, not a tuple. Although the left-hand expression is typically a column\n        name, it could also be some other value. For example, the <span class=\"hue-doc-codeph\">WHERE</span> clauses <span class=\"hue-doc-codeph\">WHERE id IN (5)</span> and\n        <span class=\"hue-doc-codeph\">WHERE 5 IN (id)</span> produce the same results.\n      </p><p>\n        The set of values to check against can be specified as constants, function calls, column names, or other expressions in the query\n        text. The maximum number of expressions in the <span class=\"hue-doc-codeph\">IN</span> list is 9999. (The maximum number of elements of\n        a single expression is 10,000 items, and the <span class=\"hue-doc-codeph\">IN</span> operator itself counts as one.)\n      </p><p>\n        In Impala 2.0 and higher, the set of values can also be generated by a subquery. <span class=\"hue-doc-codeph\">IN</span> can evaluate an unlimited\n        number of results using a subquery.\n      </p><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Any expression using the <span class=\"hue-doc-codeph\">IN</span> operator could be rewritten as a series of equality tests connected with\n        <span class=\"hue-doc-codeph\">OR</span>, but the <span class=\"hue-doc-codeph\">IN</span> syntax is often clearer, more concise, and easier for Impala to optimize. For\n        example, with partitioned tables, queries frequently use <span class=\"hue-doc-codeph\">IN</span> clauses to filter data by comparing the partition key\n        columns to specific values.\n      </p><p id=\"null_blurb\"><b>NULL considerations:</b></p><p>\n        If there really is a matching non-null value, <span class=\"hue-doc-codeph\">IN</span> returns <span class=\"hue-doc-codeph\">TRUE</span>:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select 1 in (1,null,2,3);\n+----------------------+\n| 1 in (1, null, 2, 3) |\n+----------------------+\n| true                 |\n+----------------------+\n[localhost:21000] &gt; select 1 not in (1,null,2,3);\n+--------------------------+\n| 1 not in (1, null, 2, 3) |\n+--------------------------+\n| false                    |\n+--------------------------+\n</div><p>\n        If the searched value is not found in the comparison values, and the comparison values include <span class=\"hue-doc-codeph\">NULL</span>, the result is\n        <span class=\"hue-doc-codeph\">NULL</span>:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select 5 in (1,null,2,3);\n+----------------------+\n| 5 in (1, null, 2, 3) |\n+----------------------+\n| NULL                 |\n+----------------------+\n[localhost:21000] &gt; select 5 not in (1,null,2,3);\n+--------------------------+\n| 5 not in (1, null, 2, 3) |\n+--------------------------+\n| NULL                     |\n+--------------------------+\n[localhost:21000] &gt; select 1 in (null);\n+-------------+\n| 1 in (null) |\n+-------------+\n| NULL        |\n+-------------+\n[localhost:21000] &gt; select 1 not in (null);\n+-----------------+\n| 1 not in (null) |\n+-----------------+\n| NULL            |\n+-----------------+\n</div><p>\n        If the left-hand argument is <span class=\"hue-doc-codeph\">NULL</span>, <span class=\"hue-doc-codeph\">IN</span> always returns <span class=\"hue-doc-codeph\">NULL</span>. This rule applies even\n        if the comparison values include <span class=\"hue-doc-codeph\">NULL</span>.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select null in (1,2,3);\n+-------------------+\n| null in (1, 2, 3) |\n+-------------------+\n| NULL              |\n+-------------------+\n[localhost:21000] &gt; select null not in (1,2,3);\n+-----------------------+\n| null not in (1, 2, 3) |\n+-----------------------+\n| NULL                  |\n+-----------------------+\n[localhost:21000] &gt; select null in (null);\n+----------------+\n| null in (null) |\n+----------------+\n| NULL           |\n+----------------+\n[localhost:21000] &gt; select null not in (null);\n+--------------------+\n| null not in (null) |\n+--------------------+\n| NULL               |\n+--------------------+\n</div><p id=\"enhanced_in_20\"><b>Added in:</b> Available in earlier Impala releases, but new capabilities were added\n        in Impala 2.0.0</p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p>\n        The following example shows how to do an arithmetic operation using a numeric field of a <span class=\"hue-doc-codeph\">STRUCT</span> type that is an\n        item within an <span class=\"hue-doc-codeph\">ARRAY</span> column. Once the scalar numeric value <span class=\"hue-doc-codeph\">R_NATIONKEY</span> is extracted, it can be\n        used in an arithmetic expression, such as multiplying by 10:\n      </p><div class=\"hue-doc-codeblock\">-- The SMALLINT is a field within an array of structs.\ndescribe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\n-- When we refer to the scalar value using dot notation,\n-- we can use arithmetic and comparison operators on it\n-- like any other number.\nselect r_name, nation.item.n_name, nation.item.n_nationkey\nfrom region, region.r_nations as nation\nwhere nation.item.n_nationkey in (1,3,5)\n+---------+-------------+------------------+\n| r_name  | item.n_name | item.n_nationkey |\n+---------+-------------+------------------+\n| AMERICA | CANADA      | 3                |\n| AMERICA | ARGENTINA   | 1                |\n| AFRICA  | ETHIOPIA    | 5                |\n+---------+-------------+------------------+\n</div><p id=\"restrictions_blurb\"><b>Restrictions:</b></p><p id=\"subquery_no_limit\">\n        Correlated subqueries used in <span class=\"hue-doc-codeph\">EXISTS</span> and <span class=\"hue-doc-codeph\">IN</span> operators\n        cannot include a <span class=\"hue-doc-codeph\">LIMIT</span> clause.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-codeblock\">-- Using IN is concise and self-documenting.\nSELECT * FROM t1 WHERE c1 IN (1,2,10);\n-- Equivalent to series of = comparisons ORed together.\nSELECT * FROM t1 WHERE c1 = 1 OR c1 = 2 OR c1 = 10;\n\nSELECT c1 AS \"starts with vowel\" FROM t2 WHERE upper(substr(c1,1,1)) IN ('A','E','I','O','U');\n\nSELECT COUNT(DISTINCT(visitor_id)) FROM web_traffic WHERE month IN ('January','June','July');</div><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_subqueries.xml\" data-doc-anchor-id=\"subqueries\">Subqueries in Impala SELECT Statements</a></p></div></div><div style=\"display:none;\" id=\"intersect\"><div class=\"hue-doc-title\">INTERSECT Operator</div><div><p/></div></div><div id=\"iregexp\"><div class=\"hue-doc-title\">IREGEXP Operator</div><div><p>\n        Tests whether a value matches a regular expression, using case-insensitive string comparisons.\n        Uses the POSIX regular expression syntax where <span class=\"hue-doc-codeph\">^</span> and\n        <span class=\"hue-doc-codeph\">$</span> match the beginning and end of the string, <span class=\"hue-doc-codeph\">.</span> represents any single character, <span class=\"hue-doc-codeph\">*</span>\n        represents a sequence of zero or more items, <span class=\"hue-doc-codeph\">+</span> represents a sequence of one or more items, <span class=\"hue-doc-codeph\">?</span>\n        produces a non-greedy match, and so on.\n      </p><p>\n        This operator, available in Impala 2.5 and higher, is the equivalent of the <span class=\"hue-doc-codeph\">REGEXP</span> operator,\n        but with case-insensitive comparisons.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">string_expression</span> IREGEXP <span class=\"hue-doc-varname\">regular_expression</span></div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        The <span class=\"hue-doc-codeph\">|</span> symbol is the alternation operator, typically used within <span class=\"hue-doc-codeph\">()</span> to match different sequences.\n        The <span class=\"hue-doc-codeph\">()</span> groups do not allow backreferences. To retrieve the part of a value matched within a <span class=\"hue-doc-codeph\">()</span>\n        section, use the <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_string_functions.xml\" data-doc-anchor-id=\"string_functions/regexp_extract\">regexp_extract()</a></span>\n        built-in function. (Currently, there is not any case-insensitive equivalent for the <span class=\"hue-doc-codeph\">regexp_extract()</span> function.)\n      </p><p id=\"regexp_matching\">\n        In Impala 1.3.1 and higher, the <span class=\"hue-doc-codeph\">REGEXP</span> and <span class=\"hue-doc-codeph\">RLIKE</span>\n        operators now match a regular expression string that occurs anywhere inside the target\n        string, the same as if the regular expression was enclosed on each side by\n        <span class=\"hue-doc-codeph\">.*</span>. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a> for\n        examples. Previously, these operators only succeeded when the regular expression matched\n        the entire target string. This change improves compatibility with the regular expression\n        support for popular database systems. There is no change to the behavior of the\n        <span class=\"hue-doc-codeph\">regexp_extract()</span> and <span class=\"hue-doc-codeph\">regexp_replace()</span> built-in\n        functions.\n      </p><p id=\"regexp_re2\">\n        In Impala 2.0 and later, the Impala regular expression syntax conforms to the POSIX\n        Extended Regular Expression syntax used by the Google RE2 library. For details, see\n        <a class=\"hue-doc-external-link\" href=\"https://code.google.com/p/re2/\" target=\"_blank\">the RE2\n        documentation</a>. It has most idioms familiar from regular expressions in Perl,\n        Python, and so on, including <span class=\"hue-doc-codeph\">.*?</span> for non-greedy matches.\n      </p><p id=\"regexp_re2_warning\">\n        In Impala 2.0 and later, a change in the underlying regular expression library could\n        cause changes in the way regular expressions are interpreted by this function. Test any\n        queries that use regular expressions and adjust the expression patterns if necessary.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_incompatible_changes.xml\" data-doc-anchor-id=\"incompatible_changes_200\">Incompatible Changes Introduced in Impala 2.0.0</a>\n        for details.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        The following examples demonstrate the syntax for the <span class=\"hue-doc-codeph\">IREGEXP</span> operator.\n      </p><div class=\"hue-doc-codeblock\">select 'abcABCaabbcc' iregexp '^[a-c]+$';\n+---------------------------------+\n| 'abcabcaabbcc' iregexp '[a-c]+' |\n+---------------------------------+\n| true                            |\n+---------------------------------+\n</div><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a></p></div></div><div id=\"is_distinct_from\"><div class=\"hue-doc-title\" id=\"is_distinct\">IS DISTINCT FROM Operator</div><div><p> The <span class=\"hue-doc-codeph\">IS DISTINCT FROM</span> operator, and its converse the\n          <span class=\"hue-doc-codeph\">IS NOT DISTINCT FROM</span> operator, test whether or not\n        values are identical. <span class=\"hue-doc-codeph\">IS NOT DISTINCT FROM</span> is similar\n        to the <span class=\"hue-doc-codeph\">=</span> operator, and <span class=\"hue-doc-codeph\">IS DISTINCT\n          FROM</span> is similar to the <span class=\"hue-doc-codeph\">!=</span> operator, except\n        that <span class=\"hue-doc-codeph\">NULL</span> values are treated as identical. Therefore,\n          <span class=\"hue-doc-codeph\">IS NOT DISTINCT FROM</span> returns <span class=\"hue-doc-codeph\">true</span>\n        rather than <span class=\"hue-doc-codeph\">NULL</span>, and <span class=\"hue-doc-codeph\">IS DISTINCT FROM</span>\n        returns <span class=\"hue-doc-codeph\">false</span> rather than <span class=\"hue-doc-codeph\">NULL</span>, when\n        comparing two <span class=\"hue-doc-codeph\">NULL</span> values. If one of the values being\n        compared is <span class=\"hue-doc-codeph\">NULL</span> and the other is not, <span class=\"hue-doc-codeph\">IS\n          DISTINCT FROM</span> returns <span class=\"hue-doc-codeph\">true</span> and <span class=\"hue-doc-codeph\">IS\n          NOT DISTINCT FROM</span> returns <span class=\"hue-doc-codeph\">false</span>, again\n        instead of returning <span class=\"hue-doc-codeph\">NULL</span> in both cases. </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">expression1</span> IS DISTINCT FROM <span class=\"hue-doc-varname\">expression2</span><span class=\"hue-doc-varname\">expression1</span> IS NOT DISTINCT FROM <span class=\"hue-doc-varname\">expression2</span><span class=\"hue-doc-varname\">expression1</span> &lt;=&gt; <span class=\"hue-doc-varname\">expression2</span></div><p>\n        The operator <span class=\"hue-doc-codeph\">&lt;=&gt;</span> is an alias for <span class=\"hue-doc-codeph\">IS NOT DISTINCT FROM</span>.\n        It is typically used as a <span class=\"hue-doc-codeph\">NULL</span>-safe equality operator in join queries.\n        That is, <span class=\"hue-doc-codeph\">A &lt;=&gt; B</span> is true if <span class=\"hue-doc-codeph\">A</span> equals <span class=\"hue-doc-codeph\">B</span>\n        or if both <span class=\"hue-doc-codeph\">A</span> and <span class=\"hue-doc-codeph\">B</span> are <span class=\"hue-doc-codeph\">NULL</span>.\n      </p><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        This operator provides concise notation for comparing two values and always producing a <span class=\"hue-doc-codeph\">true</span> or\n        <span class=\"hue-doc-codeph\">false</span> result, without treating <span class=\"hue-doc-codeph\">NULL</span> as a special case. Otherwise, to unambiguously distinguish\n        between two values requires a compound expression involving <span class=\"hue-doc-codeph\">IS [NOT] NULL</span> tests of both operands in addition to the\n        <span class=\"hue-doc-codeph\">=</span> or <span class=\"hue-doc-codeph\">!=</span> operator.\n      </p><p> The <span class=\"hue-doc-codeph\">&lt;=&gt;</span> operator, used like an equality\n        operator in a join query, is more efficient than the equivalent clause:\n          <span class=\"hue-doc-codeph\">IF (A IS NULL OR B IS NULL, A IS NULL AND B IS NULL, A =\n          B)</span>. The <span class=\"hue-doc-codeph\">&lt;=&gt;</span> operator can use a hash\n        join, while the <span class=\"hue-doc-codeph\">IF</span> expression cannot. </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        The following examples show how <span class=\"hue-doc-codeph\">IS DISTINCT FROM</span> gives output similar to\n        the <span class=\"hue-doc-codeph\">!=</span> operator, and <span class=\"hue-doc-codeph\">IS NOT DISTINCT FROM</span> gives output\n        similar to the <span class=\"hue-doc-codeph\">=</span> operator. The exception is when the expression involves\n        a <span class=\"hue-doc-codeph\">NULL</span> value on one side or both sides, where <span class=\"hue-doc-codeph\">!=</span> and\n        <span class=\"hue-doc-codeph\">=</span> return <span class=\"hue-doc-codeph\">NULL</span> but the <span class=\"hue-doc-codeph\">IS [NOT] DISTINCT FROM</span>\n        operators still return <span class=\"hue-doc-codeph\">true</span> or <span class=\"hue-doc-codeph\">false</span>.\n      </p><div class=\"hue-doc-codeblock\">select 1 is distinct from 0, 1 != 0;\n+----------------------+--------+\n| 1 is distinct from 0 | 1 != 0 |\n+----------------------+--------+\n| true                 | true   |\n+----------------------+--------+\n\nselect 1 is distinct from 1, 1 != 1;\n+----------------------+--------+\n| 1 is distinct from 1 | 1 != 1 |\n+----------------------+--------+\n| false                | false  |\n+----------------------+--------+\n\nselect 1 is distinct from null, 1 != null;\n+-------------------------+-----------+\n| 1 is distinct from null | 1 != null |\n+-------------------------+-----------+\n| true                    | NULL      |\n+-------------------------+-----------+\n\nselect null is distinct from null, null != null;\n+----------------------------+--------------+\n| null is distinct from null | null != null |\n+----------------------------+--------------+\n| false                      | NULL         |\n+----------------------------+--------------+\n\nselect 1 is not distinct from 0, 1 = 0;\n+--------------------------+-------+\n| 1 is not distinct from 0 | 1 = 0 |\n+--------------------------+-------+\n| false                    | false |\n+--------------------------+-------+\n\nselect 1 is not distinct from 1, 1 = 1;\n+--------------------------+-------+\n| 1 is not distinct from 1 | 1 = 1 |\n+--------------------------+-------+\n| true                     | true  |\n+--------------------------+-------+\n\nselect 1 is not distinct from null, 1 = null;\n+-----------------------------+----------+\n| 1 is not distinct from null | 1 = null |\n+-----------------------------+----------+\n| false                       | NULL     |\n+-----------------------------+----------+\n\nselect null is not distinct from null, null = null;\n+--------------------------------+-------------+\n| null is not distinct from null | null = null |\n+--------------------------------+-------------+\n| true                           | NULL        |\n+--------------------------------+-------------+\n</div><p>\n        The following example shows how <span class=\"hue-doc-codeph\">IS DISTINCT FROM</span> considers\n        <span class=\"hue-doc-codeph\">CHAR</span> values to be the same (not distinct from each other)\n        if they only differ in the number of trailing spaces. Therefore, sometimes\n        the result of an <span class=\"hue-doc-codeph\">IS [NOT] DISTINCT FROM</span> operator differs\n        depending on whether the values are <span class=\"hue-doc-codeph\">STRING</span>/<span class=\"hue-doc-codeph\">VARCHAR</span>\n        or <span class=\"hue-doc-codeph\">CHAR</span>.\n      </p><div class=\"hue-doc-codeblock\">select\n  'x' is distinct from 'x ' as string_with_trailing_spaces,\n  cast('x' as char(5)) is distinct from cast('x ' as char(5)) as char_with_trailing_spaces;\n+-----------------------------+---------------------------+\n| string_with_trailing_spaces | char_with_trailing_spaces |\n+-----------------------------+---------------------------+\n| true                        | false                     |\n+-----------------------------+---------------------------+\n</div></div></div><div id=\"is_null\"><div class=\"hue-doc-title\">IS NULL Operator</div><div><p>\n\n        The <span class=\"hue-doc-codeph\">IS NULL</span> operator, and its converse the <span class=\"hue-doc-codeph\">IS NOT NULL</span> operator, test whether a specified value is\n        <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_literals.xml\" data-doc-anchor-id=\"null\">NULL</a></span>. Because using <span class=\"hue-doc-codeph\">NULL</span> with any of the other\n        comparison operators such as <span class=\"hue-doc-codeph\">=</span> or <span class=\"hue-doc-codeph\">!=</span> also returns <span class=\"hue-doc-codeph\">NULL</span> rather than\n        <span class=\"hue-doc-codeph\">TRUE</span> or <span class=\"hue-doc-codeph\">FALSE</span>, you use a special-purpose comparison operator to check for this special condition.\n      </p><p>\n        In Impala 2.11 and higher, you can use\n        the operators <span class=\"hue-doc-codeph\">IS UNKNOWN</span> and\n        <span class=\"hue-doc-codeph\">IS NOT UNKNOWN</span> as synonyms for\n        <span class=\"hue-doc-codeph\">IS NULL</span> and <span class=\"hue-doc-codeph\">IS NOT NULL</span>,\n        respectively.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">expression</span> IS NULL\n<span class=\"hue-doc-varname\">expression</span> IS NOT NULL\n\n<span class=\"hue-doc-ph\"><span class=\"hue-doc-varname\">expression</span> IS UNKNOWN</span><span class=\"hue-doc-ph\"><span class=\"hue-doc-varname\">expression</span> IS NOT UNKNOWN</span></div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        In many cases, <span class=\"hue-doc-codeph\">NULL</span> values indicate some incorrect or incomplete processing during data ingestion or conversion.\n        You might check whether any values in a column are <span class=\"hue-doc-codeph\">NULL</span>, and if so take some followup action to fill them in.\n      </p><p>\n        With sparse data, often represented in <q>wide</q> tables, it is common for most values to be <span class=\"hue-doc-codeph\">NULL</span> with only an\n        occasional non-<span class=\"hue-doc-codeph\">NULL</span> value. In those cases, you can use the <span class=\"hue-doc-codeph\">IS NOT NULL</span> operator to identify the\n        rows containing any data at all for a particular column, regardless of the actual value.\n      </p><p>\n        With a well-designed database schema, effective use of <span class=\"hue-doc-codeph\">NULL</span> values and <span class=\"hue-doc-codeph\">IS NULL</span> and <span class=\"hue-doc-codeph\">IS NOT\n        NULL</span> operators can save having to design custom logic around special values such as 0, -1, <span class=\"hue-doc-codeph\">'N/A'</span>, empty\n        string, and so on. <span class=\"hue-doc-codeph\">NULL</span> lets you distinguish between a value that is known to be 0, false, or empty, and a truly\n        unknown value.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p>\n        The <span class=\"hue-doc-codeph\">IS [NOT] UNKNOWN</span> operator, as with the <span class=\"hue-doc-codeph\">IS [NOT] NULL</span>\n        operator, is not applicable to complex type columns (<span class=\"hue-doc-codeph\">STRUCT</span>,\n        <span class=\"hue-doc-codeph\">ARRAY</span>, or <span class=\"hue-doc-codeph\">MAP</span>). Using a complex type column with this\n        operator causes a query error.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-codeblock\">-- If this value is non-zero, something is wrong.\nselect count(*) from employees where employee_id is null;\n\n-- With data from disparate sources, some fields might be blank.\n-- Not necessarily an error condition.\nselect count(*) from census where household_income is null;\n\n-- Sometimes we expect fields to be null, and followup action\n-- is needed when they are not.\nselect count(*) from web_traffic where weird_http_code is not null;</div></div></div><div id=\"is_true\"><div class=\"hue-doc-title\">IS TRUE Operator</div><div><p>\n        This variation of the <span class=\"hue-doc-codeph\">IS</span> operator tests for truth\n        or falsity, with right-hand arguments <span class=\"hue-doc-codeph\">[NOT] TRUE</span>,\n        <span class=\"hue-doc-codeph\">[NOT] FALSE</span>, and <span class=\"hue-doc-codeph\">[NOT] UNKNOWN</span>.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">expression</span> IS TRUE\n<span class=\"hue-doc-varname\">expression</span> IS NOT TRUE\n\n<span class=\"hue-doc-varname\">expression</span> IS FALSE\n<span class=\"hue-doc-varname\">expression</span> IS NOT FALSE\n\n</div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        This <span class=\"hue-doc-codeph\">IS TRUE</span> and <span class=\"hue-doc-codeph\">IS FALSE</span> forms are\n        similar to doing equality comparisons with the Boolean values\n        <span class=\"hue-doc-codeph\">TRUE</span> and <span class=\"hue-doc-codeph\">FALSE</span>, except that\n        <span class=\"hue-doc-codeph\">IS TRUE</span> and <span class=\"hue-doc-codeph\">IS FALSE</span>\n        always return either <span class=\"hue-doc-codeph\">TRUE</span> or <span class=\"hue-doc-codeph\">FALSE</span>,\n        even if the left-hand side expression returns <span class=\"hue-doc-codeph\">NULL</span></p><p>\n        These operators let you simplify Boolean comparisons that must also\n        check for <span class=\"hue-doc-codeph\">NULL</span>, for example\n        <span class=\"hue-doc-codeph\">X != 10 AND X IS NOT NULL</span> is equivalent to\n        <span class=\"hue-doc-codeph\">(X != 10) IS TRUE</span>.\n      </p><p id=\"boolean_functions_vs_expressions\">\n        In Impala 2.11 and higher, you can use the operators <span class=\"hue-doc-codeph\">IS\n        [NOT] TRUE</span> and <span class=\"hue-doc-codeph\">IS [NOT] FALSE</span> as equivalents for the built-in\n        functions <span class=\"hue-doc-codeph\">ISTRUE()</span>, <span class=\"hue-doc-codeph\">ISNOTTRUE()</span>,\n        <span class=\"hue-doc-codeph\">ISFALSE()</span>, and <span class=\"hue-doc-codeph\">ISNOTFALSE()</span>.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p>\n        The <span class=\"hue-doc-codeph\">IS [NOT] TRUE</span> and <span class=\"hue-doc-codeph\">IS [NOT] FALSE</span> operators are not\n        applicable to complex type columns (<span class=\"hue-doc-codeph\">STRUCT</span>, <span class=\"hue-doc-codeph\">ARRAY</span>, or\n        <span class=\"hue-doc-codeph\">MAP</span>). Using a complex type column with these operators causes a query error.\n      </p><p id=\"added_in_2110\"><b>Added in:</b>Impala 2.11.0</p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select assertion, b, b is true, b is false, b is unknown\n  from boolean_test;\n+-------------+-------+-----------+------------+-----------+\n| assertion   | b     | istrue(b) | isfalse(b) | b is null |\n+-------------+-------+-----------+------------+-----------+\n| 2 + 2 = 4   | true  | true      | false      | false     |\n| 2 + 2 = 5   | false | false     | true       | false     |\n| 1 = null    | NULL  | false     | false      | true      |\n| null = null | NULL  | false     | false      | true      |\n+-------------+-------+-----------+------------+-----------+\n</div></div></div><div id=\"like\"><div class=\"hue-doc-title\">LIKE Operator</div><div><p>\n        A comparison operator for <span class=\"hue-doc-codeph\">STRING</span> data, with basic wildcard capability using the underscore\n        (<span class=\"hue-doc-codeph\">_</span>) to match a single character and the percent sign (<span class=\"hue-doc-codeph\">%</span>) to match multiple\n        characters. The argument expression must match the entire string value.\n        Typically, it is more efficient to put any <span class=\"hue-doc-codeph\">%</span> wildcard match at the end of the string.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">string_expression</span> LIKE <span class=\"hue-doc-varname\">wildcard_expression</span><span class=\"hue-doc-varname\">string_expression</span> NOT LIKE <span class=\"hue-doc-varname\">wildcard_expression</span></div><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-codeblock\">select distinct c_last_name from customer where c_last_name like 'Mc%' or c_last_name like 'Mac%';\nselect count(c_last_name) from customer where c_last_name like 'M%';\nselect c_email_address from customer where c_email_address like '%.edu';\n\n-- We can find 4-letter names beginning with 'M' by calling functions...\nselect distinct c_last_name from customer where length(c_last_name) = 4 and substr(c_last_name,1,1) = 'M';\n-- ...or in a more readable way by matching M followed by exactly 3 characters.\nselect distinct c_last_name from customer where c_last_name like 'M___';</div><p>\n        For case-insensitive comparisons, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"ilike\">ILIKE Operator</a>.\n        For a more general kind of search operator using regular expressions, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a>\n        or its case-insensitive counterpart <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"iregexp\">IREGEXP Operator</a>.\n      </p></div></div><div id=\"logical_operators\"><div class=\"hue-doc-title\">Logical Operators</div><div><p>\n        Logical operators return a <span class=\"hue-doc-codeph\">BOOLEAN</span> value, based on a binary or unary logical operation between arguments that are\n        also Booleans. Typically, the argument expressions use <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"comparison_operators\">comparison\n        operators</a>.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">boolean_expression</span><span class=\"hue-doc-varname\">binary_logical_operator</span><span class=\"hue-doc-varname\">boolean_expression</span><span class=\"hue-doc-varname\">unary_logical_operator</span><span class=\"hue-doc-varname\">boolean_expression</span></div><p>\n        The Impala logical operators are:\n      </p><ul><li><span class=\"hue-doc-codeph\">AND</span>: A binary operator that returns <span class=\"hue-doc-codeph\">true</span> if its left-hand and right-hand arguments both evaluate\n          to <span class=\"hue-doc-codeph\">true</span>, <span class=\"hue-doc-codeph\">NULL</span> if either argument is <span class=\"hue-doc-codeph\">NULL</span>, and <span class=\"hue-doc-codeph\">false</span> otherwise.\n        </li><li><span class=\"hue-doc-codeph\">OR</span>: A binary operator that returns <span class=\"hue-doc-codeph\">true</span> if either of its left-hand and right-hand arguments\n          evaluate to <span class=\"hue-doc-codeph\">true</span>, <span class=\"hue-doc-codeph\">NULL</span> if one argument is <span class=\"hue-doc-codeph\">NULL</span> and the other is either\n          <span class=\"hue-doc-codeph\">NULL</span> or <span class=\"hue-doc-codeph\">false</span>, and <span class=\"hue-doc-codeph\">false</span> otherwise.\n        </li><li><span class=\"hue-doc-codeph\">NOT</span>: A unary operator that flips the state of a Boolean expression from <span class=\"hue-doc-codeph\">true</span> to\n          <span class=\"hue-doc-codeph\">false</span>, or <span class=\"hue-doc-codeph\">false</span> to <span class=\"hue-doc-codeph\">true</span>. If the argument expression is <span class=\"hue-doc-codeph\">NULL</span>,\n          the result remains <span class=\"hue-doc-codeph\">NULL</span>. (When <span class=\"hue-doc-codeph\">NOT</span> is used this way as a unary logical operator, it works\n          differently than the <span class=\"hue-doc-codeph\">IS NOT NULL</span> comparison operator, which returns <span class=\"hue-doc-codeph\">true</span> when applied to a\n          <span class=\"hue-doc-codeph\">NULL</span>.)\n        </li></ul><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p>\n        The following example shows how to do an arithmetic operation using a numeric field of a <span class=\"hue-doc-codeph\">STRUCT</span> type that is an\n        item within an <span class=\"hue-doc-codeph\">ARRAY</span> column. Once the scalar numeric value <span class=\"hue-doc-codeph\">R_NATIONKEY</span> is extracted, it can be\n        used in an arithmetic expression, such as multiplying by 10:\n      </p><div class=\"hue-doc-codeblock\">-- The SMALLINT is a field within an array of structs.\ndescribe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\n-- When we refer to the scalar value using dot notation,\n-- we can use arithmetic and comparison operators on it\n-- like any other number.\nselect r_name, nation.item.n_name, nation.item.n_nationkey\n  from region, region.r_nations as nation\nwhere\n  nation.item.n_nationkey between 3 and 5\n  or nation.item.n_nationkey &lt; 15;\n+-------------+----------------+------------------+\n| r_name      | item.n_name    | item.n_nationkey |\n+-------------+----------------+------------------+\n| EUROPE      | UNITED KINGDOM | 23               |\n| EUROPE      | RUSSIA         | 22               |\n| EUROPE      | ROMANIA        | 19               |\n| ASIA        | VIETNAM        | 21               |\n| ASIA        | CHINA          | 18               |\n| AMERICA     | UNITED STATES  | 24               |\n| AMERICA     | PERU           | 17               |\n| AMERICA     | CANADA         | 3                |\n| MIDDLE EAST | SAUDI ARABIA   | 20               |\n| MIDDLE EAST | EGYPT          | 4                |\n| AFRICA      | MOZAMBIQUE     | 16               |\n| AFRICA      | ETHIOPIA       | 5                |\n+-------------+----------------+------------------+\n</div><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        These examples demonstrate the <span class=\"hue-doc-codeph\">AND</span> operator:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select true and true;\n+---------------+\n| true and true |\n+---------------+\n| true          |\n+---------------+\n[localhost:21000] &gt; select true and false;\n+----------------+\n| true and false |\n+----------------+\n| false          |\n+----------------+\n[localhost:21000] &gt; select false and false;\n+-----------------+\n| false and false |\n+-----------------+\n| false           |\n+-----------------+\n[localhost:21000] &gt; select true and null;\n+---------------+\n| true and null |\n+---------------+\n| NULL          |\n+---------------+\n[localhost:21000] &gt; select (10 &gt; 2) and (6 != 9);\n+-----------------------+\n| (10 &gt; 2) and (6 != 9) |\n+-----------------------+\n| true                  |\n+-----------------------+\n</div><p>\n        These examples demonstrate the <span class=\"hue-doc-codeph\">OR</span> operator:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select true or true;\n+--------------+\n| true or true |\n+--------------+\n| true         |\n+--------------+\n[localhost:21000] &gt; select true or false;\n+---------------+\n| true or false |\n+---------------+\n| true          |\n+---------------+\n[localhost:21000] &gt; select false or false;\n+----------------+\n| false or false |\n+----------------+\n| false          |\n+----------------+\n[localhost:21000] &gt; select true or null;\n+--------------+\n| true or null |\n+--------------+\n| true         |\n+--------------+\n[localhost:21000] &gt; select null or true;\n+--------------+\n| null or true |\n+--------------+\n| true         |\n+--------------+\n[localhost:21000] &gt; select false or null;\n+---------------+\n| false or null |\n+---------------+\n| NULL          |\n+---------------+\n[localhost:21000] &gt; select (1 = 1) or ('hello' = 'world');\n+--------------------------------+\n| (1 = 1) or ('hello' = 'world') |\n+--------------------------------+\n| true                           |\n+--------------------------------+\n[localhost:21000] &gt; select (2 + 2 != 4) or (-1 &gt; 0);\n+--------------------------+\n| (2 + 2 != 4) or (-1 &gt; 0) |\n+--------------------------+\n| false                    |\n+--------------------------+\n</div><p>\n        These examples demonstrate the <span class=\"hue-doc-codeph\">NOT</span> operator:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select not true;\n+----------+\n| not true |\n+----------+\n| false    |\n+----------+\n[localhost:21000] &gt; select not false;\n+-----------+\n| not false |\n+-----------+\n| true      |\n+-----------+\n[localhost:21000] &gt; select not null;\n+----------+\n| not null |\n+----------+\n| NULL     |\n+----------+\n[localhost:21000] &gt; select not (1=1);\n+-------------+\n| not (1 = 1) |\n+-------------+\n| false       |\n+-------------+\n</div></div></div><div id=\"regexp\"><div class=\"hue-doc-title\">REGEXP Operator</div><div><p>\n        Tests whether a value matches a regular expression. Uses the POSIX regular expression syntax where <span class=\"hue-doc-codeph\">^</span> and\n        <span class=\"hue-doc-codeph\">$</span> match the beginning and end of the string, <span class=\"hue-doc-codeph\">.</span> represents any single character, <span class=\"hue-doc-codeph\">*</span>\n        represents a sequence of zero or more items, <span class=\"hue-doc-codeph\">+</span> represents a sequence of one or more items, <span class=\"hue-doc-codeph\">?</span>\n        produces a non-greedy match, and so on.\n      </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">string_expression</span> REGEXP <span class=\"hue-doc-varname\">regular_expression</span></div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        The <span class=\"hue-doc-codeph\">RLIKE</span> operator is a synonym for <span class=\"hue-doc-codeph\">REGEXP</span>.\n      </p><p>\n        The <span class=\"hue-doc-codeph\">|</span> symbol is the alternation operator, typically used within <span class=\"hue-doc-codeph\">()</span> to match different sequences.\n        The <span class=\"hue-doc-codeph\">()</span> groups do not allow backreferences. To retrieve the part of a value matched within a <span class=\"hue-doc-codeph\">()</span>\n        section, use the <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_string_functions.xml\" data-doc-anchor-id=\"string_functions/regexp_extract\">regexp_extract()</a></span>\n        built-in function.\n      </p><p id=\"regexp_matching\">\n        In Impala 1.3.1 and higher, the <span class=\"hue-doc-codeph\">REGEXP</span> and <span class=\"hue-doc-codeph\">RLIKE</span>\n        operators now match a regular expression string that occurs anywhere inside the target\n        string, the same as if the regular expression was enclosed on each side by\n        <span class=\"hue-doc-codeph\">.*</span>. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a> for\n        examples. Previously, these operators only succeeded when the regular expression matched\n        the entire target string. This change improves compatibility with the regular expression\n        support for popular database systems. There is no change to the behavior of the\n        <span class=\"hue-doc-codeph\">regexp_extract()</span> and <span class=\"hue-doc-codeph\">regexp_replace()</span> built-in\n        functions.\n      </p><p id=\"regexp_re2\">\n        In Impala 2.0 and later, the Impala regular expression syntax conforms to the POSIX\n        Extended Regular Expression syntax used by the Google RE2 library. For details, see\n        <a class=\"hue-doc-external-link\" href=\"https://code.google.com/p/re2/\" target=\"_blank\">the RE2\n        documentation</a>. It has most idioms familiar from regular expressions in Perl,\n        Python, and so on, including <span class=\"hue-doc-codeph\">.*?</span> for non-greedy matches.\n      </p><p id=\"regexp_re2_warning\">\n        In Impala 2.0 and later, a change in the underlying regular expression library could\n        cause changes in the way regular expressions are interpreted by this function. Test any\n        queries that use regular expressions and adjust the expression patterns if necessary.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_incompatible_changes.xml\" data-doc-anchor-id=\"incompatible_changes_200\">Incompatible Changes Introduced in Impala 2.0.0</a>\n        for details.\n      </p><p id=\"complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"complex_types_caveat_no_operator\">\n        You cannot refer to a column with a complex data type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n        <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> directly in an operator. You can apply\n        operators only to scalar values that make up a complex type (the fields of a\n        <span class=\"hue-doc-codeph\">STRUCT</span>, the items of an <span class=\"hue-doc-codeph\">ARRAY</span>, or the key or value\n        portion of a <span class=\"hue-doc-codeph\">MAP</span>) as part of a join query that refers to the scalar\n        value using the appropriate dot notation or <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>,\n        or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        The following examples demonstrate the identical syntax for the <span class=\"hue-doc-codeph\">REGEXP</span> and <span class=\"hue-doc-codeph\">RLIKE</span> operators.\n      </p><div class=\"hue-doc-codeblock\" id=\"regexp_rlike_examples\">-- Find all customers whose first name starts with 'J', followed by 0 or more of any character.\nselect c_first_name, c_last_name from customer where c_first_name regexp '^J.*';\nselect c_first_name, c_last_name from customer where c_first_name rlike '^J.*';\n\n-- Find 'Macdonald', where the first 'a' is optional and the 'D' can be upper- or lowercase.\n-- The ^...$ are required, to match the start and end of the value.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^Ma?c[Dd]onald$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^Ma?c[Dd]onald$';\n\n-- Match multiple character sequences, either 'Mac' or 'Mc'.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^(Mac|Mc)donald$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^(Mac|Mc)donald$';\n\n-- Find names starting with 'S', then one or more vowels, then 'r', then any other characters.\n-- Matches 'Searcy', 'Sorenson', 'Sauer'.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^S[aeiou]+r.*$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^S[aeiou]+r.*$';\n\n-- Find names that end with 2 or more vowels: letters from the set a,e,i,o,u.\nselect c_first_name, c_last_name from customer where c_last_name regexp '.*[aeiou]{2,}$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '.*[aeiou]{2,}$';\n\n-- You can use letter ranges in the [] blocks, for example to find names starting with A, B, or C.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^[A-C].*';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^[A-C].*';\n\n-- If you are not sure about case, leading/trailing spaces, and so on, you can process the\n-- column using string functions first.\nselect c_first_name, c_last_name from customer where lower(trim(c_last_name)) regexp '^de.*';\nselect c_first_name, c_last_name from customer where lower(trim(c_last_name)) rlike '^de.*';\n</div><p id=\"related_info\"><b>Related information:</b></p><p>\n        For regular expression matching with case-insensitive comparisons, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"iregexp\">IREGEXP Operator</a>.\n      </p></div></div><div id=\"rlike\"><div class=\"hue-doc-title\">RLIKE Operator</div><div><p>\n        Synonym for the <span class=\"hue-doc-codeph\">REGEXP</span> operator. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_operators.xml\" data-doc-anchor-id=\"regexp\">REGEXP Operator</a> for details.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><p>\n        The following examples demonstrate the identical syntax for the <span class=\"hue-doc-codeph\">REGEXP</span> and <span class=\"hue-doc-codeph\">RLIKE</span> operators.\n      </p><div class=\"hue-doc-codeblock\" id=\"regexp_rlike_examples\">-- Find all customers whose first name starts with 'J', followed by 0 or more of any character.\nselect c_first_name, c_last_name from customer where c_first_name regexp '^J.*';\nselect c_first_name, c_last_name from customer where c_first_name rlike '^J.*';\n\n-- Find 'Macdonald', where the first 'a' is optional and the 'D' can be upper- or lowercase.\n-- The ^...$ are required, to match the start and end of the value.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^Ma?c[Dd]onald$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^Ma?c[Dd]onald$';\n\n-- Match multiple character sequences, either 'Mac' or 'Mc'.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^(Mac|Mc)donald$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^(Mac|Mc)donald$';\n\n-- Find names starting with 'S', then one or more vowels, then 'r', then any other characters.\n-- Matches 'Searcy', 'Sorenson', 'Sauer'.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^S[aeiou]+r.*$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^S[aeiou]+r.*$';\n\n-- Find names that end with 2 or more vowels: letters from the set a,e,i,o,u.\nselect c_first_name, c_last_name from customer where c_last_name regexp '.*[aeiou]{2,}$';\nselect c_first_name, c_last_name from customer where c_last_name rlike '.*[aeiou]{2,}$';\n\n-- You can use letter ranges in the [] blocks, for example to find names starting with A, B, or C.\nselect c_first_name, c_last_name from customer where c_last_name regexp '^[A-C].*';\nselect c_first_name, c_last_name from customer where c_last_name rlike '^[A-C].*';\n\n-- If you are not sure about case, leading/trailing spaces, and so on, you can process the\n-- column using string functions first.\nselect c_first_name, c_last_name from customer where lower(trim(c_last_name)) regexp '^de.*';\nselect c_first_name, c_last_name from customer where lower(trim(c_last_name)) rlike '^de.*';\n</div></div></div></div></div>","title":"SQL Operators"}