{"body":"<div><div id=\"udfs\"><div class=\"hue-doc-title\">Impala User-Defined Functions (UDFs)</div><div><p>\n      User-defined functions (frequently abbreviated as UDFs) let you code your own application logic for\n      processing column values during an Impala query. For example, a UDF could perform calculations using an\n      external math library, combine several column values into one, do geospatial calculations, or other kinds of\n      tests and transformations that are outside the scope of the built-in SQL operators and functions.\n    </p><p>\n      You can use UDFs to simplify query logic when producing reports, or to transform data in flexible ways when\n      copying from one table to another with the <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> syntax.\n    </p><p>\n      You might be familiar with this feature from other database products, under names such as stored functions or\n      stored routines.\n</p><p>\n      Impala support for UDFs is available in Impala 1.2 and higher:\n    </p><ul><li>\n        In Impala 1.1, using UDFs in a query required using the Hive shell. (Because Impala and Hive share the same\n        metastore database, you could switch to Hive to run just those queries requiring UDFs, then switch back to\n        Impala.)\n      </li><li>\n        Starting in Impala 1.2, Impala can run both high-performance native code UDFs written in C++, and\n        Java-based Hive UDFs that you might already have written.\n      </li><li>\n        Impala can run scalar UDFs that return a single value for each row of the result set, and user-defined\n        aggregate functions (UDAFs) that return a value based on a set of rows. Currently, Impala does not support\n        user-defined table functions (UDTFs) or window functions.\n      </li></ul><p/></div><div id=\"udf_concepts\"><div class=\"hue-doc-title\">UDF Concepts</div><div><p>\n        Depending on your use case, you might write all-new functions, reuse Java UDFs that you have already\n        written for Hive, or port Hive Java UDF code to higher-performance native Impala UDFs in C++. You can code\n        either scalar functions for producing results one row at a time, or more complex aggregate functions for\n        doing analysis across. The following sections discuss these different aspects of working with UDFs.\n      </p><p/></div><div id=\"udfs_udafs\"><div class=\"hue-doc-title\">UDFs and UDAFs</div><div><p>\n          Depending on your use case, the user-defined functions (UDFs) you write might accept or produce different\n          numbers of input and output values:\n        </p><ul><li>\n            The most general kind of user-defined function (the one typically referred to by the abbreviation UDF)\n            takes a single input value and produces a single output value. When used in a query, it is called once\n            for each row in the result set. For example:\n<div class=\"hue-doc-codeblock\">select customer_name, is_frequent_customer(customer_id) from customers;\nselect obfuscate(sensitive_column) from sensitive_data;</div></li><li>\n            A user-defined aggregate function (UDAF) accepts a group of values and returns a single value. You use\n            UDAFs to summarize and condense sets of rows, in the same style as the built-in <span class=\"hue-doc-codeph\">COUNT</span>,\n            <span class=\"hue-doc-codeph\">MAX()</span>, <span class=\"hue-doc-codeph\">SUM()</span>, and <span class=\"hue-doc-codeph\">AVG()</span> functions. When called in a\n            query that uses the <span class=\"hue-doc-codeph\">GROUP BY</span> clause, the function is called once for each combination\n            of <span class=\"hue-doc-codeph\">GROUP BY</span> values. For example:\n<div class=\"hue-doc-codeblock\">-- Evaluates multiple rows but returns a single value.\nselect closest_restaurant(latitude, longitude) from places;\n\n-- Evaluates batches of rows and returns a separate value for each batch.\nselect most_profitable_location(store_id, sales, expenses, tax_rate, depreciation) from franchise_data group by year;</div></li><li>\n            Currently, Impala does not support other categories of user-defined functions, such as user-defined\n            table functions (UDTFs) or window functions.\n          </li></ul></div></div><div id=\"native_udfs\"><div class=\"hue-doc-title\">Native Impala UDFs</div><div><p>\n          Impala supports UDFs written in C++, in addition to supporting existing Hive UDFs written in Java.\n          Where practical, use C++ UDFs because the compiled native code can yield higher performance, with\n          UDF execution time often 10x faster for a C++ UDF than the equivalent Java UDF.\n        </p></div></div><div id=\"udfs_hive\"><div class=\"hue-doc-title\">Using Hive UDFs with Impala</div><div><p>\n          Impala can run Java-based user-defined functions (UDFs), originally written for Hive, with no changes,\n          subject to the following conditions:\n        </p><ul><li>\n            The parameters and return value must all use scalar data types supported by Impala. For example, complex or nested\n            types are not supported.\n          </li><li>\n            Hive/Java UDFs must extend\n              <span class=\"hue-doc-codeph\">org.apache.hadoop.hive.ql.exec.UDF</span> class.\n          </li><li>\n            Currently, Hive UDFs that accept or return the <span class=\"hue-doc-codeph\">TIMESTAMP</span> type are not supported.\n          </li><li>\n            Prior to Impala 2.5 the return type must be a <q>Writable</q> type such as <span class=\"hue-doc-codeph\">Text</span> or\n            <span class=\"hue-doc-codeph\">IntWritable</span>, rather than a Java primitive type such as <span class=\"hue-doc-codeph\">String</span> or\n            <span class=\"hue-doc-codeph\">int</span>. Otherwise, the UDF returns <span class=\"hue-doc-codeph\">NULL</span>.\n            <span class=\"hue-doc-ph\">In Impala 2.5 and higher, this restriction is lifted, and both\n            UDF arguments and return values can be Java primitive types.</span></li><li>\n            Hive UDAFs and UDTFs are not supported.\n          </li><li>\n            Typically, a Java UDF will execute several times slower in Impala than the equivalent native UDF\n            written in C++.\n          </li><li>\n            In Impala 2.5 and higher, you can transparently call Hive Java UDFs through Impala,\n            or call Impala Java UDFs through Hive. This feature does not apply to built-in Hive functions.\n            Any Impala Java UDFs created with older versions must be re-created using new <span class=\"hue-doc-codeph\">CREATE FUNCTION</span>\n            syntax, without any signature for arguments or the return value.\n          </li></ul><p>\n          To take full advantage of the Impala architecture and performance features, you can also write\n          Impala-specific UDFs in C++.\n        </p><p>\n          For background about Java-based Hive UDFs, see the\n          <a class=\"hue-doc-external-link\" href=\"https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF\" target=\"_blank\">Hive\n          documentation for UDFs</a>. For examples or tutorials for writing such UDFs, search the web for\n          related blog posts.\n        </p><p>\n          The ideal way to understand how to reuse Java-based UDFs (originally written for Hive) with Impala is to\n          take some of the Hive built-in functions (implemented as Java UDFs) and take the applicable JAR files\n          through the UDF deployment process for Impala, creating new UDFs with different names:\n        </p><ol><li>\n            Take a copy of the Hive JAR file containing the Hive built-in functions. For example, the path might be\n            like <span class=\"hue-doc-filepath\">/usr/lib/hive/lib/hive-exec-0.10.0.jar</span>, with different version\n            numbers corresponding to your specific level of CDH.\n          </li><li>\n            Use <span class=\"hue-doc-codeph\">jar tf <span class=\"hue-doc-varname\">jar_file</span></span> to see a list of the classes inside the JAR.\n            You will see names like <span class=\"hue-doc-codeph\">org/apache/hadoop/hive/ql/udf/UDFLower.class</span> and\n            <span class=\"hue-doc-codeph\">org/apache/hadoop/hive/ql/udf/UDFOPNegative.class</span>. Make a note of the names of the\n            functions you want to experiment with. When you specify the entry points for the Impala <span class=\"hue-doc-codeph\">CREATE\n            FUNCTION</span> statement, change the slash characters to dots and strip off the\n            <span class=\"hue-doc-codeph\">.class</span> suffix, for example <span class=\"hue-doc-codeph\">org.apache.hadoop.hive.ql.udf.UDFLower</span> and\n            <span class=\"hue-doc-codeph\">org.apache.hadoop.hive.ql.udf.UDFOPNegative</span>.\n          </li><li>\n            Copy that file to an HDFS location that Impala can read. (In the examples here, we renamed the file to\n            <span class=\"hue-doc-filepath\">hive-builtins.jar</span> in HDFS for simplicity.)\n          </li><li>\n            For each Java-based UDF that you want to call through Impala, issue a <span class=\"hue-doc-codeph\">CREATE FUNCTION</span>\n            statement, with a <span class=\"hue-doc-codeph\">LOCATION</span> clause containing the full HDFS path of the JAR file, and a\n            <span class=\"hue-doc-codeph\">SYMBOL</span> clause with the fully qualified name of the class, using dots as separators and\n            without the <span class=\"hue-doc-codeph\">.class</span> extension. Remember that user-defined functions are associated with\n            a particular database, so issue a <span class=\"hue-doc-codeph\">USE</span> statement for the appropriate database first, or\n            specify the SQL function name as\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">db_name</span>.<span class=\"hue-doc-varname\">function_name</span></span>. Use completely new names\n            for the SQL functions, because Impala UDFs cannot have the same name as Impala built-in functions.\n          </li><li>\n            Call the function from your queries, passing arguments of the correct type to match the function\n            signature. These arguments could be references to columns, arithmetic or other kinds of expressions,\n            the results of <span class=\"hue-doc-codeph\">CAST</span> functions to ensure correct data types, and so on.\n          </li></ol><div class=\"hue-doc-note\"><p id=\"refresh_functions_tip\">\n        In Impala 2.9 and higher, you can refresh the user-defined functions (UDFs)\n        that Impala recognizes, at the database level, by running the <span class=\"hue-doc-codeph\">REFRESH FUNCTIONS</span>\n        statement with the database name as an argument. Java-based UDFs can be added to the metastore\n        database through Hive <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statements, and made visible to Impala\n        by subsequently running <span class=\"hue-doc-codeph\">REFRESH FUNCTIONS</span>. For example:\n\n<div class=\"hue-doc-codeblock\">CREATE DATABASE shared_udfs;\nUSE shared_udfs;\n...use CREATE FUNCTION statements in Hive to create some Java-based UDFs\n   that Impala is not initially aware of...\nREFRESH FUNCTIONS shared_udfs;\nSELECT udf_created_by_hive(c1) FROM ...\n</div></p></div><div class=\"hue-doc-example\"><div class=\"hue-doc-title\">Java UDF Example: Reusing lower() Function</div><p>\n            For example, the following <span class=\"hue-doc-cmdname\">impala-shell</span> session creates an Impala UDF\n            <span class=\"hue-doc-codeph\">my_lower()</span> that reuses the Java code for the Hive <span class=\"hue-doc-codeph\">lower()</span>: built-in\n            function. We cannot call it <span class=\"hue-doc-codeph\">lower()</span> because Impala does not allow UDFs to have the\n            same name as built-in functions. From SQL, we call the function in a basic way (in a query with no\n            <span class=\"hue-doc-codeph\">WHERE</span> clause), directly on a column, and on the results of a string expression:\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create database udfs;\n[localhost:21000] &gt; use udfs;\nlocalhost:21000] &gt; create function lower(string) returns string location '/user/hive/udfs/hive.jar' symbol='org.apache.hadoop.hive.ql.udf.UDFLower';\nERROR: AnalysisException: Function cannot have the same name as a builtin: lower\n[localhost:21000] &gt; create function my_lower(string) returns string location '/user/hive/udfs/hive.jar' symbol='org.apache.hadoop.hive.ql.udf.UDFLower';\n[localhost:21000] &gt; select my_lower('Some String NOT ALREADY LOWERCASE');\n+----------------------------------------------------+\n| udfs.my_lower('some string not already lowercase') |\n+----------------------------------------------------+\n| some string not already lowercase                  |\n+----------------------------------------------------+\nReturned 1 row(s) in 0.11s\n[localhost:21000] &gt; create table t2 (s string);\n[localhost:21000] &gt; insert into t2 values ('lower'),('UPPER'),('Init cap'),('CamelCase');\nInserted 4 rows in 2.28s\n[localhost:21000] &gt; select * from t2;\n+-----------+\n| s         |\n+-----------+\n| lower     |\n| UPPER     |\n| Init cap  |\n| CamelCase |\n+-----------+\nReturned 4 row(s) in 0.47s\n[localhost:21000] &gt; select my_lower(s) from t2;\n+------------------+\n| udfs.my_lower(s) |\n+------------------+\n| lower            |\n| upper            |\n| init cap         |\n| camelcase        |\n+------------------+\nReturned 4 row(s) in 0.54s\n[localhost:21000] &gt; select my_lower(concat('ABC ',s,' XYZ')) from t2;\n+------------------------------------------+\n| udfs.my_lower(concat('abc ', s, ' xyz')) |\n+------------------------------------------+\n| abc lower xyz                            |\n| abc upper xyz                            |\n| abc init cap xyz                         |\n| abc camelcase xyz                        |\n+------------------------------------------+\nReturned 4 row(s) in 0.22s</div></div><div class=\"hue-doc-example\"><div class=\"hue-doc-title\">Java UDF Example: Reusing negative() Function</div><p>\n            Here is an example that reuses the Hive Java code for the <span class=\"hue-doc-codeph\">negative()</span> built-in\n            function. This example demonstrates how the data types of the arguments must match precisely with the\n            function signature. At first, we create an Impala SQL function that can only accept an integer\n            argument. Impala cannot find a matching function when the query passes a floating-point argument,\n            although we can call the integer version of the function by casting the argument. Then we overload the\n            same function name to also accept a floating-point argument.\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table t (x int);\n[localhost:21000] &gt; insert into t values (1), (2), (4), (100);\nInserted 4 rows in 1.43s\n[localhost:21000] &gt; create function my_neg(bigint) returns bigint location '/user/hive/udfs/hive.jar' symbol='org.apache.hadoop.hive.ql.udf.UDFOPNegative';\n[localhost:21000] &gt; select my_neg(4);\n+----------------+\n| udfs.my_neg(4) |\n+----------------+\n| -4             |\n+----------------+\n[localhost:21000] &gt; select my_neg(x) from t;\n+----------------+\n| udfs.my_neg(x) |\n+----------------+\n| -2             |\n| -4             |\n| -100           |\n+----------------+\nReturned 3 row(s) in 0.60s\n[localhost:21000] &gt; select my_neg(4.0);\nERROR: AnalysisException: No matching function with signature: udfs.my_neg(FLOAT).\n[localhost:21000] &gt; select my_neg(cast(4.0 as int));\n+-------------------------------+\n| udfs.my_neg(cast(4.0 as int)) |\n+-------------------------------+\n| -4                            |\n+-------------------------------+\nReturned 1 row(s) in 0.11s\n[localhost:21000] &gt; create function my_neg(double) returns double location '/user/hive/udfs/hive.jar' symbol='org.apache.hadoop.hive.ql.udf.UDFOPNegative';\n[localhost:21000] &gt; select my_neg(4.0);\n+------------------+\n| udfs.my_neg(4.0) |\n+------------------+\n| -4               |\n+------------------+\nReturned 1 row(s) in 0.11s</div></div></div></div></div><div id=\"udf_runtime\"><div class=\"hue-doc-title\">Runtime Environment for UDFs</div><div><p>\n        By default, Impala copies UDFs into <span class=\"hue-doc-filepath\">/tmp</span>,\n        and you can configure this location through the <span class=\"hue-doc-codeph\">--local_library_dir</span>\n        startup flag for the <span class=\"hue-doc-cmdname\">impalad</span> daemon.\n      </p></div></div><div id=\"udf_demo_env\"><div class=\"hue-doc-title\">Installing the UDF Development Package</div><div><p>\n        To develop UDFs for Impala, download and install the <span class=\"hue-doc-codeph\">impala-udf-devel</span> package (RHEL-based\n        distributions) or <span class=\"hue-doc-codeph\">impala-udf-dev</span> (Ubuntu and Debian). This package contains\n        header files, sample source, and build configuration files.\n      </p><ol><li>\n          Locate the appropriate <span class=\"hue-doc-codeph\">.repo</span> or list file for your operating system version.\n        </li><li>\n          Use the familiar <span class=\"hue-doc-codeph\">yum</span>, <span class=\"hue-doc-codeph\">zypper</span>, or <span class=\"hue-doc-codeph\">apt-get</span> commands\n          depending on your operating system. For the package name, specify <span class=\"hue-doc-codeph\">impala-udf-devel</span>\n          (RHEL-based distributions) or <span class=\"hue-doc-codeph\">impala-udf-dev</span> (Ubuntu and Debian).\n        </li></ol><div class=\"hue-doc-note\">        The UDF development code does not rely on Impala being installed on the same machine. You can write and\n        compile UDFs on a minimal development system, then deploy them on a different one for use with Impala.\n      </div><p>\n        When you are ready to start writing your own UDFs, download the sample code and build scripts from\n        \n    impala-udf-samples\n  .\n        Then see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udf_coding\">Writing User-Defined Functions (UDFs)</a> for how to code UDFs, and\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udf_tutorial\">Examples of Creating and Using UDFs</a> for how to build and run UDFs.\n      </p></div></div><div id=\"udf_coding\"><div class=\"hue-doc-title\">Writing User-Defined Functions (UDFs)</div><div><p>\n        Before starting UDF development, make sure to install the development package and download the UDF code\n        samples, as described in <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_udf.xml\" data-doc-anchor-id=\"udf_demo_env\">Installing the UDF Development Package</a>.\n      </p><p>\n        When writing UDFs:\n      </p><ul><li>\n          Keep in mind the data type differences as you transfer values from the high-level SQL to your lower-level\n          UDF code. For example, in the UDF code you might be much more aware of how many bytes different kinds of\n          integers require.\n        </li><li>\n          Use best practices for function-oriented programming: choose arguments carefully, avoid side effects,\n          make each function do a single thing, and so on.\n        </li></ul><p/></div><div id=\"udf_exploring\"><div class=\"hue-doc-title\">Getting Started with UDF Coding</div><div><p>\n          To understand the layout and member variables and functions of the predefined UDF data types, examine the\n          header file <span class=\"hue-doc-filepath\">/usr/include/impala_udf/udf.h</span>:\n        </p><div class=\"hue-doc-codeblock\">// This is the only Impala header required to develop UDFs and UDAs. This header\n// contains the types that need to be used and the FunctionContext object. The context\n// object serves as the interface object between the UDF/UDA and the impala process. </div><p>\n          For the basic declarations needed to write a scalar UDF, see the header file\n          \n    udf-sample.h\n  \n          within the sample build environment, which defines a simple function\n          named <span class=\"hue-doc-codeph\">AddUdf()</span>:\n        </p><div class=\"hue-doc-codeblock\">#ifndef IMPALA_UDF_SAMPLE_UDF_H\n#define IMPALA_UDF_SAMPLE_UDF_H\n\n#include &lt;impala_udf/udf.h&gt;\n\nusing namespace impala_udf;\n\nIntVal AddUdf(FunctionContext* context, const IntVal&amp; arg1, const IntVal&amp; arg2);\n\n#endif\n</div><p>\n          For sample C++ code for a simple function named <span class=\"hue-doc-codeph\">AddUdf()</span>, see the source file\n          <span class=\"hue-doc-filepath\">udf-sample.cc</span> within the sample build environment:\n        </p><div class=\"hue-doc-codeblock\">#include \"udf-sample.h\"\n\n// In this sample we are declaring a UDF that adds two ints and returns an int.\nIntVal AddUdf(FunctionContext* context, const IntVal&amp; arg1, const IntVal&amp; arg2) {\n  if (arg1.is_null || arg2.is_null) return IntVal::null();\n  return IntVal(arg1.val + arg2.val);\n}\n\n// Multiple UDFs can be defined in the same file</div></div></div><div id=\"udfs_args\"><div class=\"hue-doc-title\">Data Types for Function Arguments and Return Values</div><div><p>\n          Each value that a user-defined function can accept as an argument or return as a result value must map to\n          a SQL data type that you could specify for a table column.\n        </p><p id=\"udfs_no_complex_types\">\n        Currently, Impala UDFs cannot accept arguments or return values of the Impala complex types\n        (<span class=\"hue-doc-codeph\">STRUCT</span>, <span class=\"hue-doc-codeph\">ARRAY</span>, or <span class=\"hue-doc-codeph\">MAP</span>).\n      </p><p>\n          Each data type has a corresponding structure defined in the C++ and Java header files, with two member\n          fields and some predefined comparison operators and constructors:\n        </p><ul><li><p><span class=\"hue-doc-codeph\">is_null</span> indicates whether the value is <span class=\"hue-doc-codeph\">NULL</span> or not.\n              <span class=\"hue-doc-codeph\">val</span> holds the actual argument or return value when it is non-<span class=\"hue-doc-codeph\">NULL</span>.\n            </p></li><li><p>\n              Each struct also defines a <span class=\"hue-doc-codeph\">null()</span> member function that constructs an instance of the\n              struct with the <span class=\"hue-doc-codeph\">is_null</span> flag set.\n            </p></li><li><p>\n              The built-in SQL comparison operators and clauses such as <span class=\"hue-doc-codeph\">&lt;</span>,\n              <span class=\"hue-doc-codeph\">&gt;=</span>, <span class=\"hue-doc-codeph\">BETWEEN</span>, and <span class=\"hue-doc-codeph\">ORDER BY</span> all work\n              automatically based on the SQL return type of each UDF. For example, Impala knows how to evaluate\n              <span class=\"hue-doc-codeph\">BETWEEN 1 AND udf_returning_int(col1)</span> or <span class=\"hue-doc-codeph\">ORDER BY\n              udf_returning_string(col2)</span> without you declaring any comparison operators within the UDF\n              itself.\n            </p><p>\n              For convenience within your UDF code, each struct defines <span class=\"hue-doc-codeph\">==</span> and <span class=\"hue-doc-codeph\">!=</span>\n              operators for comparisons with other structs of the same type. These are for typical C++ comparisons\n              within your own code, not necessarily reproducing SQL semantics. For example, if the\n              <span class=\"hue-doc-codeph\">is_null</span> flag is set in both structs, they compare as equal. That behavior of\n              <span class=\"hue-doc-codeph\">null</span> comparisons is different from SQL (where <span class=\"hue-doc-codeph\">NULL == NULL</span> is\n              <span class=\"hue-doc-codeph\">NULL</span> rather than <span class=\"hue-doc-codeph\">true</span>), but more in line with typical C++ behavior.\n            </p></li><li><p>\n              Each kind of struct has one or more constructors that define a filled-in instance of the struct,\n              optionally with default values.\n            </p></li><li><p>\n              Impala cannot process UDFs that accept composite or nested types\n              as arguments or return them as result values. This limitation\n              applies both to Impala UDFs written in C++ and Java-based Hive\n              UDFs.\n            </p></li><li><p>\n              You can overload functions by creating multiple functions with the same SQL name but different\n              argument types. For overloaded functions, you must use different C++ or Java entry point names in the\n              underlying functions.\n            </p></li></ul><p>\n          The data types defined on the C++ side (in <span class=\"hue-doc-filepath\">/usr/include/impala_udf/udf.h</span>) are:\n        </p><ul><li><p><span class=\"hue-doc-codeph\">IntVal</span> represents an <span class=\"hue-doc-codeph\">INT</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">BigIntVal</span> represents a <span class=\"hue-doc-codeph\">BIGINT</span> column. Even if you do not need the\n              full range of a <span class=\"hue-doc-codeph\">BIGINT</span> value, it can be useful to code your function arguments as\n              <span class=\"hue-doc-codeph\">BigIntVal</span> to make it convenient to call the function with different kinds of integer\n              columns and expressions as arguments. Impala automatically casts smaller integer types to larger ones\n              when appropriate, but does not implicitly cast large integer types to smaller ones.\n            </p></li><li><p><span class=\"hue-doc-codeph\">SmallIntVal</span> represents a <span class=\"hue-doc-codeph\">SMALLINT</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">TinyIntVal</span> represents a <span class=\"hue-doc-codeph\">TINYINT</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">StringVal</span> represents a <span class=\"hue-doc-codeph\">STRING</span> column. It has a <span class=\"hue-doc-codeph\">len</span>\n              field representing the length of the string, and a <span class=\"hue-doc-codeph\">ptr</span> field pointing to the string\n              data. It has constructors that create a new <span class=\"hue-doc-codeph\">StringVal</span> struct based on a\n              null-terminated C-style string, or a pointer plus a length; these new structs still refer to the\n              original string data rather than allocating a new buffer for the data. It also has a constructor that\n              takes a pointer to a <span class=\"hue-doc-codeph\">FunctionContext</span> struct and a length, that does allocate space\n              for a new copy of the string data, for use in UDFs that return string values.\n            </p></li><li><p><span class=\"hue-doc-codeph\">BooleanVal</span> represents a <span class=\"hue-doc-codeph\">BOOLEAN</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">FloatVal</span> represents a <span class=\"hue-doc-codeph\">FLOAT</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">DoubleVal</span> represents a <span class=\"hue-doc-codeph\">DOUBLE</span> column.\n            </p></li><li><p><span class=\"hue-doc-codeph\">TimestampVal</span> represents a <span class=\"hue-doc-codeph\">TIMESTAMP</span> column. It has a\n              <span class=\"hue-doc-codeph\">date</span> field, a 32-bit integer representing the Gregorian date, that is, the days past\n              the epoch date. It also has a <span class=\"hue-doc-codeph\">time_of_day</span> field, a 64-bit integer representing the\n              current time of day in nanoseconds.\n            </p></li></ul></div></div><div id=\"udf_varargs\"><div class=\"hue-doc-title\">Variable-Length Argument Lists</div><div><p>\n          UDFs typically take a fixed number of arguments, with each one named explicitly in the signature of your\n          C++ function. Your function can also accept additional optional arguments, all of the same type. For\n          example, you can concatenate two strings, three strings, four strings, and so on. Or you can compare two\n          numbers, three numbers, four numbers, and so on.\n        </p><p>\n          To accept a variable-length argument list, code the signature of your function like this:\n        </p><div class=\"hue-doc-codeblock\">StringVal Concat(FunctionContext* context, const StringVal&amp; separator,\n  int num_var_args, const StringVal* args);</div><p>\n          In the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement, after the type of the first optional argument, include\n          <span class=\"hue-doc-codeph\">...</span> to indicate it could be followed by more arguments of the same type. For example,\n          the following function accepts a <span class=\"hue-doc-codeph\">STRING</span> argument, followed by one or more additional\n          <span class=\"hue-doc-codeph\">STRING</span> arguments:\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create function my_concat(string, string ...) returns string location '/user/test_user/udfs/sample.so' symbol='Concat';\n</div><p>\n          The call from the SQL query must pass at least one argument to the variable-length portion of the\n          argument list.\n        </p><p>\n          When Impala calls the function, it fills in the initial set of required arguments, then passes the number\n          of extra arguments and a pointer to the first of those optional arguments.\n        </p></div></div><div id=\"udf_null\"><div class=\"hue-doc-title\">Handling NULL Values</div><div><p>\n          For correctness, performance, and reliability, it is important for each UDF to handle all situations\n          where any <span class=\"hue-doc-codeph\">NULL</span> values are passed to your function. For example, when passed a\n          <span class=\"hue-doc-codeph\">NULL</span>, UDFs typically also return <span class=\"hue-doc-codeph\">NULL</span>. In an aggregate function, which\n          could be passed a combination of real and <span class=\"hue-doc-codeph\">NULL</span> values, you might make the final value\n          into a <span class=\"hue-doc-codeph\">NULL</span> (as in <span class=\"hue-doc-codeph\">CONCAT()</span>), ignore the <span class=\"hue-doc-codeph\">NULL</span> value\n          (as in <span class=\"hue-doc-codeph\">AVG()</span>), or treat it the same as a numeric zero or empty string.\n        </p><p>\n          Each parameter type, such as <span class=\"hue-doc-codeph\">IntVal</span> or <span class=\"hue-doc-codeph\">StringVal</span>, has an\n          <span class=\"hue-doc-codeph\">is_null</span> Boolean member.\n\n          Test this flag immediately for each argument to your function, and if it is set, do not refer to the\n          <span class=\"hue-doc-codeph\">val</span> field of the argument structure. The <span class=\"hue-doc-codeph\">val</span> field is undefined when\n          the argument is <span class=\"hue-doc-codeph\">NULL</span>, so your function could go into an infinite loop or produce\n          incorrect results if you skip the special handling for <span class=\"hue-doc-codeph\">NULL</span>.\n</p><p>\n          If your function returns <span class=\"hue-doc-codeph\">NULL</span> when passed a <span class=\"hue-doc-codeph\">NULL</span> value, or in other\n          cases such as when a search string is not found, you can construct a null instance of the return type by\n          using its <span class=\"hue-doc-codeph\">null()</span> member function.\n        </p></div></div><div id=\"udf_malloc\"><div class=\"hue-doc-title\">Memory Allocation for UDFs</div><div><p>\n          By default, memory allocated within a UDF is deallocated when the function exits, which could be before\n          the query is finished. The input arguments remain allocated for the lifetime of the function, so you can\n          refer to them in the expressions for your return values. If you use temporary variables to construct\n          all-new string values, use the <span class=\"hue-doc-codeph\">StringVal()</span> constructor that takes an initial\n          <span class=\"hue-doc-codeph\">FunctionContext*</span> argument followed by a length, and copy the data into the newly\n          allocated memory buffer.\n        </p></div></div><div id=\"udf_threads\"><div class=\"hue-doc-title\">Thread-Safe Work Area for UDFs</div><div><p>\n          One way to improve performance of UDFs is to specify the optional <span class=\"hue-doc-codeph\">PREPARE_FN</span> and\n          <span class=\"hue-doc-codeph\">CLOSE_FN</span> clauses on the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement. The <q>prepare</q>\n          function sets up a thread-safe data structure in memory that you can use as a work area. The <q>close</q>\n          function deallocates that memory. Each subsequent call to the UDF within the same thread can access that\n          same memory area. There might be several such memory areas allocated on the same host, as UDFs are\n          parallelized using multiple threads.\n        </p><p>\n          Within this work area, you can set up predefined lookup tables, or record the results of complex\n          operations on data types such as <span class=\"hue-doc-codeph\">STRING</span> or <span class=\"hue-doc-codeph\">TIMESTAMP</span>. Saving the\n          results of previous computations rather than repeating the computation each time is an optimization known\n          as <a class=\"hue-doc-external-link\" href=\"http://en.wikipedia.org/wiki/Memoization\" target=\"_blank\">http://en.wikipedia.org/wiki/Memoization</a>. For example,\n          if your UDF performs a regular expression match or date manipulation on a column that repeats the same\n          value over and over, you could store the last-computed value or a hash table of already-computed values,\n          and do a fast lookup to find the result for subsequent iterations of the UDF.\n        </p><p>\n          Each such function must have the signature:\n        </p><div class=\"hue-doc-codeblock\">void <span class=\"hue-doc-varname\">function_name</span>(impala_udf::FunctionContext*, impala_udf::FunctionContext::FunctionScope)\n</div><p>\n          Currently, only <span class=\"hue-doc-codeph\">THREAD_SCOPE</span> is implemented, not <span class=\"hue-doc-codeph\">FRAGMENT_SCOPE</span>. See\n          <span class=\"hue-doc-filepath\">udf.h</span> for details about the scope values.\n        </p></div></div><div id=\"udf_error_handling\"><div class=\"hue-doc-title\">Error Handling for UDFs</div><div><p>\n          To handle errors in UDFs, you call functions that are members of the initial\n          <span class=\"hue-doc-codeph\">FunctionContext*</span> argument passed to your function.\n        </p><p>\n          A UDF can record one or more warnings, for conditions that indicate minor, recoverable problems that do\n          not cause the query to stop. The signature for this function is:\n        </p><div class=\"hue-doc-codeblock\">bool AddWarning(const char* warning_msg);</div><p>\n          For a serious problem that requires cancelling the query, a UDF can set an error flag that prevents the\n          query from returning any results. The signature for this function is:\n        </p><div class=\"hue-doc-codeblock\">void SetError(const char* error_msg);</div></div></div></div><div id=\"udafs\"><div class=\"hue-doc-title\">Writing User-Defined Aggregate Functions (UDAFs)</div><div><p>\n        User-defined aggregate functions (UDAFs or UDAs) are a powerful and flexible category of user-defined\n        functions. If a query processes N rows, calling a UDAF during the query condenses the result set, anywhere\n        from a single value (such as with the <span class=\"hue-doc-codeph\">SUM</span> or <span class=\"hue-doc-codeph\">MAX</span> functions), or some\n        number less than or equal to N (as in queries using the <span class=\"hue-doc-codeph\">GROUP BY</span> or\n        <span class=\"hue-doc-codeph\">HAVING</span> clause).\n      </p><p/></div><div id=\"uda_functions\"><div class=\"hue-doc-title\">The Underlying Functions for a UDA</div><div><p>\n          A UDAF must maintain a state value across subsequent calls, so that it can accumulate a result across a\n          set of calls, rather than derive it purely from one set of arguments. For that reason, a UDAF is\n          represented by multiple underlying functions:\n        </p><ul><li>\n            An initialization function that sets any counters to zero, creates empty buffers, and does any other\n            one-time setup for a query.\n          </li><li>\n            An update function that processes the arguments for each row in the query result set and accumulates an\n            intermediate result for each node. For example, this function might increment a counter, append to a\n            string buffer, or set flags.\n          </li><li>\n            A merge function that combines the intermediate results from two different nodes.\n          </li><li>\n            A serialize function that flattens any intermediate values containing pointers, and frees any memory\n            allocated during the init, update, and merge phases.\n          </li><li>\n            A finalize function that either passes through the combined result unchanged, or does one final\n            transformation.\n          </li></ul><p>\n          In the SQL syntax, you create a UDAF by using the statement <span class=\"hue-doc-codeph\">CREATE AGGREGATE FUNCTION</span>.\n          You specify the entry points of the underlying C++ functions using the clauses <span class=\"hue-doc-codeph\">INIT_FN</span>,\n          <span class=\"hue-doc-codeph\">UPDATE_FN</span>, <span class=\"hue-doc-codeph\">MERGE_FN</span>, <span class=\"hue-doc-codeph\">SERIALIZE_FN</span>, and\n          <span class=\"hue-doc-codeph\">FINALIZE_FN</span>.\n        </p><p>\n          For convenience, you can use a naming convention for the underlying functions and Impala automatically\n          recognizes those entry points. Specify the <span class=\"hue-doc-codeph\">UPDATE_FN</span> clause, using an entry point name\n          containing the string <span class=\"hue-doc-codeph\">update</span> or <span class=\"hue-doc-codeph\">Update</span>. When you omit the other\n          <span class=\"hue-doc-codeph\">_FN</span> clauses from the SQL statement, Impala looks for entry points with names formed by\n          substituting the <span class=\"hue-doc-codeph\">update</span> or <span class=\"hue-doc-codeph\">Update</span> portion of the specified name.\n        </p><p>\n    uda-sample.h\n  :\n        </p><p>\n    uda-sample.cc\n  :\n        </p></div></div><div id=\"udf_intermediate\"><div class=\"hue-doc-title\">Intermediate Results for UDAs</div><div><p>\n          A user-defined aggregate function might produce and combine intermediate results during some phases of\n          processing, using a different data type than the final return value. For example, if you implement a\n          function similar to the built-in <span class=\"hue-doc-codeph\">AVG()</span> function, it must keep track of two values, the\n          number of values counted and the sum of those values. Or, you might accumulate a string value over the\n          course of a UDA, then in the end return a numeric or Boolean result.\n        </p><p>\n          In such a case, specify the data type of the intermediate results using the optional <span class=\"hue-doc-codeph\">INTERMEDIATE\n          <span class=\"hue-doc-varname\">type_name</span></span> clause of the <span class=\"hue-doc-codeph\">CREATE AGGREGATE FUNCTION</span> statement.\n          If the intermediate data is a typeless byte array (for example, to represent a C++ struct or array),\n          specify the type name as <span class=\"hue-doc-codeph\">CHAR(<span class=\"hue-doc-varname\">n</span>)</span>, with <span class=\"hue-doc-varname\">n</span>\n          representing the number of bytes in the intermediate result buffer.\n        </p><p>\n          For an example of this technique, see the <span class=\"hue-doc-codeph\">trunc_sum()</span> aggregate function, which accumulates\n          intermediate results of type <span class=\"hue-doc-codeph\">DOUBLE</span> and returns <span class=\"hue-doc-codeph\">BIGINT</span> at the end.\n          View <a class=\"hue-doc-external-link\" href=\"https://github.com/apache/impala/blob/master/tests/query_test/test_udfs.py\" target=\"_blank\">the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement</a>\n          and <a class=\"hue-doc-external-link\" href=\"https://github.com/apache/impala/blob/master/be/src/testutil/test-udas.cc\" target=\"_blank\">the implementation of the underlying TruncSum*() functions</a>\n          on Github.\n        </p></div></div></div><div id=\"udf_building\"><div class=\"hue-doc-title\">Building and Deploying UDFs</div><div><p>\n        This section explains the steps to compile Impala UDFs from C++ source code, and deploy the resulting\n        libraries for use in Impala queries.\n      </p><p>\n        Impala ships with a sample build environment for UDFs, that you can study, experiment with, and adapt for\n        your own use. This sample build environment starts with the <span class=\"hue-doc-cmdname\">cmake</span> configuration command,\n        which reads the file <span class=\"hue-doc-filepath\">CMakeLists.txt</span> and generates a <span class=\"hue-doc-filepath\">Makefile</span>\n        customized for your particular directory paths. Then the <span class=\"hue-doc-cmdname\">make</span> command runs the actual\n        build steps based on the rules in the <span class=\"hue-doc-filepath\">Makefile</span>.\n      </p><p>\n        Impala loads the shared library from an HDFS location. After building a shared library containing one or\n        more UDFs, use <span class=\"hue-doc-codeph\">hdfs dfs</span> or <span class=\"hue-doc-codeph\">hadoop fs</span> commands to copy the binary file to\n        an HDFS location readable by Impala.\n      </p><p>\n        The final step in deployment is to issue a <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement in the\n        <span class=\"hue-doc-cmdname\">impala-shell</span> interpreter to make Impala aware of the new function. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_function.xml\" data-doc-anchor-id=\"create_function\">CREATE FUNCTION Statement</a> for syntax details. Because each function is\n        associated with a particular database, always issue a <span class=\"hue-doc-codeph\">USE</span> statement to the appropriate\n        database before creating a function, or specify a fully qualified name, that is, <span class=\"hue-doc-codeph\">CREATE FUNCTION\n        <span class=\"hue-doc-varname\">db_name</span>.<span class=\"hue-doc-varname\">function_name</span></span>.\n      </p><p>\n        As you update the UDF code and redeploy updated versions of a shared library, use <span class=\"hue-doc-codeph\">DROP\n        FUNCTION</span> and <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> to let Impala pick up the latest version of the\n        code.\n      </p><div class=\"hue-doc-note\"><p id=\"udf_persistence_restriction\">\n        In Impala 2.5 and higher, Impala UDFs and UDAs written in C++ are persisted in the metastore database.\n        Java UDFs are also persisted, if they were created with the new <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax for Java UDFs,\n        where the Java function argument and return types are omitted.\n        Java-based UDFs created with the old <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax do not persist across restarts\n        because they are held in the memory of the <span class=\"hue-doc-cmdname\">catalogd</span> daemon.\n        Until you re-create such Java UDFs using the new <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax,\n        you must reload those Java-based UDFs by running the original <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statements again each time\n        you restart the <span class=\"hue-doc-cmdname\">catalogd</span> daemon.\n        Prior to Impala 2.5 the requirement to reload functions after a restart applied to both C++ and Java functions.\n      </p><p>\n          See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_function.xml\" data-doc-anchor-id=\"create_function\">CREATE FUNCTION Statement</a> and <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_drop_function.xml\" data-doc-anchor-id=\"drop_function\">DROP FUNCTION Statement</a>\n          for the new syntax for the persistent Java UDFs.\n        </p></div><p>\n        Prerequisites for the build environment are:\n      </p><div class=\"hue-doc-codeblock\"># Use the appropriate package installation command for your Linux distribution.\nsudo yum install gcc-c++ cmake boost-devel\nsudo yum install impala-udf-devel\n# The package name on Ubuntu and Debian is impala-udf-dev.\n</div><p>\n        Then, unpack the sample code in <span class=\"hue-doc-filepath\">udf_samples.tar.gz</span> and use that as a template to set\n        up your build environment.\n      </p><p>\n        To build the original samples:\n      </p><div class=\"hue-doc-codeblock\"># Process CMakeLists.txt and set up appropriate Makefiles.\ncmake .\n# Generate shared libraries from UDF and UDAF sample code,\n# udf_samples/libudfsample.so and udf_samples/libudasample.so\nmake</div><p>\n        The sample code to examine, experiment with, and adapt is in these files:\n      </p><ul><li><span class=\"hue-doc-filepath\">udf-sample.h</span>: Header file that declares the signature for a scalar UDF\n          (<span class=\"hue-doc-codeph\">AddUDF</span>).\n        </li><li><span class=\"hue-doc-filepath\">udf-sample.cc</span>: Sample source for a simple UDF that adds two integers. Because\n          Impala can reference multiple function entry points from the same shared library, you could add other UDF\n          functions in this file and add their signatures to the corresponding header file.\n        </li><li><span class=\"hue-doc-filepath\">udf-sample-test.cc</span>: Basic unit tests for the sample UDF.\n        </li><li><span class=\"hue-doc-filepath\">uda-sample.h</span>: Header file that declares the signature for sample aggregate\n          functions. The SQL functions will be called <span class=\"hue-doc-codeph\">COUNT</span>, <span class=\"hue-doc-codeph\">AVG</span>, and\n          <span class=\"hue-doc-codeph\">STRINGCONCAT</span>. Because aggregate functions require more elaborate coding to handle the\n          processing for multiple phases, there are several underlying C++ functions such as\n          <span class=\"hue-doc-codeph\">CountInit</span>, <span class=\"hue-doc-codeph\">AvgUpdate</span>, and <span class=\"hue-doc-codeph\">StringConcatFinalize</span>.\n        </li><li><span class=\"hue-doc-filepath\">uda-sample.cc</span>: Sample source for simple UDAFs that demonstrate how to manage the\n          state transitions as the underlying functions are called during the different phases of query processing.\n          <ul><li>\n              The UDAF that imitates the <span class=\"hue-doc-codeph\">COUNT</span> function keeps track of a single incrementing\n              number; the merge functions combine the intermediate count values from each Impala node, and the\n              combined number is returned verbatim by the finalize function.\n            </li><li>\n              The UDAF that imitates the <span class=\"hue-doc-codeph\">AVG</span> function keeps track of two numbers, a count of rows\n              processed and the sum of values for a column. These numbers are updated and merged as with\n              <span class=\"hue-doc-codeph\">COUNT</span>, then the finalize function divides them to produce and return the final\n              average value.\n            </li><li>\n              The UDAF that concatenates string values into a comma-separated list demonstrates how to manage\n              storage for a string that increases in length as the function is called for multiple rows.\n            </li></ul></li><li><span class=\"hue-doc-filepath\">uda-sample-test.cc</span>: basic unit tests for the sample UDAFs.\n        </li></ul></div></div><div id=\"udf_performance\"><div class=\"hue-doc-title\">Performance Considerations for UDFs</div><div><p>\n        Because a UDF typically processes each row of a table, potentially being called billions of times, the\n        performance of each UDF is a critical factor in the speed of the overall ETL or ELT pipeline. Tiny\n        optimizations you can make within the function body can pay off in a big way when the function is called\n        over and over when processing a huge result set.\n      </p></div></div><div id=\"udf_tutorial\"><div class=\"hue-doc-title\">Examples of Creating and Using UDFs</div><div><p>\n        This section demonstrates how to create and use all kinds of user-defined functions (UDFs).\n      </p><div class=\"hue-doc-example\" id=\"udf_sample_udf\"><div class=\"hue-doc-title\">Sample C++ UDFs: HasVowels, CountVowels, StripVowels</div><p>\n          This example shows 3 separate UDFs that operate on strings and return different data types. In the C++\n          code, the functions are <span class=\"hue-doc-codeph\">HasVowels()</span> (checks if a string contains any vowels),\n          <span class=\"hue-doc-codeph\">CountVowels()</span> (returns the number of vowels in a string), and\n          <span class=\"hue-doc-codeph\">StripVowels()</span> (returns a new string with vowels removed).\n        </p><p>\n          First, we add the signatures for these functions to <span class=\"hue-doc-filepath\">udf-sample.h</span> in the demo build\n          environment:\n        </p><div class=\"hue-doc-codeblock\">BooleanVal HasVowels(FunctionContext* context, const StringVal&amp; input);\nIntVal CountVowels(FunctionContext* context, const StringVal&amp; arg1);\nStringVal StripVowels(FunctionContext* context, const StringVal&amp; arg1);</div><p>\n          Then, we add the bodies of these functions to <span class=\"hue-doc-filepath\">udf-sample.cc</span>:\n        </p><div class=\"hue-doc-codeblock\">BooleanVal HasVowels(FunctionContext* context, const StringVal&amp; input)\n{\n        if (input.is_null) return BooleanVal::null();\n\n        int index;\n        uint8_t *ptr;\n\n        for (ptr = input.ptr, index = 0; index &lt;= input.len; index++, ptr++)\n        {\n                uint8_t c = tolower(*ptr);\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n                {\n                        return BooleanVal(true);\n                }\n        }\n        return BooleanVal(false);\n}\n\nIntVal CountVowels(FunctionContext* context, const StringVal&amp; arg1)\n{\n        if (arg1.is_null) return IntVal::null();\n\n        int count;\n        int index;\n        uint8_t *ptr;\n\n        for (ptr = arg1.ptr, count = 0, index = 0; index &lt;= arg1.len; index++, ptr++)\n        {\n                uint8_t c = tolower(*ptr);\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n                {\n                        count++;\n                }\n        }\n        return IntVal(count);\n}\n\nStringVal StripVowels(FunctionContext* context, const StringVal&amp; arg1)\n{\n        if (arg1.is_null) return StringVal::null();\n\n        int index;\n        std::string original((const char *)arg1.ptr,arg1.len);\n        std::string shorter(\"\");\n\n        for (index = 0; index &lt; original.length(); index++)\n        {\n                uint8_t c = original[index];\n                uint8_t l = tolower(c);\n\n                if (l == 'a' || l == 'e' || l == 'i' || l == 'o' || l == 'u')\n                {\n                        ;\n                }\n                else\n                {\n                    shorter.append(1, (char)c);\n                }\n        }\n// The modified string is stored in 'shorter', which is destroyed when this function ends. We need to make a string val\n// and copy the contents.\n        StringVal result(context, shorter.size()); // Only the version of the ctor that takes a context object allocates new memory\n        memcpy(result.ptr, shorter.c_str(), shorter.size());\n        return result;\n}</div><p>\n          We build a shared library, <span class=\"hue-doc-filepath\">libudfsample.so</span>, and put the library file into HDFS\n          where Impala can read it:\n        </p><div class=\"hue-doc-codeblock\">$ make\n[  0%] Generating udf_samples/uda-sample.ll\n[ 16%] Built target uda-sample-ir\n[ 33%] Built target udasample\n[ 50%] Built target uda-sample-test\n[ 50%] Generating udf_samples/udf-sample.ll\n[ 66%] Built target udf-sample-ir\nScanning dependencies of target udfsample\n[ 83%] Building CXX object CMakeFiles/udfsample.dir/udf-sample.o\nLinking CXX shared library udf_samples/libudfsample.so\n[ 83%] Built target udfsample\nLinking CXX executable udf_samples/udf-sample-test\n[100%] Built target udf-sample-test\n$ hdfs dfs -put ./udf_samples/libudfsample.so /user/hive/udfs/libudfsample.so</div><p>\n          Finally, we go into the <span class=\"hue-doc-cmdname\">impala-shell</span> interpreter where we set up some sample data,\n          issue <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statements to set up the SQL function names, and call the\n          functions in some queries:\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create database udf_testing;\n[localhost:21000] &gt; use udf_testing;\n\n[localhost:21000] &gt; create function has_vowels (string) returns boolean location '/user/hive/udfs/libudfsample.so' symbol='HasVowels';\n[localhost:21000] &gt; select has_vowels('abc');\n+------------------------+\n| udfs.has_vowels('abc') |\n+------------------------+\n| true                   |\n+------------------------+\nReturned 1 row(s) in 0.13s\n[localhost:21000] &gt; select has_vowels('zxcvbnm');\n+----------------------------+\n| udfs.has_vowels('zxcvbnm') |\n+----------------------------+\n| false                      |\n+----------------------------+\nReturned 1 row(s) in 0.12s\n[localhost:21000] &gt; select has_vowels(null);\n+-----------------------+\n| udfs.has_vowels(null) |\n+-----------------------+\n| NULL                  |\n+-----------------------+\nReturned 1 row(s) in 0.11s\n[localhost:21000] &gt; select s, has_vowels(s) from t2;\n+-----------+--------------------+\n| s         | udfs.has_vowels(s) |\n+-----------+--------------------+\n| lower     | true               |\n| UPPER     | true               |\n| Init cap  | true               |\n| CamelCase | true               |\n+-----------+--------------------+\nReturned 4 row(s) in 0.24s\n\n[localhost:21000] &gt; create function count_vowels (string) returns int location '/user/hive/udfs/libudfsample.so' symbol='CountVowels';\n[localhost:21000] &gt; select count_vowels('cat in the hat');\n+-------------------------------------+\n| udfs.count_vowels('cat in the hat') |\n+-------------------------------------+\n| 4                                   |\n+-------------------------------------+\nReturned 1 row(s) in 0.12s\n[localhost:21000] &gt; select s, count_vowels(s) from t2;\n+-----------+----------------------+\n| s         | udfs.count_vowels(s) |\n+-----------+----------------------+\n| lower     | 2                    |\n| UPPER     | 2                    |\n| Init cap  | 3                    |\n| CamelCase | 4                    |\n+-----------+----------------------+\nReturned 4 row(s) in 0.23s\n[localhost:21000] &gt; select count_vowels(null);\n+-------------------------+\n| udfs.count_vowels(null) |\n+-------------------------+\n| NULL                    |\n+-------------------------+\nReturned 1 row(s) in 0.12s\n\n[localhost:21000] &gt; create function strip_vowels (string) returns string location '/user/hive/udfs/libudfsample.so' symbol='StripVowels';\n[localhost:21000] &gt; select strip_vowels('abcdefg');\n+------------------------------+\n| udfs.strip_vowels('abcdefg') |\n+------------------------------+\n| bcdfg                        |\n+------------------------------+\nReturned 1 row(s) in 0.11s\n[localhost:21000] &gt; select strip_vowels('ABCDEFG');\n+------------------------------+\n| udfs.strip_vowels('abcdefg') |\n+------------------------------+\n| BCDFG                        |\n+------------------------------+\nReturned 1 row(s) in 0.12s\n[localhost:21000] &gt; select strip_vowels(null);\n+-------------------------+\n| udfs.strip_vowels(null) |\n+-------------------------+\n| NULL                    |\n+-------------------------+\nReturned 1 row(s) in 0.16s\n[localhost:21000] &gt; select s, strip_vowels(s) from t2;\n+-----------+----------------------+\n| s         | udfs.strip_vowels(s) |\n+-----------+----------------------+\n| lower     | lwr                  |\n| UPPER     | PPR                  |\n| Init cap  | nt cp                |\n| CamelCase | CmlCs                |\n+-----------+----------------------+\nReturned 4 row(s) in 0.24s</div></div><div class=\"hue-doc-example\" id=\"udf_sample_uda\"><div class=\"hue-doc-title\">Sample C++ UDA: SumOfSquares</div><p>\n          This example demonstrates a user-defined aggregate function (UDA) that produces the sum of the squares of\n          its input values.\n        </p><p>\n          The coding for a UDA is a little more involved than a scalar UDF, because the processing is split into\n          several phases, each implemented by a different function. Each phase is relatively straightforward: the\n          <q>update</q> and <q>merge</q> phases, where most of the work is done, read an input value and combine it\n          with some accumulated intermediate value.\n        </p><p>\n          As in our sample UDF from the previous example, we add function signatures to a header file (in this\n          case, <span class=\"hue-doc-filepath\">uda-sample.h</span>). Because this is a math-oriented UDA, we make two versions of\n          each function, one accepting an integer value and the other accepting a floating-point value.\n        </p><div class=\"hue-doc-codeblock\">void SumOfSquaresInit(FunctionContext* context, BigIntVal* val);\nvoid SumOfSquaresInit(FunctionContext* context, DoubleVal* val);\n\nvoid SumOfSquaresUpdate(FunctionContext* context, const BigIntVal&amp; input, BigIntVal* val);\nvoid SumOfSquaresUpdate(FunctionContext* context, const DoubleVal&amp; input, DoubleVal* val);\n\nvoid SumOfSquaresMerge(FunctionContext* context, const BigIntVal&amp; src, BigIntVal* dst);\nvoid SumOfSquaresMerge(FunctionContext* context, const DoubleVal&amp; src, DoubleVal* dst);\n\nBigIntVal SumOfSquaresFinalize(FunctionContext* context, const BigIntVal&amp; val);\nDoubleVal SumOfSquaresFinalize(FunctionContext* context, const DoubleVal&amp; val);</div><p>\n          We add the function bodies to a C++ source file (in this case, <span class=\"hue-doc-filepath\">uda-sample.cc</span>):\n        </p><div class=\"hue-doc-codeblock\">void SumOfSquaresInit(FunctionContext* context, BigIntVal* val) {\n  val-&gt;is_null = false;\n  val-&gt;val = 0;\n}\nvoid SumOfSquaresInit(FunctionContext* context, DoubleVal* val) {\n  val-&gt;is_null = false;\n  val-&gt;val = 0.0;\n}\n\nvoid SumOfSquaresUpdate(FunctionContext* context, const BigIntVal&amp; input, BigIntVal* val) {\n  if (input.is_null) return;\n  val-&gt;val += input.val * input.val;\n}\nvoid SumOfSquaresUpdate(FunctionContext* context, const DoubleVal&amp; input, DoubleVal* val) {\n  if (input.is_null) return;\n  val-&gt;val += input.val * input.val;\n}\n\nvoid SumOfSquaresMerge(FunctionContext* context, const BigIntVal&amp; src, BigIntVal* dst) {\n  dst-&gt;val += src.val;\n}\nvoid SumOfSquaresMerge(FunctionContext* context, const DoubleVal&amp; src, DoubleVal* dst) {\n  dst-&gt;val += src.val;\n}\n\nBigIntVal SumOfSquaresFinalize(FunctionContext* context, const BigIntVal&amp; val) {\n  return val;\n}\nDoubleVal SumOfSquaresFinalize(FunctionContext* context, const DoubleVal&amp; val) {\n  return val;\n}</div><p>\n          As with the sample UDF, we build a shared library and put it into HDFS:\n        </p><div class=\"hue-doc-codeblock\">$ make\n[  0%] Generating udf_samples/uda-sample.ll\n[ 16%] Built target uda-sample-ir\nScanning dependencies of target udasample\n[ 33%] Building CXX object CMakeFiles/udasample.dir/uda-sample.o\nLinking CXX shared library udf_samples/libudasample.so\n[ 33%] Built target udasample\nScanning dependencies of target uda-sample-test\n[ 50%] Building CXX object CMakeFiles/uda-sample-test.dir/uda-sample-test.o\nLinking CXX executable udf_samples/uda-sample-test\n[ 50%] Built target uda-sample-test\n[ 50%] Generating udf_samples/udf-sample.ll\n[ 66%] Built target udf-sample-ir\n[ 83%] Built target udfsample\n[100%] Built target udf-sample-test\n$ hdfs dfs -put ./udf_samples/libudasample.so /user/hive/udfs/libudasample.so</div><p>\n          To create the SQL function, we issue a <span class=\"hue-doc-codeph\">CREATE AGGREGATE FUNCTION</span> statement and specify\n          the underlying C++ function names for the different phases:\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; use udf_testing;\n\n[localhost:21000] &gt; create table sos (x bigint, y double);\n[localhost:21000] &gt; insert into sos values (1, 1.1), (2, 2.2), (3, 3.3), (4, 4.4);\nInserted 4 rows in 1.10s\n\n[localhost:21000] &gt; create aggregate function sum_of_squares(bigint) returns bigint\n  &gt; location '/user/hive/udfs/libudasample.so'\n  &gt; init_fn='SumOfSquaresInit'\n  &gt; update_fn='SumOfSquaresUpdate'\n  &gt; merge_fn='SumOfSquaresMerge'\n  &gt; finalize_fn='SumOfSquaresFinalize';\n\n[localhost:21000] &gt; -- Compute the same value using literals or the UDA;\n[localhost:21000] &gt; select 1*1 + 2*2 + 3*3 + 4*4;\n+-------------------------------+\n| 1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 |\n+-------------------------------+\n| 30                            |\n+-------------------------------+\nReturned 1 row(s) in 0.12s\n[localhost:21000] &gt; select sum_of_squares(x) from sos;\n+------------------------+\n| udfs.sum_of_squares(x) |\n+------------------------+\n| 30                     |\n+------------------------+\nReturned 1 row(s) in 0.35s</div><p>\n          Until we create the overloaded version of the UDA, it can only handle a single data type. To allow it to\n          handle <span class=\"hue-doc-codeph\">DOUBLE</span> as well as <span class=\"hue-doc-codeph\">BIGINT</span>, we issue another <span class=\"hue-doc-codeph\">CREATE\n          AGGREGATE FUNCTION</span> statement:\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select sum_of_squares(y) from sos;\nERROR: AnalysisException: No matching function with signature: udfs.sum_of_squares(DOUBLE).\n\n[localhost:21000] &gt; create aggregate function sum_of_squares(double) returns double\n  &gt; location '/user/hive/udfs/libudasample.so'\n  &gt; init_fn='SumOfSquaresInit'\n  &gt; update_fn='SumOfSquaresUpdate'\n  &gt; merge_fn='SumOfSquaresMerge'\n  &gt; finalize_fn='SumOfSquaresFinalize';\n\n[localhost:21000] &gt; -- Compute the same value using literals or the UDA;\n[localhost:21000] &gt; select 1.1*1.1 + 2.2*2.2 + 3.3*3.3 + 4.4*4.4;\n+-----------------------------------------------+\n| 1.1 * 1.1 + 2.2 * 2.2 + 3.3 * 3.3 + 4.4 * 4.4 |\n+-----------------------------------------------+\n| 36.3                                          |\n+-----------------------------------------------+\nReturned 1 row(s) in 0.12s\n[localhost:21000] &gt; select sum_of_squares(y) from sos;\n+------------------------+\n| udfs.sum_of_squares(y) |\n+------------------------+\n| 36.3                   |\n+------------------------+\nReturned 1 row(s) in 0.35s</div><p>\n          Typically, you use a UDA in queries with <span class=\"hue-doc-codeph\">GROUP BY</span> clauses, to produce a result set with\n          a separate aggregate value for each combination of values from the <span class=\"hue-doc-codeph\">GROUP BY</span> clause.\n          Let's change our sample table to use <span class=\"hue-doc-codeph\">0</span> to indicate rows containing even values, and\n          <span class=\"hue-doc-codeph\">1</span> to flag rows containing odd values. Then the <span class=\"hue-doc-codeph\">GROUP BY</span> query can\n          return two values, the sum of the squares for the even values, and the sum of the squares for the odd\n          values:\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; insert overwrite sos values (1, 1), (2, 0), (3, 1), (4, 0);\nInserted 4 rows in 1.24s\n\n[localhost:21000] &gt; -- Compute 1 squared + 3 squared, and 2 squared + 4 squared;\n[localhost:21000] &gt; select y, sum_of_squares(x) from sos group by y;\n+---+------------------------+\n| y | udfs.sum_of_squares(x) |\n+---+------------------------+\n| 1 | 10                     |\n| 0 | 20                     |\n+---+------------------------+\nReturned 2 row(s) in 0.43s</div></div></div></div><div id=\"udf_security\"><div class=\"hue-doc-title\">Security Considerations for User-Defined Functions</div><div><p>\n        When the Impala authorization feature is enabled:\n      </p><ul><li>\n          To call a UDF in a query, you must have the required read privilege for any databases and tables used in\n          the query.\n        </li><li>\n          Because incorrectly coded UDFs could cause performance or capacity problems, for example by going into\n          infinite loops or allocating excessive amounts of memory, only an administrative user can create UDFs.\n          That is, to execute the <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> statement requires the <span class=\"hue-doc-codeph\">ALL</span>\n          privilege on the server.\n        </li></ul><p>\n        See <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_authorization.html#authorization\" target=\"_blank\">Enabling Sentry Authorization for Impala</a> for details about authorization in Impala.\n      </p></div></div><div id=\"udf_limits\"><div class=\"hue-doc-title\">Limitations and Restrictions for Impala UDFs</div><div><p>\n        The following limitations and restrictions apply to Impala UDFs in the current release:\n      </p><ul><li>\n          Impala does not support Hive UDFs that accept or return composite or nested types, or other types not\n          available in Impala tables.\n        </li><li><p id=\"current_user_caveat\">\n        The Hive <span class=\"hue-doc-codeph\">current_user()</span> function cannot be\n        called from a Java UDF through Impala.\n      </p></li><li>\n          All Impala UDFs must be deterministic, that is, produce the same output each time when passed the same\n          argument values. For example, an Impala UDF must not call functions such as <span class=\"hue-doc-codeph\">rand()</span> to\n          produce different values for each invocation. It must not retrieve data from external sources, such as\n          from disk or over the network.\n        </li><li>\n          An Impala UDF must not spawn other threads or processes.\n        </li><li>\n          Prior to Impala 2.5 when the <span class=\"hue-doc-cmdname\">catalogd</span> process is restarted,\n          all UDFs become undefined and must be reloaded. In Impala 2.5 and higher, this\n          limitation only applies to older Java UDFs. Re-create those UDFs using the new\n          <span class=\"hue-doc-codeph\">CREATE FUNCTION</span> syntax for Java UDFs, which excludes the function signature,\n          to remove the limitation entirely.\n        </li><li>\n          Impala currently does not support user-defined table functions (UDTFs).\n        </li><li>\n          The <span class=\"hue-doc-codeph\">CHAR</span> and <span class=\"hue-doc-codeph\">VARCHAR</span> types cannot be used as input arguments or return\n          values for UDFs.\n        </li></ul></div></div></div></div>","title":"Impala User-Defined Functions (UDFs)"}