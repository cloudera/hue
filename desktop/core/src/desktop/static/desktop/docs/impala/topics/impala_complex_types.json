{"body":"<div><div id=\"complex_types\"><div class=\"hue-doc-title\" id=\"nested_types\">Complex Types (Impala 2.3 or higher only)</div><div><p><span class=\"hue-doc-term\">Complex types</span> (also referred to as <span class=\"hue-doc-term\">nested types</span>) let you represent multiple data values within a single\n      row/column position. They differ from the familiar column types such as <span class=\"hue-doc-codeph\">BIGINT</span> and <span class=\"hue-doc-codeph\">STRING</span>, known as\n      <span class=\"hue-doc-term\">scalar types</span> or <span class=\"hue-doc-term\">primitive types</span>, which represent a single data value within a given row/column position.\n      Impala supports the complex types <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">MAP</span>, and <span class=\"hue-doc-codeph\">STRUCT</span> in Impala 2.3\n      and higher. The Hive <span class=\"hue-doc-codeph\">UNION</span> type is not currently supported.\n    </p><p/><p>\n      Once you understand the basics of complex types, refer to the individual type topics when you need to refresh your memory about syntax\n      and examples:\n    </p><ul><li><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_array.xml\" data-doc-anchor-id=\"array\">ARRAY Complex Type (Impala 2.3 or higher only)</a></li><li><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_struct.xml\" data-doc-anchor-id=\"struct\">STRUCT Complex Type (Impala 2.3 or higher only)</a></li><li><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_map.xml\" data-doc-anchor-id=\"map\">MAP Complex Type (Impala 2.3 or higher only)</a></li></ul></div><div id=\"complex_types_benefits\"><div class=\"hue-doc-title\">Benefits of Impala Complex Types</div><div><p>\n        The reasons for using Impala complex types include the following:\n      </p><ul><li><p>\n            You already have data produced by Hive or other non-Impala component that uses the complex type column names. You might need to\n            convert the underlying data to Parquet to use it with Impala.\n          </p></li><li><p>\n            Your data model originates with a non-SQL programming language or a NoSQL data management system. For example, if you are\n            representing Python data expressed as nested lists, dictionaries, and tuples, those data structures correspond closely to Impala\n            <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">MAP</span>, and <span class=\"hue-doc-codeph\">STRUCT</span> types.\n          </p></li><li><p>\n            Your analytic queries involving multiple tables could benefit from greater locality during join processing. By packing more\n            related data items within each HDFS data block, complex types let join queries avoid the network overhead of the traditional\n            Hadoop shuffle or broadcast join techniques.\n          </p></li></ul><p>\n        The Impala complex type support produces result sets with all scalar values, and the scalar components of complex types can be used\n        with all SQL clauses, such as <span class=\"hue-doc-codeph\">GROUP BY</span>, <span class=\"hue-doc-codeph\">ORDER BY</span>, all kinds of joins, subqueries, and inline\n        views. The ability to process complex type data entirely in SQL reduces the need to write application-specific code in Java or other\n        programming languages to deconstruct the underlying data structures.\n      </p></div></div><div id=\"complex_types_overview\"><div class=\"hue-doc-title\">Overview of Impala Complex Types</div><div><p>\n        The <span class=\"hue-doc-codeph\">ARRAY</span> and <span class=\"hue-doc-codeph\">MAP</span> types are closely related: they represent collections with arbitrary numbers of\n        elements, where each element is the same type. In contrast, <span class=\"hue-doc-codeph\">STRUCT</span> groups together a fixed number of items into a\n        single element. The parts of a <span class=\"hue-doc-codeph\">STRUCT</span> element (the <span class=\"hue-doc-term\">fields</span>) can be of different types, and each field\n        has a name.\n      </p><p>\n        The elements of an <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span>, or the fields of a <span class=\"hue-doc-codeph\">STRUCT</span>, can also be other\n        complex types. You can construct elaborate data structures with up to 100 levels of nesting. For example, you can make an\n        <span class=\"hue-doc-codeph\">ARRAY</span> whose elements are <span class=\"hue-doc-codeph\">STRUCT</span>s. Within each <span class=\"hue-doc-codeph\">STRUCT</span>, you can have some fields\n        that are <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">MAP</span>, or another kind of <span class=\"hue-doc-codeph\">STRUCT</span>. The Impala documentation uses the\n        terms complex and nested types interchangeably; for simplicity, it primarily uses the term complex types, to encompass all the\n        properties of these types.\n      </p><p>\n        When visualizing your data model in familiar SQL terms, you can think of each <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span> as a\n        miniature table, and each <span class=\"hue-doc-codeph\">STRUCT</span> as a row within such a table. By default, the table represented by an\n        <span class=\"hue-doc-codeph\">ARRAY</span> has two columns, <span class=\"hue-doc-codeph\">POS</span> to represent ordering of elements, and <span class=\"hue-doc-codeph\">ITEM</span>\n        representing the value of each element. Likewise, by default, the table represented by a <span class=\"hue-doc-codeph\">MAP</span> encodes key-value\n        pairs, and therefore has two columns, <span class=\"hue-doc-codeph\">KEY</span> and <span class=\"hue-doc-codeph\">VALUE</span>.\n</p><p>\n        The <span class=\"hue-doc-codeph\">ITEM</span> and <span class=\"hue-doc-codeph\">VALUE</span> names are only required for the very simplest kinds of <span class=\"hue-doc-codeph\">ARRAY</span>\n        and <span class=\"hue-doc-codeph\">MAP</span> columns, ones that hold only scalar values. When the elements within the <span class=\"hue-doc-codeph\">ARRAY</span> or\n        <span class=\"hue-doc-codeph\">MAP</span> are of type <span class=\"hue-doc-codeph\">STRUCT</span> rather than a scalar type, then the result set contains columns with names\n        corresponding to the <span class=\"hue-doc-codeph\">STRUCT</span> fields rather than <span class=\"hue-doc-codeph\">ITEM</span> or <span class=\"hue-doc-codeph\">VALUE</span>.\n      </p><p>\n        You write most queries that process complex type columns using familiar join syntax, even though the data for both sides of the join\n        resides in a single table. The join notation brings together the scalar values from a row with the values from the complex type\n        columns for that same row. The final result set contains all scalar values, allowing you to do all the familiar filtering,\n        aggregation, ordering, and so on for the complex data entirely in SQL or using business intelligence tools that issue SQL queries.\n</p><p>\n        Behind the scenes, Impala ensures that the processing for each row is done efficiently on a single host, without the network traffic\n        involved in broadcast or shuffle joins. The most common type of join query for tables with complex type columns is <span class=\"hue-doc-codeph\">INNER\n        JOIN</span>, which returns results only in those cases where the complex type contains some elements. Therefore, most query\n        examples in this section use either the <span class=\"hue-doc-codeph\">INNER JOIN</span> clause or the equivalent comma notation.\n      </p><div class=\"hue-doc-note\"><p>\n          Although Impala can query complex types that are present in Parquet files, Impala currently cannot create new Parquet files\n          containing complex types. Therefore, the discussion and examples presume that you are working with existing Parquet data produced\n          through Hive, Spark, or some other source. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types_ex_hive_etl\">Constructing Parquet Files with Complex Columns Using Hive</a> for examples of constructing Parquet data\n          files with complex type columns.\n        </p><p>\n          For learning purposes, you can create empty tables with complex type columns and practice query syntax, even if you do not have\n          sample data with the required structure.\n        </p></div></div></div><div id=\"complex_types_design\"><div class=\"hue-doc-title\">Design Considerations for Complex Types</div><div><p>\n        When planning to use Impala complex types, and designing the Impala schema, first learn how this kind of schema differs from\n        traditional table layouts from the relational database and data warehousing fields. Because you might have already encountered\n        complex types in a Hadoop context while using Hive for ETL, also learn how to write high-performance analytic queries for complex\n        type data using Impala SQL syntax.\n      </p><p/></div><div id=\"complex_types_vs_rdbms\"><div class=\"hue-doc-title\">How Complex Types Differ from Traditional Data Warehouse Schemas</div><div><p>\n          Complex types let you associate arbitrary data structures with a particular row. If you are familiar with schema design for\n          relational database management systems or data warehouses, a schema with complex types has the following differences:\n        </p><ul><li><p>\n              Logically, related values can now be grouped tightly together in the same table.\n            </p><p>\n              In traditional data warehousing, related values were typically arranged in one of two ways:\n            </p><ul><li><p>\n                  Split across multiple normalized tables. Foreign key columns specified which rows from each table were associated with\n                  each other. This arrangement avoided duplicate data and therefore the data was compact, but join queries could be\n                  expensive because the related data had to be retrieved from separate locations. (In the case of distributed Hadoop\n                  queries, the joined tables might even be transmitted between different hosts in a cluster.)\n                </p></li><li><p>\n                  Flattened into a single denormalized table. Although this layout eliminated some potential performance issues by removing\n                  the need for join queries, the table typically became larger because values were repeated. The extra data volume could\n                  cause performance issues in other parts of the workflow, such as longer ETL cycles or more expensive full-table scans\n                  during queries.\n                </p></li></ul><p>\n              Complex types represent a middle ground that addresses these performance and volume concerns. By physically locating related\n              data within the same data files, complex types increase locality and reduce the expense of join queries. By associating an\n              arbitrary amount of data with a single row, complex types avoid the need to repeat lengthy values such as strings. Because\n              Impala knows which complex type values are associated with each row, you can save storage by avoiding artificial foreign key\n              values that are only used for joins. The flexibility of the <span class=\"hue-doc-codeph\">STRUCT</span>, <span class=\"hue-doc-codeph\">ARRAY</span>, and\n              <span class=\"hue-doc-codeph\">MAP</span> types lets you model familiar constructs such as fact and dimension tables from a data warehouse, and\n              wide tables representing sparse matrixes.\n            </p></li></ul></div></div><div id=\"complex_types_physical\"><div class=\"hue-doc-title\">Physical Storage for Complex Types</div><div><p>\n          Physically, the scalar and complex columns in each row are located adjacent to each other in the same Parquet data file, ensuring\n          that they are processed on the same host rather than being broadcast across the network when cross-referenced within a query. This\n          co-location simplifies the process of copying, converting, and backing all the columns up at once. Because of the column-oriented\n          layout of Parquet files, you can still query only the scalar columns of a table without imposing the I/O penalty of reading the\n          (possibly large) values of the composite columns.\n        </p><p>\n          Within each Parquet data file, the constituent parts of complex type columns are stored in column-oriented format:\n        </p><ul><li><p>\n              Each field of a <span class=\"hue-doc-codeph\">STRUCT</span> type is stored like a column, with all the scalar values adjacent to each other and\n              encoded, compressed, and so on using the Parquet space-saving techniques.\n            </p></li><li><p>\n              For an <span class=\"hue-doc-codeph\">ARRAY</span> containing scalar values, all those values (represented by the <span class=\"hue-doc-codeph\">ITEM</span>\n              pseudocolumn) are stored adjacent to each other.\n            </p></li><li><p>\n              For a <span class=\"hue-doc-codeph\">MAP</span>, the values of the <span class=\"hue-doc-codeph\">KEY</span> pseudocolumn are stored adjacent to each other. If the\n              <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn is a scalar type, its values are also stored adjacent to each other.\n            </p></li><li><p>\n              If an <span class=\"hue-doc-codeph\">ARRAY</span> element, <span class=\"hue-doc-codeph\">STRUCT</span> field, or <span class=\"hue-doc-codeph\">MAP</span><span class=\"hue-doc-codeph\">VALUE</span> part is\n              another complex type, the column-oriented storage applies to the next level down (or the next level after that, and so on for\n              deeply nested types) where the final elements, fields, or values are of scalar types.\n            </p></li></ul><p>\n          The numbers represented by the <span class=\"hue-doc-codeph\">POS</span> pseudocolumn of an <span class=\"hue-doc-codeph\">ARRAY</span> are not physically stored in the\n          data files. They are synthesized at query time based on the order of the <span class=\"hue-doc-codeph\">ARRAY</span> elements associated with each row.\n        </p></div></div><div id=\"complex_types_file_formats\"><div class=\"hue-doc-title\">File Format Support for Impala Complex Types</div><div><p>\n          Currently, Impala queries support complex type data only in the Parquet file format. See <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_parquet.html#parquet\" target=\"_blank\">Using the Parquet File Format with Impala Tables</a>\n          for details about the performance benefits and physical layout of this file format.\n        </p><p>\n          Because Impala does not parse the data structures containing nested types for unsupported formats such as text, Avro,\n          SequenceFile, or RCFile, you cannot use data files in these formats with Impala, even if the query does not refer to the nested\n          type columns. Also, if a table using an unsupported format originally contained nested type columns, and then those columns were\n          dropped from the table using <span class=\"hue-doc-codeph\">ALTER TABLE ... DROP COLUMN</span>, any existing data files in the table still contain the\n          nested type data and Impala queries on that table will generate errors.\n        </p><p>\n            The one exception to the preceding rule is <span class=\"hue-doc-codeph\">COUNT(*)</span> queries on RCFile tables that include complex types.\n            Such queries are allowed in Impala 2.6 and higher.\n        </p><p>\n          You can perform DDL operations for tables involving complex types in\n          most file formats other than Parquet. You cannot create tables in\n          Impala with complex types using text files.\n        </p><p>\n          You can have a partitioned table with complex type columns that uses\n          a non-Parquet format, and use <span class=\"hue-doc-codeph\">ALTER TABLE</span> to change\n          the file format to Parquet for individual partitions. When you put\n          Parquet data files into those partitions, Impala can execute queries\n          against that data as long as the query does not involve any of the\n          non-Parquet partitions.\n        </p><p>\n          If you use the <span class=\"hue-doc-cmdname\">parquet-tools</span> command to examine the structure of a Parquet data file that includes complex\n          types, you see that both <span class=\"hue-doc-codeph\">ARRAY</span> and <span class=\"hue-doc-codeph\">MAP</span> are represented as a <span class=\"hue-doc-codeph\">Bag</span> in Parquet\n          terminology, with all fields marked <span class=\"hue-doc-codeph\">Optional</span> because Impala allows any column to be nullable.\n        </p><p>\n          Impala supports either 2-level and 3-level encoding within each Parquet data file. When constructing Parquet data files outside\n          Impala, use either encoding style but do not mix 2-level and 3-level encoding within the same data file.\n        </p></div></div><div id=\"complex_types_vs_normalization\"><div class=\"hue-doc-title\">Choosing Between Complex Types and Normalized Tables</div><div><p>\n          Choosing between multiple normalized fact and dimension tables, or a single table containing complex types, is an important design\n          decision.\n        </p><ul><li><p>\n              If you are coming from a traditional database or data warehousing background, you might be familiar with how to split up data\n              between tables. Your business intelligence tools might already be optimized for dealing with this kind of multi-table scenario\n              through join queries.\n            </p></li><li><p>\n              If you are pulling data from Impala into an application written in a programming language that has data structures analogous\n              to the complex types, such as Python or Java, complex types in Impala could simplify data interchange and improve\n              understandability and reliability of your program logic.\n            </p></li><li><p>\n              You might already be faced with existing infrastructure or receive high volumes of data that assume one layout or the other.\n              For example, complex types are popular with web-oriented applications, for example to keep information about an online user\n              all in one place for convenient lookup and analysis, or to deal with sparse or constantly evolving data fields.\n            </p></li><li><p>\n              If some parts of the data change over time while related data remains constant, using multiple normalized tables lets you\n              replace certain parts of the data without reloading the entire data set. Conversely, if you receive related data all bundled\n              together, such as in JSON files, using complex types can save the overhead of splitting the related items across multiple\n              tables.\n            </p></li><li><p>\n              From a performance perspective:\n            </p><ul><li><p>\n                  In Parquet tables, Impala can skip columns that are not referenced in a query, avoiding the I/O penalty of reading the\n                  embedded data. When complex types are nested within a column, the data is physically divided at a very granular level; for\n                  example, a query referring to data nested multiple levels deep in a complex type column does not have to read all the data\n                  from that column, only the data for the relevant parts of the column type hierarchy.\n</p></li><li><p>\n                  Complex types avoid the possibility of expensive join queries when data from fact and dimension tables is processed in\n                  parallel across multiple hosts. All the information for a row containing complex types is typically to be in the same data\n                  block, and therefore does not need to be transmitted across the network when joining fields that are all part of the same\n                  row.\n                </p></li><li><p>\n                  The tradeoff with complex types is that fewer rows fit in each data block. Whether it is better to have more data blocks\n                  with fewer rows, or fewer data blocks with many rows, depends on the distribution of your data and the characteristics of\n                  your query workload. If the complex columns are rarely referenced, using them might lower efficiency. If you are seeing\n                  low parallelism due to a small volume of data (relatively few data blocks) in each table partition, increasing the row\n                  size by including complex columns might produce more data blocks and thus spread the work more evenly across the cluster.\n                  See <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_scalability.html#scalability\" target=\"_blank\">Scalability Considerations for Impala</a> for more on this advanced topic.\n                </p></li></ul></li></ul></div></div><div id=\"complex_types_hive\"><div class=\"hue-doc-title\">Differences Between Impala and Hive Complex Types</div><div><p>\n          Impala can query Parquet tables containing <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, and <span class=\"hue-doc-codeph\">MAP</span> columns\n          produced by Hive. There are some differences to be aware of between the Impala SQL and HiveQL syntax for complex types, primarily\n          for queries.\n        </p><p>\n          Impala supports a subset of the syntax that Hive supports for\n          specifying <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, and\n            <span class=\"hue-doc-codeph\">MAP</span> types in the <span class=\"hue-doc-codeph\">CREATE TABLE</span>\n          statements.\n        </p><p>\n          Because Impala <span class=\"hue-doc-codeph\">STRUCT</span> columns include user-specified field names, you use the <span class=\"hue-doc-codeph\">NAMED_STRUCT()</span>\n          constructor in Hive rather than the <span class=\"hue-doc-codeph\">STRUCT()</span> constructor when you populate an Impala <span class=\"hue-doc-codeph\">STRUCT</span>\n          column using a Hive <span class=\"hue-doc-codeph\">INSERT</span> statement.\n        </p><p>\n          The Hive <span class=\"hue-doc-codeph\">UNION</span> type is not currently supported in Impala.\n        </p><p>\n          While Impala usually aims for a high degree of compatibility with HiveQL query syntax, Impala syntax differs from Hive for queries\n          involving complex types. The differences are intended to provide extra flexibility for queries involving these kinds of tables.\n        </p><ul><li>\n            Impala uses dot notation for referring to element names or elements within complex types, and join notation for\n            cross-referencing scalar columns with the elements of complex types within the same row, rather than the <span class=\"hue-doc-codeph\">LATERAL\n            VIEW</span> clause and <span class=\"hue-doc-codeph\">EXPLODE()</span> function of HiveQL.\n          </li><li>\n            Using join notation lets you use all the kinds of join queries with complex type columns. For example, you can use a\n            <span class=\"hue-doc-codeph\">LEFT OUTER JOIN</span>, <span class=\"hue-doc-codeph\">LEFT ANTI JOIN</span>, or <span class=\"hue-doc-codeph\">LEFT SEMI JOIN</span> query to evaluate\n            different scenarios where the complex columns do or do not contain any elements.\n          </li><li>\n            You can include references to collection types inside subqueries and inline views. For example, you can construct a\n            <span class=\"hue-doc-codeph\">FROM</span> clause where one of the <q>tables</q> is a subquery against a complex type column, or use a subquery\n            against a complex type column as the argument to an <span class=\"hue-doc-codeph\">IN</span> or <span class=\"hue-doc-codeph\">EXISTS</span> clause.\n          </li><li>\n            The Impala pseudocolumn <span class=\"hue-doc-codeph\">POS</span> lets you retrieve the position of elements in an array along with the elements\n            themselves, equivalent to the <span class=\"hue-doc-codeph\">POSEXPLODE()</span> function of HiveQL. You do not use index notation to retrieve a\n            single array element in a query; the join query loops through the array elements and you use <span class=\"hue-doc-codeph\">WHERE</span> clauses to\n            specify which elements to return.\n          </li><li><p>\n              Join clauses involving complex type columns do not require an <span class=\"hue-doc-codeph\">ON</span> or <span class=\"hue-doc-codeph\">USING</span> clause. Impala\n              implicitly applies the join key so that the correct array entries or map elements are associated with the correct row from the\n              table.\n            </p></li><li><p>\n              Impala does not currently support the <span class=\"hue-doc-codeph\">UNION</span> complex type.\n            </p></li></ul></div></div><div id=\"complex_types_limits\"><div class=\"hue-doc-title\">Limitations and Restrictions for Complex Types</div><div><p>\n          Complex type columns can only be used in tables or partitions with the Parquet file format.\n        </p><p>\n          Complex type columns cannot be used as partition key columns in a partitioned table.\n        </p><p>\n          When you use complex types with the <span class=\"hue-doc-codeph\">ORDER BY</span>, <span class=\"hue-doc-codeph\">GROUP BY</span>, <span class=\"hue-doc-codeph\">HAVING</span>, or\n          <span class=\"hue-doc-codeph\">WHERE</span> clauses, you cannot refer to the column name by itself. Instead, you refer to the names of the scalar\n          values within the complex type, such as the <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">POS</span>, <span class=\"hue-doc-codeph\">KEY</span>, or\n          <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumns, or the field names from a <span class=\"hue-doc-codeph\">STRUCT</span>.\n        </p><p>\n          The maximum depth of nesting for complex types is 100 levels.\n        </p><p id=\"complex_types_max_length\">\n            The maximum length of the column definition for any complex type, including declarations for any nested types,\n            is 4000 characters.\n          </p><p>\n          For ideal performance and scalability, use small or medium-sized collections, where all the complex columns contain at most a few\n          hundred megabytes per row. Remember, all the columns of a row are stored in the same HDFS data block, whose size in Parquet files\n          typically ranges from 256 MB to 1 GB.\n        </p><p>\n          Including complex type columns in a table introduces some overhead that might make queries that do not reference those columns\n          somewhat slower than Impala queries against tables without any complex type columns. Expect at most a 2x slowdown compared to\n          tables that do not have any complex type columns.\n        </p><p>\n          Currently, the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement does not collect any statistics for columns containing complex types.\n          Impala uses heuristics to construct execution plans involving complex type columns.\n        </p><p>\n          Currently, Impala built-in functions and user-defined functions cannot accept complex types as parameters or produce them as\n          function return values. (When the complex type values are materialized in an Impala result set, the result set contains the scalar\n          components of the values, such as the <span class=\"hue-doc-codeph\">POS</span> or <span class=\"hue-doc-codeph\">ITEM</span> for an <span class=\"hue-doc-codeph\">ARRAY</span>, the\n          <span class=\"hue-doc-codeph\">KEY</span> or <span class=\"hue-doc-codeph\">VALUE</span> for a <span class=\"hue-doc-codeph\">MAP</span>, or the fields of a <span class=\"hue-doc-codeph\">STRUCT</span>; these\n          scalar data items <i>can</i> be used with built-in functions and UDFs as usual.)\n        </p><p id=\"complex_types_read_only\">\n        Impala currently cannot write new data files containing complex type columns.\n        Therefore, although the <span class=\"hue-doc-codeph\">SELECT</span> statement works for queries\n        involving complex type columns, you cannot use a statement form that writes\n        data to complex type columns, such as <span class=\"hue-doc-codeph\">CREATE TABLE AS SELECT</span> or <span class=\"hue-doc-codeph\">INSERT ... SELECT</span>.\n        To create data files containing complex type data, use the Hive <span class=\"hue-doc-codeph\">INSERT</span> statement, or another\n        ETL mechanism such as MapReduce jobs, Spark jobs, Pig, and so on.\n      </p><p>\n          Currently, Impala can query complex type columns only from Parquet tables or Parquet partitions within partitioned tables.\n          Although you can use complex types in tables with Avro, text, and other file formats as part of your ETL pipeline, for example as\n          intermediate tables populated through Hive, doing analytics through Impala requires that the data eventually ends up in a Parquet\n          table. The requirement for Parquet data files means that you can use complex types with Impala tables hosted on other kinds of\n          file storage systems such as Isilon and Amazon S3, but you cannot use Impala to query complex types from HBase tables. See\n          <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types_file_formats\">File Format Support for Impala Complex Types</a> for more details.\n        </p></div></div></div><div id=\"complex_types_using\"><div class=\"hue-doc-title\">Using Complex Types from SQL</div><div><p>\n        When using complex types through SQL in Impala, you learn the notation for <span class=\"hue-doc-codeph\">&lt; &gt;</span> delimiters for the complex\n        type columns in <span class=\"hue-doc-codeph\">CREATE TABLE</span> statements, and how to construct join queries to <q>unpack</q> the scalar values\n        nested inside the complex data structures. You might need to condense a traditional RDBMS or data warehouse schema into a smaller\n        number of Parquet tables, and use Hive, Spark, Pig, or other mechanism outside Impala to populate the tables with data.\n      </p><p/></div><div id=\"nested_types_ddl\"><div class=\"hue-doc-title\">Complex Type Syntax for DDL Statements</div><div><p>\n          The definition of <span class=\"hue-doc-varname\">data_type</span>, as seen in the <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n          statements, now includes complex types in addition to primitive types:\n        </p><div class=\"hue-doc-codeblock\">  primitive_type\n| array_type\n| map_type\n| struct_type\n</div><p>\n          Unions are not currently supported.\n        </p><p><span class=\"hue-doc-codeph\">Array</span>, <span class=\"hue-doc-codeph\">struct</span>, and\n            <span class=\"hue-doc-codeph\">map</span> column type declarations are specified in the\n            <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement. You can also add or change\n          the type of complex columns through the <span class=\"hue-doc-codeph\">ALTER TABLE</span>\n          statement. </p><p> Currently, Impala queries allow complex types only in tables that\n          use the Parquet format. If an Impala query encounters complex types in\n          a table or partition using another file format, the query returns a\n          runtime error. </p><p> You can use <span class=\"hue-doc-codeph\">ALTER TABLE ... SET FILEFORMAT PARQUET</span>\n          to change the file format of an existing table containing complex\n          types to Parquet, after which Impala can query it. Make sure to load\n          Parquet files into the table after changing the file format, because\n          the <span class=\"hue-doc-codeph\">ALTER TABLE ... SET FILEFORMAT</span> statement does not\n          convert existing data to the new file format. </p><p id=\"complex_types_partitioning\">\n        Partitioned tables can contain complex type columns.\n        All the partition key columns must be scalar types.\n      </p><p>\n          Because use cases for Impala complex types require that you already have Parquet data files produced outside of Impala, you can\n          use the Impala <span class=\"hue-doc-codeph\">CREATE TABLE LIKE PARQUET</span> syntax to produce a table with columns that match the structure of an\n          existing Parquet file, including complex type columns for nested data structures. Remember to include the <span class=\"hue-doc-codeph\">STORED AS\n          PARQUET</span> clause in this case, because even with <span class=\"hue-doc-codeph\">CREATE TABLE LIKE PARQUET</span>, the default file format of the\n          resulting table is still text.\n        </p><p>\n          Because the complex columns are omitted from the result set of an Impala <span class=\"hue-doc-codeph\">SELECT *</span> or <span class=\"hue-doc-codeph\">SELECT\n          <span class=\"hue-doc-varname\">col_name</span></span> query, and because Impala currently does not support writing Parquet files with complex type\n          columns, you cannot use the <span class=\"hue-doc-codeph\">CREATE TABLE AS SELECT</span> syntax to create a table with nested type columns.\n        </p><div class=\"hue-doc-note\"><p>\n            Once you have a table set up with complex type columns, use the <span class=\"hue-doc-codeph\">DESCRIBE</span> and <span class=\"hue-doc-codeph\">SHOW CREATE TABLE</span>\n            statements to see the correct notation with <span class=\"hue-doc-codeph\">&lt;</span> and <span class=\"hue-doc-codeph\">&gt;</span> delimiters and comma and colon\n            separators within the complex type definitions. If you do not have existing data with the same layout as the table, you can\n            query the empty table to practice with the notation for the <span class=\"hue-doc-codeph\">SELECT</span> statement. In the <span class=\"hue-doc-codeph\">SELECT</span>\n            list, you use dot notation and pseudocolumns such as <span class=\"hue-doc-codeph\">ITEM</span>, <span class=\"hue-doc-codeph\">KEY</span>, and <span class=\"hue-doc-codeph\">VALUE</span> for\n            referring to items within the complex type columns. In the <span class=\"hue-doc-codeph\">FROM</span> clause, you use join notation to construct\n            table aliases for any referenced <span class=\"hue-doc-codeph\">ARRAY</span> and <span class=\"hue-doc-codeph\">MAP</span> columns.\n          </p></div><p>\n          For example, when defining a table that holds contact information, you might represent phone numbers differently depending on the\n          expected layout and relationships of the data, and how well you can predict those properties in advance.\n        </p><p>\n          Here are different ways that you might represent phone numbers in a traditional relational schema, with equivalent representations\n          using complex types.\n        </p><div class=\"hue-doc-fig\" id=\"complex_types_phones_flat_fixed\"><div class=\"hue-doc-title\">Traditional Relational Representation of Phone Numbers: Single Table</div><p>\n            The traditional, simplest way to represent phone numbers in a relational table is to store all contact info in a single table,\n            with all columns having scalar types, and each potential phone number represented as a separate column. In this example, each\n            person can only have these 3 types of phone numbers. If the person does not have a particular kind of phone number, the\n            corresponding column is <span class=\"hue-doc-codeph\">NULL</span> for that row.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE contacts_fixed_phones\n(\n    id BIGINT\n  , name STRING\n  , address STRING\n  , home_phone STRING\n  , work_phone STRING\n  , mobile_phone STRING\n) STORED AS PARQUET;\n</div></div><div class=\"hue-doc-fig\" id=\"complex_types_phones_array\"><div class=\"hue-doc-title\">An Array of Phone Numbers</div><p>\n            Using a complex type column to represent the phone numbers adds some extra flexibility. Now there could be an unlimited number\n            of phone numbers. Because the array elements have an order but not symbolic names, you could decide in advance that\n            phone_number[0] is the home number, [1] is the work number, [2] is the mobile number, and so on. (In subsequent examples, you\n            will see how to create a more flexible naming scheme using other complex type variations, such as a <span class=\"hue-doc-codeph\">MAP</span> or an\n            <span class=\"hue-doc-codeph\">ARRAY</span> where each element is a <span class=\"hue-doc-codeph\">STRUCT</span>.)\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE contacts_array_of_phones\n(\n    id BIGINT\n  , name STRING\n  , address STRING\n  , phone_number ARRAY &lt; STRING &gt;\n) STORED AS PARQUET;\n</div></div><div class=\"hue-doc-fig\" id=\"complex_types_phones_map\"><div class=\"hue-doc-title\">A Map of Phone Numbers</div><p>\n            Another way to represent an arbitrary set of phone numbers is with a <span class=\"hue-doc-codeph\">MAP</span> column. With a <span class=\"hue-doc-codeph\">MAP</span>,\n            each element is associated with a key value that you specify, which could be a numeric, string, or other scalar type. This\n            example uses a <span class=\"hue-doc-codeph\">STRING</span> key to give each phone number a name, such as <span class=\"hue-doc-codeph\">'home'</span> or\n            <span class=\"hue-doc-codeph\">'mobile'</span>. A query could filter the data based on the key values, or display the key values in reports.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE contacts_unlimited_phones\n(\n  id BIGINT, name STRING, address STRING, phone_number MAP &lt; STRING,STRING &gt;\n) STORED AS PARQUET;\n</div></div><div class=\"hue-doc-fig\" id=\"complex_types_phones_flat_normalized\"><div class=\"hue-doc-title\">Traditional Relational Representation of Phone Numbers: Normalized Tables</div><p>\n            If you are an experienced database designer, you already know how to work around the limitations of the single-table schema from\n            <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"nested_types_ddl/complex_types_phones_flat_fixed\">Traditional Relational Representation of Phone Numbers: Single Table</a>. By normalizing the schema, with the phone numbers in their own\n            table, you can associate an arbitrary set of phone numbers with each person, and associate additional details with each phone\n            number, such as whether it is a home, work, or mobile phone.\n          </p><p>\n            The flexibility of this approach comes with some drawbacks. Reconstructing all the data for a particular person requires a join\n            query, which might require performance tuning on Hadoop because the data from each table might be transmitted from a different\n            host. Data management tasks such as backups and refreshing the data require dealing with multiple tables instead of a single\n            table.\n          </p><p>\n            This example illustrates a traditional database schema to store contact info normalized across 2 tables. The fact table\n            establishes the identity and basic information about person. A dimension table stores information only about phone numbers,\n            using an ID value to associate each phone number with a person ID from the fact table. Each person can have 0, 1, or many\n            phones; the categories are not restricted to a few predefined ones; and the phone table can contain as many columns as desired,\n            to represent all sorts of details about each phone number.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE fact_contacts (id BIGINT, name STRING, address STRING) STORED AS PARQUET;\nCREATE TABLE dim_phones\n(\n    contact_id BIGINT\n  , category STRING\n  , international_code STRING\n  , area_code STRING\n  , exchange STRING\n  , extension STRING\n  , mobile BOOLEAN\n  , carrier STRING\n  , current BOOLEAN\n  , service_start_date TIMESTAMP\n  , service_end_date TIMESTAMP\n)\nSTORED AS PARQUET;\n</div></div><div class=\"hue-doc-fig\" id=\"complex_types_phones_array_struct\"><div class=\"hue-doc-title\">Phone Numbers Represented as an Array of Structs</div><p>\n            To represent a schema equivalent to the one from <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"nested_types_ddl/complex_types_phones_flat_normalized\">Traditional Relational Representation of Phone Numbers: Normalized Tables</a> using\n            complex types, this example uses an <span class=\"hue-doc-codeph\">ARRAY</span> where each array element is a <span class=\"hue-doc-codeph\">STRUCT</span>. As with the\n            earlier complex type examples, each person can have an arbitrary set of associated phone numbers. Making each array element into\n            a <span class=\"hue-doc-codeph\">STRUCT</span> lets us associate multiple data items with each phone number, and give a separate name and type to\n            each data item. The <span class=\"hue-doc-codeph\">STRUCT</span> fields of the <span class=\"hue-doc-codeph\">ARRAY</span> elements reproduce the columns of the dimension\n            table from the previous example.\n          </p><p>\n            You can do all the same kinds of queries with the complex type schema as with the normalized schema from the previous example.\n            The advantages of the complex type design are in the areas of convenience and performance. Now your backup and ETL processes\n            only deal with a single table. When a query uses a join to cross-reference the information about a person with their associated\n            phone numbers, all the relevant data for each row resides in the same HDFS data block, meaning each row can be processed on a\n            single host without requiring network transmission.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE contacts_detailed_phones\n(\n  id BIGINT, name STRING, address STRING\n    , phone ARRAY &lt; STRUCT &lt;\n        category: STRING\n      , international_code: STRING\n      , area_code: STRING\n      , exchange: STRING\n      , extension: STRING\n      , mobile: BOOLEAN\n      , carrier: STRING\n      , current: BOOLEAN\n      , service_start_date: TIMESTAMP\n      , service_end_date: TIMESTAMP\n    &gt;&gt;\n) STORED AS PARQUET;\n</div></div></div></div><div id=\"complex_types_sql\"><div class=\"hue-doc-title\">SQL Statements that Support Complex Types</div><div><p>\n          The Impala SQL statements that support complex types are currently\n          <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE</a></span>,\n          <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_alter_table.xml\" data-doc-anchor-id=\"alter_table\">ALTER TABLE</a></span>,\n          <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_describe.xml\" data-doc-anchor-id=\"describe\">DESCRIBE</a></span>,\n          <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_load_data.xml\" data-doc-anchor-id=\"load_data\">LOAD DATA</a></span>, and\n          <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_select.xml\" data-doc-anchor-id=\"select\">SELECT</a></span>. That is, currently Impala can create or alter tables\n          containing complex type columns, examine the structure of a table containing complex type columns, import existing data files\n          containing complex type columns into a table, and query Parquet tables containing complex types.\n        </p><p id=\"complex_types_read_only\">\n        Impala currently cannot write new data files containing complex type columns.\n        Therefore, although the <span class=\"hue-doc-codeph\">SELECT</span> statement works for queries\n        involving complex type columns, you cannot use a statement form that writes\n        data to complex type columns, such as <span class=\"hue-doc-codeph\">CREATE TABLE AS SELECT</span> or <span class=\"hue-doc-codeph\">INSERT ... SELECT</span>.\n        To create data files containing complex type data, use the Hive <span class=\"hue-doc-codeph\">INSERT</span> statement, or another\n        ETL mechanism such as MapReduce jobs, Spark jobs, Pig, and so on.\n      </p><p/></div><div id=\"complex_types_ddl\"><div class=\"hue-doc-title\">DDL Statements and Complex Types</div><div><p>\n            Column specifications for complex or nested types use <span class=\"hue-doc-codeph\">&lt;</span> and <span class=\"hue-doc-codeph\">&gt;</span> delimiters:\n          </p><div class=\"hue-doc-codeblock\">-- What goes inside the &lt; &gt; for an ARRAY is a single type, either a scalar or another\n-- complex type (ARRAY, STRUCT, or MAP).\nCREATE TABLE array_t\n(\n  id BIGINT,\n  a1 ARRAY &lt;STRING&gt;,\n  a2 ARRAY &lt;BIGINT&gt;,\n  a3 ARRAY &lt;TIMESTAMP&gt;,\n  a4 ARRAY &lt;STRUCT &lt;f1: STRING, f2: INT, f3: BOOLEAN&gt;&gt;\n)\nSTORED AS PARQUET;\n\n-- What goes inside the &lt; &gt; for a MAP is two comma-separated types specifying the types of the key-value pair:\n-- a scalar type representing the key, and a scalar or complex type representing the value.\nCREATE TABLE map_t\n(\n  id BIGINT,\n  m1 MAP &lt;STRING, STRING&gt;,\n  m2 MAP &lt;STRING, BIGINT&gt;,\n  m3 MAP &lt;BIGINT, STRING&gt;,\n  m4 MAP &lt;BIGINT, BIGINT&gt;,\n  m5 MAP &lt;STRING, ARRAY &lt;STRING&gt;&gt;\n)\nSTORED AS PARQUET;\n\n-- What goes inside the &lt; &gt; for a STRUCT is a comma-separated list of fields, each field defined as\n-- name:type. The type can be a scalar or a complex type. The field names for each STRUCT do not clash\n-- with the names of table columns or fields in other STRUCTs. A STRUCT is most often used inside\n-- an ARRAY or a MAP rather than as a top-level column.\nCREATE TABLE struct_t\n(\n  id BIGINT,\n  s1 STRUCT &lt;f1: STRING, f2: BIGINT&gt;,\n  s2 ARRAY &lt;STRUCT &lt;f1: INT, f2: TIMESTAMP&gt;&gt;,\n  s3 MAP &lt;BIGINT, STRUCT &lt;name: STRING, birthday: TIMESTAMP&gt;&gt;\n)\nSTORED AS PARQUET;\n</div></div></div><div id=\"complex_types_queries\"><div class=\"hue-doc-title\">Queries and Complex Types</div><div><p>\n            The result set of an Impala query always contains all scalar types; the elements and fields within any complex type queries must\n            be <q>unpacked</q> using join queries. A query cannot directly retrieve the entire value for a complex type column. Impala\n            returns an error in this case. Queries using <span class=\"hue-doc-codeph\">SELECT *</span> are allowed for tables with complex types, but the\n            columns with complex types are skipped.\n          </p><p>\n            The following example shows how referring directly to a complex type column returns an error, while <span class=\"hue-doc-codeph\">SELECT *</span> on\n            the same table succeeds, but only retrieves the scalar columns.\n          </p><div class=\"hue-doc-note\" id=\"complex_type_schema_pointer\">      Many of the complex type examples refer to tables\n      such as <span class=\"hue-doc-codeph\">CUSTOMER</span> and <span class=\"hue-doc-codeph\">REGION</span>\n      adapted from the tables used in the TPC-H benchmark.\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_sample_schema\">Sample Schema and Data for Experimenting with Impala Complex Types</a>\n      for the table definitions.\n      </div><div class=\"hue-doc-codeblock\">SELECT c_orders FROM customer LIMIT 1;\nERROR: AnalysisException: Expr 'c_orders' in select list returns a complex type 'ARRAY&lt;STRUCT&lt;o_orderkey:BIGINT,o_orderstatus:STRING, ... l_receiptdate:STRING,l_shipinstruct:STRING,l_shipmode:STRING,l_comment:STRING&gt;&gt;&gt;&gt;'.\nOnly scalar types are allowed in the select list.\n\n-- Original column has several scalar and one complex column.\nDESCRIBE customer;\n+--------------+------------------------------------+\n| name         | type                               |\n+--------------+------------------------------------+\n| c_custkey    | bigint                             |\n| c_name       | string                             |\n...\n| c_orders     | array&lt;struct&lt;                      |\n|              |   o_orderkey:bigint,               |\n|              |   o_orderstatus:string,            |\n|              |   o_totalprice:decimal(12,2),      |\n...\n|              | &gt;&gt;                                 |\n+--------------+------------------------------------+\n\n-- When we SELECT * from that table, only the scalar columns come back in the result set.\nCREATE TABLE select_star_customer STORED AS PARQUET AS SELECT * FROM customer;\n+------------------------+\n| summary                |\n+------------------------+\n| Inserted 150000 row(s) |\n+------------------------+\n\n-- The c_orders column, being of complex type, was not included in the SELECT * result set.\nDESC select_star_customer;\n+--------------+---------------+\n| name         | type          |\n+--------------+---------------+\n| c_custkey    | bigint        |\n| c_name       | string        |\n| c_address    | string        |\n| c_nationkey  | smallint      |\n| c_phone      | string        |\n| c_acctbal    | decimal(12,2) |\n| c_mktsegment | string        |\n| c_comment    | string        |\n+--------------+---------------+\n</div><p>\n            References to fields within <span class=\"hue-doc-codeph\">STRUCT</span> columns use dot notation. If the field name is unambiguous, you can omit\n            qualifiers such as table name, column name, or even the <span class=\"hue-doc-codeph\">ITEM</span> or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn names for\n            <span class=\"hue-doc-codeph\">STRUCT</span> elements inside an <span class=\"hue-doc-codeph\">ARRAY</span> or a <span class=\"hue-doc-codeph\">MAP</span>.\n          </p><div class=\"hue-doc-codeblock\">SELECT id, address.city FROM customers WHERE address.zip = 94305;\n</div><p>\n            References to elements within <span class=\"hue-doc-codeph\">ARRAY</span> columns use the <span class=\"hue-doc-codeph\">ITEM</span> pseudocolumn:\n          </p><div class=\"hue-doc-codeblock\">select r_name, r_nations.item.n_name from region, region.r_nations limit 7;\n+--------+----------------+\n| r_name | item.n_name    |\n+--------+----------------+\n| EUROPE | UNITED KINGDOM |\n| EUROPE | RUSSIA         |\n| EUROPE | ROMANIA        |\n| EUROPE | GERMANY        |\n| EUROPE | FRANCE         |\n| ASIA   | VIETNAM        |\n| ASIA   | CHINA          |\n+--------+----------------+\n</div><p>\n            References to fields within <span class=\"hue-doc-codeph\">MAP</span> columns use the <span class=\"hue-doc-codeph\">KEY</span> and <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumns.\n            In this example, once the query establishes the alias <span class=\"hue-doc-codeph\">MAP_FIELD</span> for a <span class=\"hue-doc-codeph\">MAP</span> column with a\n            <span class=\"hue-doc-codeph\">STRING</span> key and an <span class=\"hue-doc-codeph\">INT</span> value, the query can refer to <span class=\"hue-doc-codeph\">MAP_FIELD.KEY</span> and\n            <span class=\"hue-doc-codeph\">MAP_FIELD.VALUE</span>, which have zero, one, or many instances for each row from the containing table.\n          </p><div class=\"hue-doc-codeblock\">DESCRIBE table_0;\n+---------+-----------------------+\n| name    | type                  |\n+---------+-----------------------+\n| field_0 | string                |\n| field_1 | map&lt;string,int&gt;       |\n...\n\nSELECT field_0, map_field.key, map_field.value\n  FROM table_0, table_0.field_1 AS map_field\nWHERE length(field_0) = 1\nLIMIT 10;\n+---------+-----------+-------+\n| field_0 | key       | value |\n+---------+-----------+-------+\n| b       | gshsgkvd  | NULL  |\n| b       | twrtcxj6  | 18    |\n| b       | 2vp5      | 39    |\n| b       | fh0s      | 13    |\n| v       | 2         | 41    |\n| v       | 8b58mz    | 20    |\n| v       | hw        | 16    |\n| v       | 65l388pyt | 29    |\n| v       | 03k68g91z | 30    |\n| v       | r2hlg5b   | NULL  |\n+---------+-----------+-------+\n</div><p>\n            When complex types are nested inside each other, you use a combination of joins, pseudocolumn names, and dot notation to refer\n            to specific fields at the appropriate level. This is the most frequent form of query syntax for complex columns, because the\n            typical use case involves two levels of complex types, such as an <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span> elements.\n          </p><div class=\"hue-doc-codeblock\">SELECT id, phone_numbers.area_code FROM contact_info_many_structs INNER JOIN contact_info_many_structs.phone_numbers phone_numbers LIMIT 3;\n</div><p>\n            You can express relationships between <span class=\"hue-doc-codeph\">ARRAY</span> and <span class=\"hue-doc-codeph\">MAP</span> columns at different levels as joins. You\n            include comparison operators between fields at the top level and within the nested type columns so that Impala can do the\n            appropriate join operation.\n          </p><div class=\"hue-doc-note\" id=\"complex_type_schema_pointer\">      Many of the complex type examples refer to tables\n      such as <span class=\"hue-doc-codeph\">CUSTOMER</span> and <span class=\"hue-doc-codeph\">REGION</span>\n      adapted from the tables used in the TPC-H benchmark.\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_sample_schema\">Sample Schema and Data for Experimenting with Impala Complex Types</a>\n      for the table definitions.\n      </div><p>\n            For example, the following queries work equivalently. They each return customer and order data for customers that have at least\n            one order.\n          </p><div class=\"hue-doc-codeblock\">SELECT c.c_name, o.o_orderkey FROM customer c, c.c_orders o LIMIT 5;\n+--------------------+------------+\n| c_name             | o_orderkey |\n+--------------------+------------+\n| Customer#000072578 | 558821     |\n| Customer#000072578 | 2079810    |\n| Customer#000072578 | 5768068    |\n| Customer#000072578 | 1805604    |\n| Customer#000072578 | 3436389    |\n+--------------------+------------+\n\nSELECT c.c_name, o.o_orderkey FROM customer c INNER JOIN c.c_orders o LIMIT 5;\n+--------------------+------------+\n| c_name             | o_orderkey |\n+--------------------+------------+\n| Customer#000072578 | 558821     |\n| Customer#000072578 | 2079810    |\n| Customer#000072578 | 5768068    |\n| Customer#000072578 | 1805604    |\n| Customer#000072578 | 3436389    |\n+--------------------+------------+\n</div><p>\n            The following query using an outer join returns customers that have orders, plus customers with no orders (no entries in the\n            <span class=\"hue-doc-codeph\">C_ORDERS</span> array):\n          </p><div class=\"hue-doc-codeblock\">SELECT c.c_custkey, o.o_orderkey\n  FROM customer c LEFT OUTER JOIN c.c_orders o\nLIMIT 5;\n+-----------+------------+\n| c_custkey | o_orderkey |\n+-----------+------------+\n| 60210     | NULL       |\n| 147873    | NULL       |\n| 72578     | 558821     |\n| 72578     | 2079810    |\n| 72578     | 5768068    |\n+-----------+------------+\n</div><p>\n            The following query returns <i>only</i> customers that have no orders. (With <span class=\"hue-doc-codeph\">LEFT ANTI JOIN</span> or <span class=\"hue-doc-codeph\">LEFT\n            SEMI JOIN</span>, the query can only refer to columns from the left-hand table, because by definition there is no matching\n            information in the right-hand table.)\n          </p><div class=\"hue-doc-codeblock\">SELECT c.c_custkey, c.c_name\n  FROM customer c LEFT ANTI JOIN c.c_orders o\nLIMIT 5;\n+-----------+--------------------+\n| c_custkey | c_name             |\n+-----------+--------------------+\n| 60210     | Customer#000060210 |\n| 147873    | Customer#000147873 |\n| 141576    | Customer#000141576 |\n| 85365     | Customer#000085365 |\n| 70998     | Customer#000070998 |\n+-----------+--------------------+\n</div><p>\n            You can also perform correlated subqueries to examine the properties of complex type columns for each row in the result set.\n          </p><p>\n            Count the number of orders per customer. Note the correlated reference to the table alias <span class=\"hue-doc-codeph\">C</span>. The\n            <span class=\"hue-doc-codeph\">COUNT(*)</span> operation applies to all the elements of the <span class=\"hue-doc-codeph\">C_ORDERS</span> array for the corresponding\n            row, avoiding the need for a <span class=\"hue-doc-codeph\">GROUP BY</span> clause.\n          </p><div class=\"hue-doc-codeblock\">select c_name, howmany FROM customer c, (SELECT COUNT(*) howmany FROM c.c_orders) v limit 5;\n+--------------------+---------+\n| c_name             | howmany |\n+--------------------+---------+\n| Customer#000030065 | 15      |\n| Customer#000065455 | 18      |\n| Customer#000113644 | 21      |\n| Customer#000111078 | 0       |\n| Customer#000024621 | 0       |\n+--------------------+---------+\n</div><p>\n            Count the number of orders per customer, ignoring any customers that have not placed any orders:\n          </p><div class=\"hue-doc-codeblock\">SELECT c_name, howmany_orders\nFROM\n  customer c,\n  (SELECT COUNT(*) howmany_orders FROM c.c_orders) subq1\nWHERE howmany_orders &gt; 0\nLIMIT 5;\n+--------------------+----------------+\n| c_name             | howmany_orders |\n+--------------------+----------------+\n| Customer#000072578 | 7              |\n| Customer#000046378 | 26             |\n| Customer#000069815 | 11             |\n| Customer#000079058 | 12             |\n| Customer#000092239 | 26             |\n+--------------------+----------------+\n</div><p>\n            Count the number of line items in each order. The reference to <span class=\"hue-doc-codeph\">C.C_ORDERS</span> in the <span class=\"hue-doc-codeph\">FROM</span> clause\n            is needed because the <span class=\"hue-doc-codeph\">O_ORDERKEY</span> field is a member of the elements in the <span class=\"hue-doc-codeph\">C_ORDERS</span> array. The\n            subquery labelled <span class=\"hue-doc-codeph\">SUBQ1</span> is correlated: it is re-evaluated for the <span class=\"hue-doc-codeph\">C_ORDERS.O_LINEITEMS</span> array\n            from each row of the <span class=\"hue-doc-codeph\">CUSTOMERS</span> table.\n          </p><div class=\"hue-doc-codeblock\">SELECT c_name, o_orderkey, howmany_line_items\nFROM\n  customer c,\n  c.c_orders t2,\n  (SELECT COUNT(*) howmany_line_items FROM c.c_orders.o_lineitems) subq1\nWHERE howmany_line_items &gt; 0\nLIMIT 5;\n+--------------------+------------+--------------------+\n| c_name             | o_orderkey | howmany_line_items |\n+--------------------+------------+--------------------+\n| Customer#000020890 | 1884930    | 95                 |\n| Customer#000020890 | 4570754    | 95                 |\n| Customer#000020890 | 3771072    | 95                 |\n| Customer#000020890 | 2555489    | 95                 |\n| Customer#000020890 | 919171     | 95                 |\n+--------------------+------------+--------------------+\n</div><p>\n            Get the number of orders, the average order price, and the maximum items in any order per customer. For this example, the\n            subqueries labelled <span class=\"hue-doc-codeph\">SUBQ1</span> and <span class=\"hue-doc-codeph\">SUBQ2</span> are correlated: they are re-evaluated for each row from\n            the original <span class=\"hue-doc-codeph\">CUSTOMER</span> table, and only apply to the complex columns associated with that row.\n          </p><div class=\"hue-doc-codeblock\">SELECT c_name, howmany, average_price, most_items\nFROM\n  customer c,\n  (SELECT COUNT(*) howmany, AVG(o_totalprice) average_price FROM c.c_orders) subq1,\n  (SELECT MAX(l_quantity) most_items FROM c.c_orders.o_lineitems ) subq2\nLIMIT 5;\n+--------------------+---------+---------------+------------+\n| c_name             | howmany | average_price | most_items |\n+--------------------+---------+---------------+------------+\n| Customer#000030065 | 15      | 128908.34     | 50.00      |\n| Customer#000088191 | 0       | NULL          | NULL       |\n| Customer#000101555 | 10      | 164250.31     | 50.00      |\n| Customer#000022092 | 0       | NULL          | NULL       |\n| Customer#000036277 | 27      | 166040.06     | 50.00      |\n+--------------------+---------+---------------+------------+\n</div><p>\n            For example, these queries show how to access information about the <span class=\"hue-doc-codeph\">ARRAY</span> elements within the\n            <span class=\"hue-doc-codeph\">CUSTOMER</span> table from the <q>nested TPC-H</q> schema, starting with the initial <span class=\"hue-doc-codeph\">ARRAY</span> elements\n            and progressing to examine the <span class=\"hue-doc-codeph\">STRUCT</span> fields of the <span class=\"hue-doc-codeph\">ARRAY</span>, and then the elements nested within\n            another <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span>:\n          </p><div class=\"hue-doc-codeblock\">-- How many orders does each customer have?\n-- The type of the ARRAY column doesn't matter, this is just counting the elements.\nSELECT c_custkey, count(*)\n  FROM customer, customer.c_orders\nGROUP BY c_custkey\nLIMIT 5;\n+-----------+----------+\n| c_custkey | count(*) |\n+-----------+----------+\n| 61081     | 21       |\n| 115987    | 15       |\n| 69685     | 19       |\n| 109124    | 15       |\n| 50491     | 12       |\n+-----------+----------+\n\n-- How many line items are part of each customer order?\n-- Now we examine a field from a STRUCT nested inside the ARRAY.\nSELECT c_custkey, c_orders.o_orderkey, count(*)\n  FROM customer, customer.c_orders c_orders, c_orders.o_lineitems\nGROUP BY c_custkey, c_orders.o_orderkey\nLIMIT 5;\n+-----------+------------+----------+\n| c_custkey | o_orderkey | count(*) |\n+-----------+------------+----------+\n| 63367     | 4985959    | 7        |\n| 53989     | 1972230    | 2        |\n| 143513    | 5750498    | 5        |\n| 17849     | 4857989    | 1        |\n| 89881     | 1046437    | 1        |\n+-----------+------------+----------+\n\n-- What are the line items in each customer order?\n-- One of the STRUCT fields inside the ARRAY is another\n-- ARRAY containing STRUCT elements. The join finds\n-- all the related items from both levels of ARRAY.\nSELECT c_custkey, o_orderkey, l_partkey\n  FROM customer, customer.c_orders, c_orders.o_lineitems\nLIMIT 5;\n+-----------+------------+-----------+\n| c_custkey | o_orderkey | l_partkey |\n+-----------+------------+-----------+\n| 113644    | 2738497    | 175846    |\n| 113644    | 2738497    | 27309     |\n| 113644    | 2738497    | 175873    |\n| 113644    | 2738497    | 88559     |\n| 113644    | 2738497    | 8032      |\n+-----------+------------+-----------+\n</div></div></div></div><div id=\"pseudocolumns\"><div class=\"hue-doc-title\">Pseudocolumns for ARRAY and MAP Types</div><div><p>\n          Each element in an <span class=\"hue-doc-codeph\">ARRAY</span> type has a position, indexed starting from zero, and a value. Each element in a\n          <span class=\"hue-doc-codeph\">MAP</span> type represents a key-value pair. Impala provides pseudocolumns that let you retrieve this metadata as part\n          of a query, or filter query results by including such things in a <span class=\"hue-doc-codeph\">WHERE</span> clause. You refer to the pseudocolumns as\n          part of qualified column names in queries:\n        </p><ul><li><span class=\"hue-doc-codeph\">ITEM</span>: The value of an array element. If the <span class=\"hue-doc-codeph\">ARRAY</span> contains <span class=\"hue-doc-codeph\">STRUCT</span> elements,\n            you can refer to either <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_name</span>.ITEM.<span class=\"hue-doc-varname\">field_name</span></span> or use the shorthand\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_name</span>.<span class=\"hue-doc-varname\">field_name</span></span>.\n          </li><li><span class=\"hue-doc-codeph\">POS</span>: The position of an element within an array.\n          </li><li><span class=\"hue-doc-codeph\">KEY</span>: The value forming the first part of a key-value pair in a map. It is not necessarily unique.\n          </li><li><span class=\"hue-doc-codeph\">VALUE</span>: The data item forming the second part of a key-value pair in a map. If the <span class=\"hue-doc-codeph\">VALUE</span> part\n            of the <span class=\"hue-doc-codeph\">MAP</span> element is a <span class=\"hue-doc-codeph\">STRUCT</span>, you can refer to either\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_name</span>.VALUE.<span class=\"hue-doc-varname\">field_name</span></span> or use the shorthand\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_name</span>.<span class=\"hue-doc-varname\">field_name</span></span>.\n          </li></ul><p/></div><div id=\"item\"><div class=\"hue-doc-title\" id=\"pos\">ITEM and POS Pseudocolumns</div><div><p>\n            When an <span class=\"hue-doc-codeph\">ARRAY</span> column contains <span class=\"hue-doc-codeph\">STRUCT</span> elements, you can refer to a field within the\n            <span class=\"hue-doc-codeph\">STRUCT</span> using a qualified name of the form\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_column</span>.<span class=\"hue-doc-varname\">field_name</span></span>. If the <span class=\"hue-doc-codeph\">ARRAY</span> contains scalar\n            values, Impala recognizes the special name <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_column</span>.ITEM</span> to represent the value of each\n            scalar array element. For example, if a column contained an <span class=\"hue-doc-codeph\">ARRAY</span> where each element was a\n            <span class=\"hue-doc-codeph\">STRING</span>, you would use <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_name</span>.ITEM</span> to refer to each scalar value in the\n            <span class=\"hue-doc-codeph\">SELECT</span> list, or the <span class=\"hue-doc-codeph\">WHERE</span> or other clauses.\n          </p><p>\n            This example shows a table with two <span class=\"hue-doc-codeph\">ARRAY</span> columns whose elements are of the scalar type\n            <span class=\"hue-doc-codeph\">STRING</span>. When referring to the values of the array elements in the <span class=\"hue-doc-codeph\">SELECT</span> list,\n            <span class=\"hue-doc-codeph\">WHERE</span> clause, or <span class=\"hue-doc-codeph\">ORDER BY</span> clause, you use the <span class=\"hue-doc-codeph\">ITEM</span> pseudocolumn because\n            within the array, the individual elements have no defined names.\n          </p><div class=\"hue-doc-codeblock\">create TABLE persons_of_interest\n(\nperson_id BIGINT,\naliases ARRAY &lt;STRING&gt;,\nassociates ARRAY &lt;STRING&gt;,\nreal_name STRING\n)\nSTORED AS PARQUET;\n\n-- Get all the aliases of each person.\nSELECT real_name, aliases.ITEM\n  FROM persons_of_interest, persons_of_interest.aliases\nORDER BY real_name, aliases.item;\n\n-- Search for particular associates of each person.\nSELECT real_name, associates.ITEM\n  FROM persons_of_interest, persons_of_interest.associates\nWHERE associates.item LIKE '% MacGuffin';\n</div><p>\n            Because an array is inherently an ordered data structure, Impala recognizes the special name\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">array_column</span>.POS</span> to represent the numeric position of each element within the array. The\n            <span class=\"hue-doc-codeph\">POS</span> pseudocolumn lets you filter or reorder the result set based on the sequence of array elements.\n          </p><p>\n            The following example uses a table from a flattened version of the TPC-H schema. The <span class=\"hue-doc-codeph\">REGION</span> table only has a\n            few rows, such as one row for Europe and one for Asia. The row for each region represents all the countries in that region as an\n            <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span> elements:\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; desc region;\n+-------------+--------------------------------------------------------------------+\n| name        | type                                                               |\n+-------------+--------------------------------------------------------------------+\n| r_regionkey | smallint                                                           |\n| r_name      | string                                                             |\n| r_comment   | string                                                             |\n| r_nations   | array&lt;struct&lt;n_nationkey:smallint,n_name:string,n_comment:string&gt;&gt; |\n+-------------+--------------------------------------------------------------------+\n</div><p>\n            To find the countries within a specific region, you use a join query. To find out the order of elements in the array, you also\n            refer to the <span class=\"hue-doc-codeph\">POS</span> pseudocolumn in the select list:\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; SELECT r1.r_name, r2.n_name, <b>r2.POS</b>\n                  &gt; FROM region r1 INNER JOIN r1.r_nations r2\n                  &gt; WHERE r1.r_name = 'ASIA';\n+--------+-----------+-----+\n| r_name | n_name    | pos |\n+--------+-----------+-----+\n| ASIA   | VIETNAM   | 0   |\n| ASIA   | CHINA     | 1   |\n| ASIA   | JAPAN     | 2   |\n| ASIA   | INDONESIA | 3   |\n| ASIA   | INDIA     | 4   |\n+--------+-----------+-----+\n</div><p>\n            Once you know the positions of the elements, you can use that information in subsequent queries, for example to change the\n            ordering of results from the complex type column or to filter certain elements from the array:\n          </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; SELECT r1.r_name, r2.n_name, r2.POS\n                  &gt; FROM region r1 INNER JOIN r1.r_nations r2\n                  &gt; WHERE r1.r_name = 'ASIA'\n                  &gt; <b>ORDER BY r2.POS DESC</b>;\n+--------+-----------+-----+\n| r_name | n_name    | pos |\n+--------+-----------+-----+\n| ASIA   | INDIA     | 4   |\n| ASIA   | INDONESIA | 3   |\n| ASIA   | JAPAN     | 2   |\n| ASIA   | CHINA     | 1   |\n| ASIA   | VIETNAM   | 0   |\n+--------+-----------+-----+\n[localhost:21000] &gt; SELECT r1.r_name, r2.n_name, r2.POS\n                  &gt; FROM region r1 INNER JOIN r1.r_nations r2\n                  &gt; WHERE r1.r_name = 'ASIA' AND <b>r2.POS BETWEEN 1 and 3</b>;\n+--------+-----------+-----+\n| r_name | n_name    | pos |\n+--------+-----------+-----+\n| ASIA   | CHINA     | 1   |\n| ASIA   | JAPAN     | 2   |\n| ASIA   | INDONESIA | 3   |\n+--------+-----------+-----+\n</div></div></div><div id=\"key\"><div class=\"hue-doc-title\" id=\"value\">KEY and VALUE Pseudocolumns</div><div><p>\n            The <span class=\"hue-doc-codeph\">MAP</span> data type is suitable for representing sparse or wide data structures, where each row might only have\n            entries for a small subset of named fields. Because the element names (the map keys) vary depending on the row, a query must be\n            able to refer to both the key and the value parts of each key-value pair. The <span class=\"hue-doc-codeph\">KEY</span> and <span class=\"hue-doc-codeph\">VALUE</span>\n            pseudocolumns let you refer to the parts of the key-value pair independently within the query, as\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_column</span>.KEY</span> and <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_column</span>.VALUE</span>.\n          </p><p>\n            The <span class=\"hue-doc-codeph\">KEY</span> must always be a scalar type, such as <span class=\"hue-doc-codeph\">STRING</span>, <span class=\"hue-doc-codeph\">BIGINT</span>, or\n            <span class=\"hue-doc-codeph\">TIMESTAMP</span>. It can be <span class=\"hue-doc-codeph\">NULL</span>. Values of the <span class=\"hue-doc-codeph\">KEY</span> field are not necessarily unique\n            within the same <span class=\"hue-doc-codeph\">MAP</span>. You apply any required <span class=\"hue-doc-codeph\">DISTINCT</span>, <span class=\"hue-doc-codeph\">GROUP BY</span>, and other\n            clauses in the query, and loop through the result set to process all the values matching any specified keys.\n          </p><p>\n            The <span class=\"hue-doc-codeph\">VALUE</span> can be either a scalar type or another complex type. If the <span class=\"hue-doc-codeph\">VALUE</span> is a\n            <span class=\"hue-doc-codeph\">STRUCT</span>, you can construct a qualified name\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_column</span>.VALUE.<span class=\"hue-doc-varname\">struct_field</span></span> to refer to the individual fields inside\n            the value part. If the <span class=\"hue-doc-codeph\">VALUE</span> is an <span class=\"hue-doc-codeph\">ARRAY</span> or another <span class=\"hue-doc-codeph\">MAP</span>, you must include\n            another join condition that establishes a table alias for <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">map_column</span>.VALUE</span>, and then\n            construct another qualified name using that alias, for example <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">table_alias</span>.ITEM</span> or\n            <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">table_alias</span>.KEY</span> and <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">table_alias</span>.VALUE</span></p><p>\n            The following example shows different ways to access a <span class=\"hue-doc-codeph\">MAP</span> column using the <span class=\"hue-doc-codeph\">KEY</span> and\n            <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumns. The <span class=\"hue-doc-codeph\">DETAILS</span> column has a <span class=\"hue-doc-codeph\">STRING</span> first part with short,\n            standardized values such as <span class=\"hue-doc-codeph\">'Recurring'</span>, <span class=\"hue-doc-codeph\">'Lucid'</span>, or <span class=\"hue-doc-codeph\">'Anxiety'</span>. This is the\n            <q>key</q> that is used to look up particular kinds of elements from the <span class=\"hue-doc-codeph\">MAP</span>. The second part, also a\n            <span class=\"hue-doc-codeph\">STRING</span>, is a longer free-form explanation. Impala gives you the standard pseudocolumn names\n            <span class=\"hue-doc-codeph\">KEY</span> and <span class=\"hue-doc-codeph\">VALUE</span> for the two parts, and you apply your own conventions and interpretations to the\n            underlying values.\n          </p><div class=\"hue-doc-note\">            If you find that the single-item nature of the <span class=\"hue-doc-codeph\">VALUE</span> makes it difficult to model your data accurately, the\n            solution is typically to add some nesting to the complex type. For example, to have several sets of key-value pairs, make the\n            column an <span class=\"hue-doc-codeph\">ARRAY</span> whose elements are <span class=\"hue-doc-codeph\">MAP</span>. To make a set of key-value pairs that holds more\n            elaborate information, make a <span class=\"hue-doc-codeph\">MAP</span> column whose <span class=\"hue-doc-codeph\">VALUE</span> part contains an <span class=\"hue-doc-codeph\">ARRAY</span>\n            or a <span class=\"hue-doc-codeph\">STRUCT</span>.\n          </div><div class=\"hue-doc-codeblock\">CREATE TABLE dream_journal\n(\n  dream_id BIGINT,\n  details MAP &lt;STRING,STRING&gt;\n)\nSTORED AS PARQUET;\n\n\n-- What are all the types of dreams that are recorded?\nSELECT DISTINCT details.KEY FROM dream_journal, dream_journal.details;\n\n-- How many lucid dreams were recorded?\n-- Because there is no GROUP BY, we count the 'Lucid' keys across all rows.\nSELECT <b>COUNT(details.KEY)</b>\n  FROM dream_journal, dream_journal.details\nWHERE <b>details.KEY = 'Lucid'</b>;\n\n-- Print a report of a subset of dreams, filtering based on both the lookup key\n-- and the detailed value.\nSELECT dream_id, <b>details.KEY AS \"Dream Type\"</b>, <b>details.VALUE AS \"Dream Summary\"</b>\n  FROM dream_journal, dream_journal.details\nWHERE\n  <b>details.KEY IN ('Happy', 'Pleasant', 'Joyous')</b>\n  AND <b>details.VALUE LIKE '%childhood%'</b>;\n</div><p>\n            The following example shows a more elaborate version of the previous table, where the <span class=\"hue-doc-codeph\">VALUE</span> part of the\n            <span class=\"hue-doc-codeph\">MAP</span> entry is a <span class=\"hue-doc-codeph\">STRUCT</span> rather than a scalar type. Now instead of referring to the\n            <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn directly, you use dot notation to refer to the <span class=\"hue-doc-codeph\">STRUCT</span> fields inside it.\n          </p><div class=\"hue-doc-codeblock\">CREATE TABLE better_dream_journal\n(\n  dream_id BIGINT,\n  details MAP &lt;STRING,STRUCT &lt;summary: STRING, when_happened: TIMESTAMP, duration: DECIMAL(5,2), woke_up: BOOLEAN&gt; &gt;\n)\nSTORED AS PARQUET;\n\n\n-- Do more elaborate reporting and filtering by examining multiple attributes within the same dream.\nSELECT dream_id, <b>details.KEY AS \"Dream Type\"</b>, <b>details.VALUE.summary AS \"Dream Summary\"</b>, <b>details.VALUE.duration AS \"Duration\"</b>\n  FROM better_dream_journal, better_dream_journal.details\nWHERE\n  <b>details.KEY IN ('Anxiety', 'Nightmare')</b>\n  AND <b>details.VALUE.duration &gt; 60</b>\n  AND <b>details.VALUE.woke_up = TRUE</b>;\n\n-- Remember that if the ITEM or VALUE contains a STRUCT, you can reference\n-- the STRUCT fields directly without the .ITEM or .VALUE qualifier.\nSELECT dream_id, <b>details.KEY AS \"Dream Type\"</b>, <b>details.summary AS \"Dream Summary\"</b>, <b>details.duration AS \"Duration\"</b>\n  FROM better_dream_journal, better_dream_journal.details\nWHERE\n  <b>details.KEY IN ('Anxiety', 'Nightmare')</b>\n  AND <b>details.duration &gt; 60</b>\n  AND <b>details.woke_up = TRUE</b>;\n</div></div></div></div><div id=\"complex_types_etl\"><div class=\"hue-doc-title\">Loading Data Containing Complex Types</div><div><p>\n          Because the Impala <span class=\"hue-doc-codeph\">INSERT</span> statement does not currently support creating new data with complex type columns, or\n          copying existing complex type values from one table to another, you primarily use Impala to query Parquet tables with complex\n          types where the data was inserted through Hive, or create tables with complex types where you already have existing Parquet data\n          files.\n        </p><p>\n          If you have created a Hive table with the Parquet file format and containing complex types, use the same table for Impala queries\n          with no changes. If you have such a Hive table in some other format, use a Hive <span class=\"hue-doc-codeph\">CREATE TABLE AS SELECT ... STORED AS\n          PARQUET</span> or <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement to produce an equivalent Parquet table that Impala can query.\n        </p><p>\n          If you have existing Parquet data files containing complex types, located outside of any Impala or Hive table, such as data files\n          created by Spark jobs, you can use an Impala <span class=\"hue-doc-codeph\">CREATE TABLE ... STORED AS PARQUET</span> statement, followed by an Impala\n          <span class=\"hue-doc-codeph\">LOAD DATA</span> statement to move the data files into the table. As an alternative, you can use an Impala\n          <span class=\"hue-doc-codeph\">CREATE EXTERNAL TABLE</span> statement to create a table pointing to the HDFS directory that already contains the data\n          files.\n        </p><p>\n          Perhaps the simplest way to get started with complex type data is to take a denormalized table containing duplicated values, and\n          use an <span class=\"hue-doc-codeph\">INSERT ... SELECT</span> statement to copy the data into a Parquet table and condense the repeated values into\n          complex types. With the Hive <span class=\"hue-doc-codeph\">INSERT</span> statement, you use the <span class=\"hue-doc-codeph\">COLLECT_LIST()</span>,\n          <span class=\"hue-doc-codeph\">NAMED_STRUCT()</span>, and <span class=\"hue-doc-codeph\">MAP()</span> constructor functions within a <span class=\"hue-doc-codeph\">GROUP BY</span> query to\n          produce the complex type values. <span class=\"hue-doc-codeph\">COLLECT_LIST()</span> turns a sequence of values into an <span class=\"hue-doc-codeph\">ARRAY</span>.\n          <span class=\"hue-doc-codeph\">NAMED_STRUCT()</span> uses the first, third, and so on arguments as the field names for a <span class=\"hue-doc-codeph\">STRUCT</span>, to\n          match the field names from the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement.\n        </p><div class=\"hue-doc-note\">          Because Hive currently cannot construct individual rows using complex types through the <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> syntax,\n          you prepare the data in flat form in a separate table, then copy it to the table with complex columns using <span class=\"hue-doc-codeph\">INSERT ...\n          SELECT</span> and the complex type constructors. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types_ex_hive_etl\">Constructing Parquet Files with Complex Columns Using Hive</a> for\n          examples.\n        </div></div></div><div id=\"complex_types_nesting\"><div class=\"hue-doc-title\">Using Complex Types as Nested Types</div><div><p>\n          The <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, and <span class=\"hue-doc-codeph\">MAP</span> types can be the top-level types for <q>nested\n          type</q> columns. That is, each of these types can contain other complex or scalar types, with multiple levels of nesting to a\n          maximum depth of 100. For example, you can have an array of structures, a map containing other maps, a structure containing an\n          array of other structures, and so on. At the lowest level, there are always scalar types making up the fields of a\n          <span class=\"hue-doc-codeph\">STRUCT</span>, elements of an <span class=\"hue-doc-codeph\">ARRAY</span>, and keys and values of a <span class=\"hue-doc-codeph\">MAP</span>.\n        </p><p>\n          Schemas involving complex types typically use some level of nesting for the complex type columns.\n        </p><p>\n          For example, to model a relationship like a dimension table and a fact table, you typically use an <span class=\"hue-doc-codeph\">ARRAY</span> where\n          each array element is a <span class=\"hue-doc-codeph\">STRUCT</span>. The <span class=\"hue-doc-codeph\">STRUCT</span> fields represent what would traditionally be columns\n          in a separate joined table. It makes little sense to use a <span class=\"hue-doc-codeph\">STRUCT</span> as the top-level type for a column, because you\n          could just make the fields of the <span class=\"hue-doc-codeph\">STRUCT</span> into regular table columns.\n        </p><p>\n          Perhaps the only use case for a top-level <span class=\"hue-doc-codeph\">STRUCT</span> would be to to allow <span class=\"hue-doc-codeph\">STRUCT</span> fields with the\n          same name as columns to coexist in the same table. The following example shows how a table could have a column named\n          <span class=\"hue-doc-codeph\">ID</span>, and two separate <span class=\"hue-doc-codeph\">STRUCT</span> fields also named <span class=\"hue-doc-codeph\">ID</span>. Because the\n          <span class=\"hue-doc-codeph\">STRUCT</span> fields are always referenced using qualified names, the identical <span class=\"hue-doc-codeph\">ID</span> names do not cause a\n          conflict.\n        </p><div class=\"hue-doc-codeblock\">CREATE TABLE struct_namespaces\n(\n  id BIGINT\n  , s1 STRUCT &lt; id: BIGINT, field1: STRING &gt;\n  , s2 STRUCT &lt; id: BIGINT, when_happened: TIMESTAMP &gt;\n)\nSTORED AS PARQUET;\n\nselect id, s1.id, s2.id from struct_namespaces;\n</div><p>\n          It is common to make the value portion of each key-value pair in a <span class=\"hue-doc-codeph\">MAP</span> a <span class=\"hue-doc-codeph\">STRUCT</span>,\n          <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span>, or other complex type variation. That way, each key in the <span class=\"hue-doc-codeph\">MAP</span>\n          can be associated with a flexible and extensible data structure. The key values are not predefined ahead of time (other than by\n          specifying their data type). Therefore, the <span class=\"hue-doc-codeph\">MAP</span> can accomodate a rapidly evolving schema, or sparse data\n          structures where each row contains only a few data values drawn from a large set of possible choices.\n        </p><p>\n          Although you can use an <span class=\"hue-doc-codeph\">ARRAY</span> of scalar values as the top-level column in a table, such a simple array is\n          typically of limited use for analytic queries. The only property of the array elements, aside from the element value, is the\n          ordering sequence available through the <span class=\"hue-doc-codeph\">POS</span> pseudocolumn. To record any additional item about each array element,\n          such as a <span class=\"hue-doc-codeph\">TIMESTAMP</span> or a symbolic name, you use an <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span> rather than\n          of scalar values.\n        </p><p>\n          If you are considering having multiple <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span> columns, with related items under the same\n          position in each <span class=\"hue-doc-codeph\">ARRAY</span> or the same key in each <span class=\"hue-doc-codeph\">MAP</span>, prefer to use a <span class=\"hue-doc-codeph\">STRUCT</span> to\n          group all the related items into a single <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span>. Doing so avoids the additional storage\n          overhead and potential duplication of key values from having an extra complex type column. Also, because each\n          <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span> that you reference in the query <span class=\"hue-doc-codeph\">SELECT</span> list requires an additional\n          join clause, minimizing the number of complex type columns also makes the query easier to read and maintain, relying more on dot\n          notation to refer to the relevant fields rather than a sequence of join clauses.\n        </p><p>\n          For example, here is a table with several complex type columns all at the top level and containing only scalar types. To retrieve\n          every data item for the row requires a separate join for each <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span> column. The fields of\n          the <span class=\"hue-doc-codeph\">STRUCT</span> can be referenced using dot notation, but there is no real advantage to using the\n          <span class=\"hue-doc-codeph\">STRUCT</span> at the top level rather than just making separate columns <span class=\"hue-doc-codeph\">FIELD1</span> and\n          <span class=\"hue-doc-codeph\">FIELD2</span>.\n        </p><div class=\"hue-doc-codeblock\">CREATE TABLE complex_types_top_level\n(\n  id BIGINT,\n  a1 ARRAY&lt;INT&gt;,\n  a2 ARRAY&lt;STRING&gt;,\n  s STRUCT&lt;field1: INT, field2: STRING&gt;,\n-- Numeric lookup key for a string value.\n  m1 MAP&lt;INT,STRING&gt;,\n-- String lookup key for a numeric value.\n  m2 MAP&lt;STRING,INT&gt;\n)\nSTORED AS PARQUET;\n\ndescribe complex_types_top_level;\n+------+-----------------+\n| name | type            |\n+------+-----------------+\n| id   | bigint          |\n| a1   | array&lt;int&gt;      |\n| a2   | array&lt;string&gt;   |\n| s    | struct&lt;         |\n|      |   field1:int,   |\n|      |   field2:string |\n|      | &gt;               |\n| m1   | map&lt;int,string&gt; |\n| m2   | map&lt;string,int&gt; |\n+------+-----------------+\n\nselect\n  id,\n  a1.item,\n  a2.item,\n  s.field1,\n  s.field2,\n  m1.key,\n  m1.value,\n  m2.key,\n  m2.value\nfrom\n  complex_types_top_level,\n  complex_types_top_level.a1,\n  complex_types_top_level.a2,\n  complex_types_top_level.m1,\n  complex_types_top_level.m2;\n</div><p>\n          For example, here is a table with columns containing an <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span>, a <span class=\"hue-doc-codeph\">MAP</span>\n          where each key value is a <span class=\"hue-doc-codeph\">STRUCT</span>, and a <span class=\"hue-doc-codeph\">MAP</span> where each key value is an <span class=\"hue-doc-codeph\">ARRAY</span> of\n          <span class=\"hue-doc-codeph\">STRUCT</span>.\n        </p><div class=\"hue-doc-codeblock\">CREATE TABLE nesting_demo\n(\n  user_id BIGINT,\n  family_members ARRAY &lt; STRUCT &lt; name: STRING, email: STRING, date_joined: TIMESTAMP &gt;&gt;,\n  foo map &lt; STRING, STRUCT &lt; f1: INT, f2: INT, f3: TIMESTAMP, f4: BOOLEAN &gt;&gt;,\n  gameplay MAP &lt; STRING , ARRAY &lt; STRUCT &lt;\n    name: STRING, highest: BIGINT, lives_used: INT, total_spent: DECIMAL(16,2)\n  &gt;&gt;&gt;\n)\nSTORED AS PARQUET;\n</div><p>\n          The <span class=\"hue-doc-codeph\">DESCRIBE</span> statement rearranges the <span class=\"hue-doc-codeph\">&lt;</span> and <span class=\"hue-doc-codeph\">&gt;</span> separators and the field\n          names within each <span class=\"hue-doc-codeph\">STRUCT</span> for easy readability:\n        </p><div class=\"hue-doc-codeblock\">DESCRIBE nesting_demo;\n+----------------+-----------------------------+\n| name           | type                        |\n+----------------+-----------------------------+\n| user_id        | bigint                      |\n| family_members | array&lt;struct&lt;               |\n|                |   name:string,              |\n|                |   email:string,             |\n|                |   date_joined:timestamp     |\n|                | &gt;&gt;                          |\n| foo            | map&lt;string,struct&lt;          |\n|                |   f1:int,                   |\n|                |   f2:int,                   |\n|                |   f3:timestamp,             |\n|                |   f4:boolean                |\n|                | &gt;&gt;                          |\n| gameplay       | map&lt;string,array&lt;struct&lt;    |\n|                |   name:string,              |\n|                |   highest:bigint,           |\n|                |   lives_used:int,           |\n|                |   total_spent:decimal(16,2) |\n|                | &gt;&gt;&gt;                         |\n+----------------+-----------------------------+\n</div><p>\n          To query the complex type columns, you use join notation to refer to the lowest-level scalar values. If the value is an\n          <span class=\"hue-doc-codeph\">ARRAY</span> element, the fully qualified name includes the <span class=\"hue-doc-codeph\">ITEM</span> pseudocolumn. If the value is inside a\n          <span class=\"hue-doc-codeph\">MAP</span>, the fully qualified name includes the <span class=\"hue-doc-codeph\">KEY</span> or <span class=\"hue-doc-codeph\">VALUE</span> pseudocolumn. Each\n          reference to a different <span class=\"hue-doc-codeph\">ARRAY</span> or <span class=\"hue-doc-codeph\">MAP</span> (even if nested inside another complex type) requires an\n          additional join clause.\n        </p><div class=\"hue-doc-codeblock\">SELECT\n-- The lone scalar field doesn't require any dot notation or join clauses.\n    user_id\n-- Retrieve the fields of a STRUCT inside an ARRAY.\n-- The FAMILY_MEMBERS name refers to the FAMILY_MEMBERS table alias defined later in the FROM clause.\n  , family_members.item.name\n  , family_members.item.email\n  , family_members.item.date_joined\n-- Retrieve the KEY and VALUE fields of a MAP, with the value being a STRUCT consisting of more fields.\n-- The FOO name refers to the FOO table alias defined later in the FROM clause.\n  , foo.key\n  , foo.value.f1\n  , foo.value.f2\n  , foo.value.f3\n  , foo.value.f4\n-- Retrieve the KEY fields of a MAP, and expand the VALUE part into ARRAY items consisting of STRUCT fields.\n-- The GAMEPLAY name refers to the GAMEPLAY table alias defined later in the FROM clause (referring to the MAP item).\n-- The GAME_N name refers to the GAME_N table alias defined later in the FROM clause (referring to the ARRAY\n-- inside the MAP item's VALUE part.)\n  , gameplay.key\n  , game_n.name\n  , game_n.highest\n  , game_n.lives_used\n  , game_n.total_spent\nFROM\n    nesting_demo\n  , nesting_demo.family_members AS family_members\n  , nesting_demo.foo AS foo\n  , nesting_demo.gameplay AS gameplay\n  , nesting_demo.gameplay.value AS game_n;\n</div><p>\n          Once you understand the notation to refer to a particular data item in the <span class=\"hue-doc-codeph\">SELECT</span> list, you can use the same\n          qualified name to refer to that data item in other parts of the query, such as the <span class=\"hue-doc-codeph\">WHERE</span> clause, <span class=\"hue-doc-codeph\">ORDER\n          BY</span> or <span class=\"hue-doc-codeph\">GROUP BY</span> clauses, or calls to built-in functions. For example, you might frequently retrieve the\n          <span class=\"hue-doc-codeph\">VALUE</span> part of each <span class=\"hue-doc-codeph\">MAP</span> item in the <span class=\"hue-doc-codeph\">SELECT</span> list, while choosing the specific\n          <span class=\"hue-doc-codeph\">MAP</span> items by running comparisons against the <span class=\"hue-doc-codeph\">KEY</span> part in the <span class=\"hue-doc-codeph\">WHERE</span> clause.\n        </p></div></div><div id=\"complex_types_views\"><div class=\"hue-doc-title\">Accessing Complex Type Data in Flattened Form Using Views</div><div><p>\n          The layout of complex and nested types is largely a physical consideration. The complex type columns reside in the same data files\n          rather than in separate normalized tables, for your convenience in managing related data sets and performance in querying related\n          data sets. You can use views to treat tables with complex types as if they were flattened. By putting the join logic and\n          references to the complex type columns in the view definition, you can query the same tables using existing queries intended for\n          tables containing only scalar columns. This technique also lets you use tables with complex types with BI tools that are not aware\n          of the data types and query notation for accessing complex type columns.\n        </p><p>\n          For example, the variation of the TPC-H schema containing complex types has a table <span class=\"hue-doc-codeph\">REGION</span>. This table has 5\n          rows, corresponding to 5 regions such as <span class=\"hue-doc-codeph\">NORTH AMERICA</span> and <span class=\"hue-doc-codeph\">AFRICA</span>. Each row has an\n          <span class=\"hue-doc-codeph\">ARRAY</span> column, where each array item is a <span class=\"hue-doc-codeph\">STRUCT</span> containing details about a country in that\n          region.\n        </p><div class=\"hue-doc-codeblock\">DESCRIBE region;\n+-------------+-------------------------+\n| name        | type                    |\n+-------------+-------------------------+\n| r_regionkey | smallint                |\n| r_name      | string                  |\n| r_comment   | string                  |\n| r_nations   | array&lt;struct&lt;           |\n|             |   n_nationkey:smallint, |\n|             |   n_name:string,        |\n|             |   n_comment:string      |\n|             | &gt;&gt;                      |\n+-------------+-------------------------+\n</div><p>\n          The same data could be represented in traditional denormalized form, as a single table where the information about each region is\n          repeated over and over, alongside the information about each country. The nested complex types let us avoid the repetition, while\n          still keeping the data in a single table rather than normalizing across multiple tables.\n        </p><p>\n          To use this table with a JDBC or ODBC application that expected scalar columns, we could create a view that represented the result\n          set as a set of scalar columns (three columns from the original table, plus three more from the <span class=\"hue-doc-codeph\">STRUCT</span> fields of\n          the array elements). In the following examples, any column with an <span class=\"hue-doc-codeph\">R_*</span> prefix is taken unchanged from the\n          original table, while any column with an <span class=\"hue-doc-codeph\">N_*</span> prefix is extracted from the <span class=\"hue-doc-codeph\">STRUCT</span> inside the\n          <span class=\"hue-doc-codeph\">ARRAY</span>.\n        </p><div class=\"hue-doc-codeblock\">CREATE VIEW region_view AS\n  SELECT\n    r_regionkey,\n    r_name,\n    r_comment,\n    array_field.item.n_nationkey AS n_nationkey,\n    array_field.item.n_name AS n_name,\n    array_field.n_comment AS n_comment\nFROM\n  region, region.r_nations AS array_field;\n</div><p>\n          Then we point the application queries at the view rather than the original table. From the perspective of the view, there are 25\n          rows in the result set, one for each nation in each region, and queries can refer freely to fields related to the region or the\n          nation.\n        </p><div class=\"hue-doc-codeblock\">-- Retrieve info such as the nation name from the original R_NATIONS array elements.\nselect n_name from region_view where r_name in ('EUROPE', 'ASIA');\n+----------------+\n| n_name         |\n+----------------+\n| UNITED KINGDOM |\n| RUSSIA         |\n| ROMANIA        |\n| GERMANY        |\n| FRANCE         |\n| VIETNAM        |\n| CHINA          |\n| JAPAN          |\n| INDONESIA      |\n| INDIA          |\n+----------------+\n\n-- UNITED STATES in AMERICA and UNITED KINGDOM in EUROPE.\nSELECT DISTINCT r_name FROM region_view WHERE n_name LIKE 'UNITED%';\n+---------+\n| r_name  |\n+---------+\n| AMERICA |\n| EUROPE  |\n+---------+\n\n-- For conciseness, we only list some view columns in the SELECT list.\n-- SELECT * would bring back all the data, unlike SELECT *\n-- queries on the original table with complex type columns.\nSELECT r_regionkey, r_name, n_nationkey, n_name FROM region_view LIMIT 7;\n+-------------+--------+-------------+----------------+\n| r_regionkey | r_name | n_nationkey | n_name         |\n+-------------+--------+-------------+----------------+\n| 3           | EUROPE | 23          | UNITED KINGDOM |\n| 3           | EUROPE | 22          | RUSSIA         |\n| 3           | EUROPE | 19          | ROMANIA        |\n| 3           | EUROPE | 7           | GERMANY        |\n| 3           | EUROPE | 6           | FRANCE         |\n| 2           | ASIA   | 21          | VIETNAM        |\n| 2           | ASIA   | 18          | CHINA          |\n+-------------+--------+-------------+----------------+\n</div></div></div></div><div id=\"complex_types_examples\"><div class=\"hue-doc-title\">Tutorials and Examples for Complex Types</div><div><p>\n        The following examples illustrate the query syntax for some common use cases involving complex type columns.\n      </p><p/></div><div id=\"complex_sample_schema\"><div class=\"hue-doc-title\">Sample Schema and Data for Experimenting with Impala Complex Types</div><div><p>\n          The tables used for earlier examples of complex type syntax are trivial ones with no actual data. The more substantial examples of\n          the complex type feature use these tables, adapted from the schema used for TPC-H testing:\n        </p><div class=\"hue-doc-codeblock\">SHOW TABLES;\n+----------+\n| name     |\n+----------+\n| customer |\n| part     |\n| region   |\n| supplier |\n+----------+\n\nDESCRIBE customer;\n+--------------+------------------------------------+\n| name         | type                               |\n+--------------+------------------------------------+\n| c_custkey    | bigint                             |\n| c_name       | string                             |\n| c_address    | string                             |\n| c_nationkey  | smallint                           |\n| c_phone      | string                             |\n| c_acctbal    | decimal(12,2)                      |\n| c_mktsegment | string                             |\n| c_comment    | string                             |\n| c_orders     | array&lt;struct&lt;                      |\n|              |   o_orderkey:bigint,               |\n|              |   o_orderstatus:string,            |\n|              |   o_totalprice:decimal(12,2),      |\n|              |   o_orderdate:string,              |\n|              |   o_orderpriority:string,          |\n|              |   o_clerk:string,                  |\n|              |   o_shippriority:int,              |\n|              |   o_comment:string,                |\n|              |   o_lineitems:array&lt;struct&lt;        |\n|              |     l_partkey:bigint,              |\n|              |     l_suppkey:bigint,              |\n|              |     l_linenumber:int,              |\n|              |     l_quantity:decimal(12,2),      |\n|              |     l_extendedprice:decimal(12,2), |\n|              |     l_discount:decimal(12,2),      |\n|              |     l_tax:decimal(12,2),           |\n|              |     l_returnflag:string,           |\n|              |     l_linestatus:string,           |\n|              |     l_shipdate:string,             |\n|              |     l_commitdate:string,           |\n|              |     l_receiptdate:string,          |\n|              |     l_shipinstruct:string,         |\n|              |     l_shipmode:string,             |\n|              |     l_comment:string               |\n|              |   &gt;&gt;                               |\n|              | &gt;&gt;                                 |\n+--------------+------------------------------------+\n\nDESCRIBE part;\n+---------------+---------------+\n| name          | type          |\n+---------------+---------------+\n| p_partkey     | bigint        |\n| p_name        | string        |\n| p_mfgr        | string        |\n| p_brand       | string        |\n| p_type        | string        |\n| p_size        | int           |\n| p_container   | string        |\n| p_retailprice | decimal(12,2) |\n| p_comment     | string        |\n+---------------+---------------+\n\nDESCRIBE region;\n+-------------+--------------------------------------------------------------------+\n| name        | type                                                               |\n+-------------+--------------------------------------------------------------------+\n| r_regionkey | smallint                                                           |\n| r_name      | string                                                             |\n| r_comment   | string                                                             |\n| r_nations   | array&lt;struct&lt;n_nationkey:smallint,n_name:string,n_comment:string&gt;&gt; |\n+-------------+--------------------------------------------------------------------+\n\nDESCRIBE supplier;\n+-------------+----------------------------------------------+\n| name        | type                                         |\n+-------------+----------------------------------------------+\n| s_suppkey   | bigint                                       |\n| s_name      | string                                       |\n| s_address   | string                                       |\n| s_nationkey | smallint                                     |\n| s_phone     | string                                       |\n| s_acctbal   | decimal(12,2)                                |\n| s_comment   | string                                       |\n| s_partsupps | array&lt;struct&lt;ps_partkey:bigint,              |\n|             | ps_availqty:int,ps_supplycost:decimal(12,2), |\n|             | ps_comment:string&gt;&gt;                          |\n+-------------+----------------------------------------------+\n</div><p>\n          The volume of data used in the following examples is:\n        </p><div class=\"hue-doc-codeblock\">SELECT count(*) FROM customer;\n+----------+\n| count(*) |\n+----------+\n| 150000   |\n+----------+\n\nSELECT count(*) FROM part;\n+----------+\n| count(*) |\n+----------+\n| 200000   |\n+----------+\n\nSELECT count(*) FROM region;\n+----------+\n| count(*) |\n+----------+\n| 5        |\n+----------+\n\nSELECT count(*) FROM supplier;\n+----------+\n| count(*) |\n+----------+\n| 10000    |\n+----------+\n</div></div><div style=\"display:none;\" id=\"complex_python\"><div class=\"hue-doc-title\">Representing Python Data Types with Impala Complex Types</div><div><p>\n            If you use Python data types for data science computations or for convenience of manipulating data structures, you might think\n            of complex or nested data in terms of lists, tuples, and dictionaries and their textual representations. These types map well to\n            Impala complex types, as follows:\n          </p><ul><li><p>\n                An Impala <span class=\"hue-doc-codeph\">ARRAY</span> is like a Python list.\n              </p></li><li><p>\n                An Impala <span class=\"hue-doc-codeph\">STRUCT</span> is like a Python tuple. The elements of an Impala <span class=\"hue-doc-codeph\">STRUCT</span> are accessed by\n                name, rather than by numeric index as in Python.\n              </p></li><li><p>\n                An Impala <span class=\"hue-doc-codeph\">MAP</span> is like a Python dictionary. To emulate the Python <span class=\"hue-doc-codeph\">defaultdict</span> type, which\n                returns a default value in the case of non-existent elements, use an <span class=\"hue-doc-codeph\">OUTER JOIN</span> clause in the Impala query\n                that retrieves the <span class=\"hue-doc-codeph\">MAP</span> elements, and translate any <span class=\"hue-doc-codeph\">NULL</span> values corresponding to missing\n                elements using Impala conditional functions.\n              </p></li></ul></div></div></div><div style=\"display:none;\" id=\"complex_types_ex_aggregation\"><div class=\"hue-doc-title\">Aggregating the Elements in an ARRAY</div><div><p/><div class=\"hue-doc-codeblock\"/></div></div><div style=\"display:none;\" id=\"complex_types_ex_map_keys\"><div class=\"hue-doc-title\">Finding the Distinct Keys in a MAP</div><div><p/><div class=\"hue-doc-codeblock\"/></div></div><div style=\"display:none;\" id=\"complex_types_ex_map_struct\"><div class=\"hue-doc-title\">Using a STRUCT as the Value Part of a MAP</div><div><p/><div class=\"hue-doc-codeblock\"/></div></div><div id=\"complex_types_ex_hive_etl\"><div class=\"hue-doc-title\">Constructing Parquet Files with Complex Columns Using Hive</div><div><p>\n          The following examples demonstrate the Hive syntax to transform flat data (tables with all scalar columns) into Parquet tables\n          where Impala can query the complex type columns. Each example shows the full sequence of steps, including switching back and forth\n          between Impala and Hive. Although the source table can use any file format, the destination table must use the Parquet file\n          format.\n        </p><p><b>Create table with <span class=\"hue-doc-codeph\">ARRAY</span> in Impala, load data in Hive, query in Impala:</b></p><p>\n          This example shows the cycle of creating the tables and querying the complex data in Impala, and using Hive (either the\n          <span class=\"hue-doc-codeph\">hive</span> shell or <span class=\"hue-doc-codeph\">beeline</span>) for the data loading step. The data starts in flattened, denormalized\n          form in a text table. Hive writes the corresponding Parquet data, including an <span class=\"hue-doc-codeph\">ARRAY</span> column. Then Impala can run\n          analytic queries on the Parquet table, using join notation to unpack the <span class=\"hue-doc-codeph\">ARRAY</span> column.\n        </p><div class=\"hue-doc-codeblock\">/* Initial DDL and loading of flat, denormalized data happens in impala-shell */CREATE TABLE flat_array (country STRING, city STRING);INSERT INTO flat_array VALUES\n    ('Canada', 'Toronto') , ('Canada', 'Vancouver') , ('Canada', \"St. John\\'s\")\n  , ('Canada', 'Saint John') , ('Canada', 'Montreal') , ('Canada', 'Halifax')\n  , ('Canada', 'Winnipeg') , ('Canada', 'Calgary') , ('Canada', 'Saskatoon')\n  , ('Canada', 'Ottawa') , ('Canada', 'Yellowknife') , ('France', 'Paris')\n  , ('France', 'Nice') , ('France', 'Marseilles') , ('France', 'Cannes')\n  , ('Greece', 'Athens') , ('Greece', 'Piraeus') , ('Greece', 'Hania')\n  , ('Greece', 'Heraklion') , ('Greece', 'Rethymnon') , ('Greece', 'Fira');\n\nCREATE TABLE complex_array (country STRING, city ARRAY &lt;STRING&gt;) STORED AS PARQUET;\n</div><div class=\"hue-doc-codeblock\">/* Conversion to Parquet and complex and/or nested columns happens in Hive */\n\nINSERT INTO complex_array SELECT country, collect_list(city) FROM flat_array GROUP BY country;\nQuery ID = dev_20151108160808_84477ff2-82bd-4ba4-9a77-554fa7b8c0cb\nTotal jobs = 1\nLaunching Job 1 out of 1\n...\n</div><div class=\"hue-doc-codeblock\">/* Back to impala-shell again for analytic queries */\n\nREFRESH complex_array;\nSELECT country, city.item FROM complex_array, complex_array.city\n+---------+-------------+\n| country | item        |\n+---------+-------------+\n| Canada  | Toronto     |\n| Canada  | Vancouver   |\n| Canada  | St. John's  |\n| Canada  | Saint John  |\n| Canada  | Montreal    |\n| Canada  | Halifax     |\n| Canada  | Winnipeg    |\n| Canada  | Calgary     |\n| Canada  | Saskatoon   |\n| Canada  | Ottawa      |\n| Canada  | Yellowknife |\n| France  | Paris       |\n| France  | Nice        |\n| France  | Marseilles  |\n| France  | Cannes      |\n| Greece  | Athens      |\n| Greece  | Piraeus     |\n| Greece  | Hania       |\n| Greece  | Heraklion   |\n| Greece  | Rethymnon   |\n| Greece  | Fira        |\n+---------+-------------+\n</div><p><b>Create table with <span class=\"hue-doc-codeph\">STRUCT</span> and <span class=\"hue-doc-codeph\">ARRAY</span> in Impala, load data in Hive, query in Impala:</b></p><p>\n          This example shows the cycle of creating the tables and querying the complex data in Impala, and using Hive (either the\n          <span class=\"hue-doc-codeph\">hive</span> shell or <span class=\"hue-doc-codeph\">beeline</span>) for the data loading step. The data starts in flattened, denormalized\n          form in a text table. Hive writes the corresponding Parquet data, including a <span class=\"hue-doc-codeph\">STRUCT</span> column with an\n          <span class=\"hue-doc-codeph\">ARRAY</span> field. Then Impala can run analytic queries on the Parquet table, using join notation to unpack the\n          <span class=\"hue-doc-codeph\">ARRAY</span> field from the <span class=\"hue-doc-codeph\">STRUCT</span> column.\n        </p><div class=\"hue-doc-codeblock\">/* Initial DDL and loading of flat, denormalized data happens in impala-shell */\n\nCREATE TABLE flat_struct_array (continent STRING, country STRING, city STRING);\nINSERT INTO flat_struct_array VALUES\n    ('North America', 'Canada', 'Toronto') , ('North America', 'Canada', 'Vancouver')\n  , ('North America', 'Canada', \"St. John\\'s\") , ('North America', 'Canada', 'Saint John')\n  , ('North America', 'Canada', 'Montreal') , ('North America', 'Canada', 'Halifax')\n  , ('North America', 'Canada', 'Winnipeg') , ('North America', 'Canada', 'Calgary')\n  , ('North America', 'Canada', 'Saskatoon') , ('North America', 'Canada', 'Ottawa')\n  , ('North America', 'Canada', 'Yellowknife') , ('Europe', 'France', 'Paris')\n  , ('Europe', 'France', 'Nice') , ('Europe', 'France', 'Marseilles')\n  , ('Europe', 'France', 'Cannes') , ('Europe', 'Greece', 'Athens')\n  , ('Europe', 'Greece', 'Piraeus') , ('Europe', 'Greece', 'Hania')\n  , ('Europe', 'Greece', 'Heraklion') , ('Europe', 'Greece', 'Rethymnon')\n  , ('Europe', 'Greece', 'Fira');\n\nCREATE TABLE complex_struct_array (continent STRING, country STRUCT &lt;name: STRING, city: ARRAY &lt;STRING&gt; &gt;) STORED AS PARQUET;\n</div><div class=\"hue-doc-codeblock\">/* Conversion to Parquet and complex and/or nested columns happens in Hive */\n\nINSERT INTO complex_struct_array SELECT continent, named_struct('name', country, 'city', collect_list(city)) FROM flat_array_array GROUP BY continent, country;\nQuery ID = dev_20151108163535_11a4fa53-0003-4638-97e6-ef13cdb8e09e\nTotal jobs = 1\nLaunching Job 1 out of 1\n...\n</div><div class=\"hue-doc-codeblock\">/* Back to impala-shell again for analytic queries */\n\nREFRESH complex_struct_array;\nSELECT t1.continent, t1.country.name, t2.item\n  FROM complex_struct_array t1, t1.country.city t2\n+---------------+--------------+-------------+\n| continent     | country.name | item        |\n+---------------+--------------+-------------+\n| Europe        | France       | Paris       |\n| Europe        | France       | Nice        |\n| Europe        | France       | Marseilles  |\n| Europe        | France       | Cannes      |\n| Europe        | Greece       | Athens      |\n| Europe        | Greece       | Piraeus     |\n| Europe        | Greece       | Hania       |\n| Europe        | Greece       | Heraklion   |\n| Europe        | Greece       | Rethymnon   |\n| Europe        | Greece       | Fira        |\n| North America | Canada       | Toronto     |\n| North America | Canada       | Vancouver   |\n| North America | Canada       | St. John's  |\n| North America | Canada       | Saint John  |\n| North America | Canada       | Montreal    |\n| North America | Canada       | Halifax     |\n| North America | Canada       | Winnipeg    |\n| North America | Canada       | Calgary     |\n| North America | Canada       | Saskatoon   |\n| North America | Canada       | Ottawa      |\n| North America | Canada       | Yellowknife |\n+---------------+--------------+-------------+\n</div></div></div><div style=\"display:none;\" id=\"complex_types_no_joins\"><div class=\"hue-doc-title\">Using Complex Types without Join Queries</div><div><p>\n          Although most discussion and examples of complex types revolve around join queries, you can make use of complex columns without\n          joins. In these cases, you refer to the complex object (possibly nested under multiple levels of other complex types) as the only\n          <q>table</q> in the <span class=\"hue-doc-codeph\">FROM</span> clause, and the columns of this table are the scalar values named <span class=\"hue-doc-codeph\">POS</span>\n          (for <span class=\"hue-doc-codeph\">ARRAY</span>), <span class=\"hue-doc-codeph\">ITEM</span> (for <span class=\"hue-doc-codeph\">ARRAY</span> of scalar values), <span class=\"hue-doc-codeph\">KEY</span> (for\n          <span class=\"hue-doc-codeph\">MAP</span>), <span class=\"hue-doc-codeph\">VALUE</span> (for <span class=\"hue-doc-codeph\">MAP</span> with scalar values), and the names of\n          <span class=\"hue-doc-codeph\">STRUCT</span> fields (where the <span class=\"hue-doc-codeph\">ARRAY</span> element or <span class=\"hue-doc-codeph\">MAP</span> value is a\n          <span class=\"hue-doc-codeph\">STRUCT</span>).\n        </p><p>\n          This technique lets you use aggregation operation such as <span class=\"hue-doc-codeph\">COUNT()</span>, <span class=\"hue-doc-codeph\">SUM()</span>,\n          <span class=\"hue-doc-codeph\">MAX()</span>, or <span class=\"hue-doc-codeph\">DISTINCT</span> across all the data items from a complex type, across all rows of the table.\n          For users new to complex types, this can be a good practice exercise to understand the notation for referring to data items within\n          deeply nested types, and how the pseudocolumns such as <span class=\"hue-doc-codeph\">POS</span> and <span class=\"hue-doc-codeph\">KEY</span> are treated as columns\n          alongside the fields of a <span class=\"hue-doc-codeph\">STRUCT</span>.\n        </p><div class=\"hue-doc-note\" id=\"complex_type_schema_pointer\">      Many of the complex type examples refer to tables\n      such as <span class=\"hue-doc-codeph\">CUSTOMER</span> and <span class=\"hue-doc-codeph\">REGION</span>\n      adapted from the tables used in the TPC-H benchmark.\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_sample_schema\">Sample Schema and Data for Experimenting with Impala Complex Types</a>\n      for the table definitions.\n      </div><p>\n          For example, these queries perform aggregate functions using the <span class=\"hue-doc-codeph\">CUSTOMER</span> table from the <q>nested TPC-H</q>\n          schema:\n        </p><div class=\"hue-doc-codeblock\"/></div></div><div id=\"complex_denormalizing\"><div class=\"hue-doc-title\">Flattening Normalized Tables into a Single Table with Complex Types</div><div><p>\n          One common use for complex types is to embed the contents of one table into another. The traditional technique of denormalizing\n          results in a huge number of rows with some column values repeated over and over. With complex types, you can keep the same number\n          of rows as in the original normalized table, and put all the associated data from the other table in a single new column.\n        </p><p>\n          In this flattening scenario, you might frequently use a column that is an <span class=\"hue-doc-codeph\">ARRAY</span> consisting of\n          <span class=\"hue-doc-codeph\">STRUCT</span> elements, where each field within the <span class=\"hue-doc-codeph\">STRUCT</span> corresponds to a column name from the table\n          that you are combining.\n        </p><p>\n          The following example shows a traditional normalized layout using two tables, and then an equivalent layout using complex types in\n          a single table.\n        </p><div class=\"hue-doc-codeblock\">/* Traditional relational design */\n\n-- This table just stores numbers, allowing us to look up details about the employee\n-- and details about their vacation time using a three-table join query.\nCREATE table employee_vacations\n(\n  employee_id BIGINT,\n  vacation_id BIGINT\n)\nSTORED AS PARQUET;\n\n-- Each kind of information to track gets its own \"fact table\".\nCREATE table vacation_details\n(\n  vacation_id BIGINT,\n  vacation_start TIMESTAMP,\n  duration INT\n)\nSTORED AS PARQUET;\n\n-- Any time we print a human-readable report, we join with this table to\n-- display info about employee #1234.\nCREATE TABLE employee_contact\n(\n  employee_id BIGINT,\n  name STRING,\n  address STRING,\n  phone STRING,\n  email STRING,\n  address_type STRING /* 'home', 'work', 'remote', etc. */\n)\nSTORED AS PARQUET;\n\n/* Equivalent flattened schema using complex types */\n\n-- For analytic queries using complex types, we can bundle the dimension table\n-- and multiple fact tables into a single table.\nCREATE TABLE employee_vacations_nested_types\n(\n-- We might still use the employee_id for other join queries.\n-- The table needs at least one scalar column to serve as an identifier\n-- for the complex type columns.\n  employee_id BIGINT,\n\n-- Columns of the VACATION_DETAILS table are folded into a STRUCT.\n-- We drop the VACATION_ID column because Impala doesn't need\n-- synthetic IDs to join a complex type column.\n-- Each row from the VACATION_DETAILS table becomes an array element.\n  vacation ARRAY &lt; STRUCT &lt;\n    vacation_start: TIMESTAMP,\n    duration: INT\n  &gt;&gt;,\n\n-- The ADDRESS_TYPE column, with a small number of predefined values that are distinct\n-- for each employee, makes the EMPLOYEE_CONTACT table a good candidate to turn into a MAP,\n-- with each row represented as a STRUCT. The string value from ADDRESS_TYPE becomes the\n-- \"key\" (the anonymous first field) of the MAP.\n  contact MAP &lt; STRING, STRUCT &lt;\n    address: STRING,\n    phone: STRING,\n    email: STRING\n  &gt;&gt;\n)\nSTORED AS PARQUET;\n</div></div></div><div id=\"complex_inference\"><div class=\"hue-doc-title\">Interchanging Complex Type Tables and Data Files with Hive and Other Components</div><div><p>\n          You can produce Parquet data files through several Hadoop components and APIs.\n        </p><p>\n          If you have a Hive-created Parquet table that includes <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span>\n          columns, Impala can query that same table in Impala 2.3 and higher, subject to the usual restriction that all other\n          columns are of data types supported by Impala, and also that the file type of the table must be Parquet.\n        </p><p>\n          If you have a Parquet data file produced outside of Impala, Impala can automatically deduce the appropriate table structure using\n          the syntax <span class=\"hue-doc-codeph\">CREATE TABLE ... LIKE PARQUET '<span class=\"hue-doc-varname\">hdfs_path_of_parquet_file</span>'</span>. In Impala 2.3\n          and higher, this feature works for Parquet files that include <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, or\n          <span class=\"hue-doc-codeph\">MAP</span> types.\n        </p><div class=\"hue-doc-codeblock\">/* In impala-shell, find the HDFS data directory of the original table.\nDESCRIBE FORMATTED tpch_nested_parquet.customer;\n...\n| Location: | hdfs://localhost:20500/test-warehouse/tpch_nested_parquet.db/customer   | NULL |\n...\n\n# In the Unix shell, find the path of any Parquet data file in that HDFS directory.\n$ hdfs dfs -ls hdfs://localhost:20500/test-warehouse/tpch_nested_parquet.db/customer\nFound 4 items\n-rwxr-xr-x   3 dev supergroup  171298918 2015-09-22 23:30 hdfs://localhost:20500/blah/tpch_nested_parquet.db/customer/000000_0\n...\n\n/* Back in impala-shell, use the HDFS path in a CREATE TABLE LIKE PARQUET statement. */\nCREATE TABLE customer_ctlp\n  LIKE PARQUET 'hdfs://localhost:20500/blah/tpch_nested_parquet.db/customer/000000_0'\n  STORED AS PARQUET;\n\n/* Confirm that old and new tables have the same column layout, including complex types. */\nDESCRIBE tpch_nested_parquet.customer\n+--------------+------------------------------------+---------+\n| name         | type                               | comment |\n+--------------+------------------------------------+---------+\n| c_custkey    | bigint                             |         |\n| c_name       | string                             |         |\n| c_address    | string                             |         |\n| c_nationkey  | smallint                           |         |\n| c_phone      | string                             |         |\n| c_acctbal    | decimal(12,2)                      |         |\n| c_mktsegment | string                             |         |\n| c_comment    | string                             |         |\n| c_orders     | array&lt;struct&lt;                      |         |\n|              |   o_orderkey:bigint,               |         |\n|              |   o_orderstatus:string,            |         |\n|              |   o_totalprice:decimal(12,2),      |         |\n|              |   o_orderdate:string,              |         |\n|              |   o_orderpriority:string,          |         |\n|              |   o_clerk:string,                  |         |\n|              |   o_shippriority:int,              |         |\n|              |   o_comment:string,                |         |\n|              |   o_lineitems:array&lt;struct&lt;        |         |\n|              |     l_partkey:bigint,              |         |\n|              |     l_suppkey:bigint,              |         |\n|              |     l_linenumber:int,              |         |\n|              |     l_quantity:decimal(12,2),      |         |\n|              |     l_extendedprice:decimal(12,2), |         |\n|              |     l_discount:decimal(12,2),      |         |\n|              |     l_tax:decimal(12,2),           |         |\n|              |     l_returnflag:string,           |         |\n|              |     l_linestatus:string,           |         |\n|              |     l_shipdate:string,             |         |\n|              |     l_commitdate:string,           |         |\n|              |     l_receiptdate:string,          |         |\n|              |     l_shipinstruct:string,         |         |\n|              |     l_shipmode:string,             |         |\n|              |     l_comment:string               |         |\n|              |   &gt;&gt;                               |         |\n|              | &gt;&gt;                                 |         |\n+--------------+------------------------------------+---------+\n\ndescribe customer_ctlp;\n+--------------+------------------------------------+-----------------------------+\n| name         | type                               | comment                     |\n+--------------+------------------------------------+-----------------------------+\n| c_custkey    | bigint                             | Inferred from Parquet file. |\n| c_name       | string                             | Inferred from Parquet file. |\n| c_address    | string                             | Inferred from Parquet file. |\n| c_nationkey  | int                                | Inferred from Parquet file. |\n| c_phone      | string                             | Inferred from Parquet file. |\n| c_acctbal    | decimal(12,2)                      | Inferred from Parquet file. |\n| c_mktsegment | string                             | Inferred from Parquet file. |\n| c_comment    | string                             | Inferred from Parquet file. |\n| c_orders     | array&lt;struct&lt;                      | Inferred from Parquet file. |\n|              |   o_orderkey:bigint,               |                             |\n|              |   o_orderstatus:string,            |                             |\n|              |   o_totalprice:decimal(12,2),      |                             |\n|              |   o_orderdate:string,              |                             |\n|              |   o_orderpriority:string,          |                             |\n|              |   o_clerk:string,                  |                             |\n|              |   o_shippriority:int,              |                             |\n|              |   o_comment:string,                |                             |\n|              |   o_lineitems:array&lt;struct&lt;        |                             |\n|              |     l_partkey:bigint,              |                             |\n|              |     l_suppkey:bigint,              |                             |\n|              |     l_linenumber:int,              |                             |\n|              |     l_quantity:decimal(12,2),      |                             |\n|              |     l_extendedprice:decimal(12,2), |                             |\n|              |     l_discount:decimal(12,2),      |                             |\n|              |     l_tax:decimal(12,2),           |                             |\n|              |     l_returnflag:string,           |                             |\n|              |     l_linestatus:string,           |                             |\n|              |     l_shipdate:string,             |                             |\n|              |     l_commitdate:string,           |                             |\n|              |     l_receiptdate:string,          |                             |\n|              |     l_shipinstruct:string,         |                             |\n|              |     l_shipmode:string,             |                             |\n|              |     l_comment:string               |                             |\n|              |   &gt;&gt;                               |                             |\n|              | &gt;&gt;                                 |                             |\n+--------------+------------------------------------+-----------------------------+\n</div></div></div></div></div></div>","title":"Complex Types (Impala 2.3 or higher only)"}