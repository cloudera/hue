{"body":"<div><div id=\"perf_joins\"><div class=\"hue-doc-title\">Performance Considerations for Join Queries</div><div><p>\n      Queries involving join operations often require more tuning than queries that refer to only one table. The\n      maximum size of the result set from a join query is the product of the number of rows in all the joined\n      tables. When joining several tables with millions or billions of rows, any missed opportunity to filter the\n      result set, or other inefficiency in the query, could lead to an operation that does not finish in a\n      practical time and has to be cancelled.\n    </p><p>\n      The simplest technique for tuning an Impala join query is to collect statistics on each table involved in the\n      join using the <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_compute_stats.xml\" data-doc-anchor-id=\"compute_stats\">COMPUTE STATS</a></span>\n      statement, and then let Impala automatically optimize the query based on the size of each table, number of\n      distinct values of each column, and so on. The <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement and the join\n      optimization are new features introduced in Impala 1.2.2. For accurate statistics about each table, issue the\n      <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement after loading the data into that table, and again if the amount of\n      data changes substantially due to an <span class=\"hue-doc-codeph\">INSERT</span>, <span class=\"hue-doc-codeph\">LOAD DATA</span>, adding a partition,\n      and so on.\n    </p><p>\n      If statistics are not available for all the tables in the join query, or if Impala chooses a join order that\n      is not the most efficient, you can override the automatic join order optimization by specifying the\n      <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> keyword immediately after the <span class=\"hue-doc-codeph\">SELECT</span> and any <span class=\"hue-doc-codeph\">DISTINCT</span>\n      or <span class=\"hue-doc-codeph\">ALL</span> keywords. In this case, Impala uses the order the tables appear in the query to guide how the\n      joins are processed.\n    </p><p>\n      When you use the <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> technique, you must order the tables in the join query\n      manually instead of relying on the Impala optimizer. The optimizer uses sophisticated techniques to estimate\n      the size of the result set at each stage of the join. For manual ordering, use this heuristic approach to\n      start with, and then experiment to fine-tune the order:\n    </p><ul><li>\n        Specify the largest table first. This table is read from disk by each Impala node and so its size is not\n        significant in terms of memory usage during the query.\n      </li><li>\n        Next, specify the smallest table. The contents of the second, third, and so on tables are all transmitted\n        across the network. You want to minimize the size of the result set from each subsequent stage of the join\n        query. The most likely approach involves joining a small table first, so that the result set remains small\n        even as subsequent larger tables are processed.\n      </li><li>\n        Join the next smallest table, then the next smallest, and so on.\n      </li></ul><p>\n        For example, if you had tables <span class=\"hue-doc-codeph\">BIG</span>, <span class=\"hue-doc-codeph\">MEDIUM</span>, <span class=\"hue-doc-codeph\">SMALL</span>, and\n        <span class=\"hue-doc-codeph\">TINY</span>, the logical join order to try would be <span class=\"hue-doc-codeph\">BIG</span>, <span class=\"hue-doc-codeph\">TINY</span>,\n        <span class=\"hue-doc-codeph\">SMALL</span>, <span class=\"hue-doc-codeph\">MEDIUM</span>.\n      </p><p>\n      The terms <q>largest</q> and <q>smallest</q> refers to the size of the intermediate result set based on the\n      number of rows and columns from each table that are part of the result set. For example, if you join one\n      table <span class=\"hue-doc-codeph\">sales</span> with another table <span class=\"hue-doc-codeph\">customers</span>, a query might find results from\n      100 different customers who made a total of 5000 purchases. In that case, you would specify <span class=\"hue-doc-codeph\">SELECT\n      ... FROM sales JOIN customers ...</span>, putting <span class=\"hue-doc-codeph\">customers</span> on the right side because it\n      is smaller in the context of this query.\n    </p><p>\n      The Impala query planner chooses between different techniques for performing join queries, depending on the\n      absolute and relative sizes of the tables. <b>Broadcast joins</b> are the default, where the right-hand table\n      is considered to be smaller than the left-hand table, and its contents are sent to all the other nodes\n      involved in the query. The alternative technique is known as a <b>partitioned join</b> (not related to a\n      partitioned table), which is more suitable for large tables of roughly equal size. With this technique,\n      portions of each table are sent to appropriate other nodes where those subsets of rows can be processed in\n      parallel. The choice of broadcast or partitioned join also depends on statistics being available for all\n      tables in the join, gathered by the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement.\n    </p><p>\n      To see which join strategy is used for a particular query, issue an <span class=\"hue-doc-codeph\">EXPLAIN</span> statement for\n      the query. If you find that a query uses a broadcast join when you know through benchmarking that a\n      partitioned join would be more efficient, or vice versa, add a hint to the query to specify the precise join\n      mechanism to use. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_hints.xml\" data-doc-anchor-id=\"hints\">Optimizer Hints</a> for details.\n    </p></div><div id=\"joins_no_stats\"><div class=\"hue-doc-title\">How Joins Are Processed when Statistics Are Unavailable</div><div><p>\n        If table or column statistics are not available for some tables in a join, Impala still reorders the tables\n        using the information that is available. Tables with statistics are placed on the left side of the join\n        order, in descending order of cost based on overall size and cardinality. Tables without statistics are\n        treated as zero-size, that is, they are always placed on the right side of the join order.\n      </p></div></div><div id=\"straight_join\"><div class=\"hue-doc-title\">Overriding Join Reordering with STRAIGHT_JOIN</div><div><p>\n        If an Impala join query is inefficient because of outdated statistics or unexpected data distribution, you\n        can keep Impala from reordering the joined tables by using the <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> keyword\n        immediately after the <span class=\"hue-doc-codeph\">SELECT</span> and any <span class=\"hue-doc-codeph\">DISTINCT</span> or <span class=\"hue-doc-codeph\">ALL</span>\n        keywords. The <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> keyword turns off\n        the reordering of join clauses that Impala does internally, and produces a plan that relies on the join\n        clauses being ordered optimally in the query text.\n      </p><div class=\"hue-doc-note\"><p id=\"straight_join_nested_queries\">\n        The <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> hint affects the join order of table references in\n        the query block containing the hint. It does not affect the join order of nested\n        queries, such as views, inline views, or <span class=\"hue-doc-codeph\">WHERE</span>-clause subqueries. To\n        use this hint for performance tuning of complex queries, apply the hint to all query\n        blocks that need a fixed join order.\n      </p></div><p>\n        In this example, the subselect from the <span class=\"hue-doc-codeph\">BIG</span> table produces a very small result set, but\n        the table might still be treated as if it were the biggest and placed first in the join order. Using\n        <span class=\"hue-doc-codeph\">STRAIGHT_JOIN</span> for the last join clause prevents the final table from being reordered,\n        keeping it as the rightmost table in the join order.\n      </p><div class=\"hue-doc-codeblock\">select straight_join x from medium join small join (select * from big where c1 &lt; 10) as big\n  where medium.id = small.id and small.id = big.id;\n\n-- If the query contains [DISTINCT | ALL], the hint goes after those keywords.\nselect distinct straight_join x from medium join small join (select * from big where c1 &lt; 10) as big\n  where medium.id = small.id and small.id = big.id;</div></div></div><div id=\"perf_joins_examples\"><div class=\"hue-doc-title\">Examples of Join Order Optimization</div><div><p>\n        Here are examples showing joins between tables with 1 billion, 200 million, and 1 million rows. (In this\n        case, the tables are unpartitioned and using Parquet format.) The smaller tables contain subsets of data\n        from the largest one, for convenience of joining on the unique <span class=\"hue-doc-codeph\">ID</span> column. The smallest\n        table only contains a subset of columns from the others.\n      </p><p/><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table big stored as parquet as select * from raw_data;\n+----------------------------+\n| summary                    |\n+----------------------------+\n| Inserted 1000000000 row(s) |\n+----------------------------+\nReturned 1 row(s) in 671.56s\n[localhost:21000] &gt; desc big;\n+-----------+---------+---------+\n| name      | type    | comment |\n+-----------+---------+---------+\n| id        | int     |         |\n| val       | int     |         |\n| zfill     | string  |         |\n| name      | string  |         |\n| assertion | boolean |         |\n+-----------+---------+---------+\nReturned 5 row(s) in 0.01s\n[localhost:21000] &gt; create table medium stored as parquet as select * from big limit 200 * floor(1e6);\n+---------------------------+\n| summary                   |\n+---------------------------+\n| Inserted 200000000 row(s) |\n+---------------------------+\nReturned 1 row(s) in 138.31s\n[localhost:21000] &gt; create table small stored as parquet as select id,val,name from big where assertion = true limit 1 * floor(1e6);\n+-------------------------+\n| summary                 |\n+-------------------------+\n| Inserted 1000000 row(s) |\n+-------------------------+\nReturned 1 row(s) in 6.32s</div><p>\n        For any kind of performance experimentation, use the <span class=\"hue-doc-codeph\">EXPLAIN</span> statement to see how any\n        expensive query will be performed without actually running it, and enable verbose <span class=\"hue-doc-codeph\">EXPLAIN</span>\n        plans containing more performance-oriented detail: The most interesting plan lines are highlighted in bold,\n        showing that without statistics for the joined tables, Impala cannot make a good estimate of the number of\n        rows involved at each stage of processing, and is likely to stick with the <span class=\"hue-doc-codeph\">BROADCAST</span> join\n        mechanism that sends a complete copy of one of the tables to each node.\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; set explain_level=verbose;\nEXPLAIN_LEVEL set to verbose\n[localhost:21000] &gt; explain select count(*) from big join medium where big.id = medium.id;\n+----------------------------------------------------------+\n| Explain String                                           |\n+----------------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=2.10GB VCores=2  |\n|                                                          |\n| PLAN FRAGMENT 0                                          |\n|   PARTITION: UNPARTITIONED                               |\n|                                                          |\n|   6:AGGREGATE (merge finalize)                           |\n|   |  output: SUM(COUNT(*))                               |\n|   |  cardinality: 1                                      |\n|   |  per-host memory: unavailable                        |\n|   |  tuple ids: 2                                        |\n|   |                                                      |\n|   5:EXCHANGE                                             |\n|      cardinality: 1                                      |\n|      per-host memory: unavailable                        |\n|      tuple ids: 2                                        |\n|                                                          |\n| PLAN FRAGMENT 1                                          |\n|   PARTITION: RANDOM                                      |\n|                                                          |\n|   STREAM DATA SINK                                       |\n|     EXCHANGE ID: 5                                       |\n|     UNPARTITIONED                                        |\n|                                                          |\n|   3:AGGREGATE                                            |\n|   |  output: COUNT(*)                                    |\n|   |  cardinality: 1                                      |\n|   |  per-host memory: 10.00MB                            |\n|   |  tuple ids: 2                                        |\n|   |                                                      |\n|   2:HASH JOIN                                            |\n<b>|   |  join op: INNER JOIN (BROADCAST)                     |</b>\n|   |  hash predicates:                                    |\n|   |    big.id = medium.id                                |\n<b>|   |  cardinality: unavailable                            |</b>\n|   |  per-host memory: 2.00GB                             |\n|   |  tuple ids: 0 1                                      |\n|   |                                                      |\n|   |----4:EXCHANGE                                        |\n|   |       cardinality: unavailable                       |\n|   |       per-host memory: 0B                            |\n|   |       tuple ids: 1                                   |\n|   |                                                      |\n|   0:SCAN HDFS                                            |\n<b>|      table=join_order.big #partitions=1/1 size=23.12GB   |\n|      table stats: unavailable                            |\n|      column stats: unavailable                           |\n|      cardinality: unavailable                            |</b>\n|      per-host memory: 88.00MB                            |\n|      tuple ids: 0                                        |\n|                                                          |\n| PLAN FRAGMENT 2                                          |\n|   PARTITION: RANDOM                                      |\n|                                                          |\n|   STREAM DATA SINK                                       |\n|     EXCHANGE ID: 4                                       |\n|     UNPARTITIONED                                        |\n|                                                          |\n|   1:SCAN HDFS                                            |\n<b>|      table=join_order.medium #partitions=1/1 size=4.62GB |\n|      table stats: unavailable                            |\n|      column stats: unavailable                           |\n|      cardinality: unavailable                            |</b>\n|      per-host memory: 88.00MB                            |\n|      tuple ids: 1                                        |\n+----------------------------------------------------------+\nReturned 64 row(s) in 0.04s</div><p>\n        Gathering statistics for all the tables is straightforward, one <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement\n        per table:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; compute stats small;\n+-----------------------------------------+\n| summary                                 |\n+-----------------------------------------+\n| Updated 1 partition(s) and 3 column(s). |\n+-----------------------------------------+\nReturned 1 row(s) in 4.26s\n[localhost:21000] &gt; compute stats medium;\n+-----------------------------------------+\n| summary                                 |\n+-----------------------------------------+\n| Updated 1 partition(s) and 5 column(s). |\n+-----------------------------------------+\nReturned 1 row(s) in 42.11s\n[localhost:21000] &gt; compute stats big;\n+-----------------------------------------+\n| summary                                 |\n+-----------------------------------------+\n| Updated 1 partition(s) and 5 column(s). |\n+-----------------------------------------+\nReturned 1 row(s) in 165.44s</div><p>\n        With statistics in place, Impala can choose a more effective join order rather than following the\n        left-to-right sequence of tables in the query, and can choose <span class=\"hue-doc-codeph\">BROADCAST</span> or\n        <span class=\"hue-doc-codeph\">PARTITIONED</span> join strategies based on the overall sizes and number of rows in the table:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; explain select count(*) from medium join big where big.id = medium.id;\nQuery: explain select count(*) from medium join big where big.id = medium.id\n+-----------------------------------------------------------+\n| Explain String                                            |\n+-----------------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=937.23MB VCores=2 |\n|                                                           |\n| PLAN FRAGMENT 0                                           |\n|   PARTITION: UNPARTITIONED                                |\n|                                                           |\n|   6:AGGREGATE (merge finalize)                            |\n|   |  output: SUM(COUNT(*))                                |\n|   |  cardinality: 1                                       |\n|   |  per-host memory: unavailable                         |\n|   |  tuple ids: 2                                         |\n|   |                                                       |\n|   5:EXCHANGE                                              |\n|      cardinality: 1                                       |\n|      per-host memory: unavailable                         |\n|      tuple ids: 2                                         |\n|                                                           |\n| PLAN FRAGMENT 1                                           |\n|   PARTITION: RANDOM                                       |\n|                                                           |\n|   STREAM DATA SINK                                        |\n|     EXCHANGE ID: 5                                        |\n|     UNPARTITIONED                                         |\n|                                                           |\n|   3:AGGREGATE                                             |\n|   |  output: COUNT(*)                                     |\n|   |  cardinality: 1                                       |\n|   |  per-host memory: 10.00MB                             |\n|   |  tuple ids: 2                                         |\n|   |                                                       |\n|   2:HASH JOIN                                             |\n|   |  join op: INNER JOIN (BROADCAST)                      |\n|   |  hash predicates:                                     |\n|   |    big.id = medium.id                                 |\n|   |  cardinality: 1443004441                              |\n|   |  per-host memory: 839.23MB                            |\n|   |  tuple ids: 1 0                                       |\n|   |                                                       |\n|   |----4:EXCHANGE                                         |\n|   |       cardinality: 200000000                          |\n|   |       per-host memory: 0B                             |\n|   |       tuple ids: 0                                    |\n|   |                                                       |\n|   1:SCAN HDFS                                             |\n|      table=join_order.big #partitions=1/1 size=23.12GB    |\n|      table stats: 1000000000 rows total                   |\n|      column stats: all                                    |\n|      cardinality: 1000000000                              |\n|      per-host memory: 88.00MB                             |\n|      tuple ids: 1                                         |\n|                                                           |\n| PLAN FRAGMENT 2                                           |\n|   PARTITION: RANDOM                                       |\n|                                                           |\n|   STREAM DATA SINK                                        |\n|     EXCHANGE ID: 4                                        |\n|     UNPARTITIONED                                         |\n|                                                           |\n|   0:SCAN HDFS                                             |\n|      table=join_order.medium #partitions=1/1 size=4.62GB  |\n|      table stats: 200000000 rows total                    |\n|      column stats: all                                    |\n|      cardinality: 200000000                               |\n|      per-host memory: 88.00MB                             |\n|      tuple ids: 0                                         |\n+-----------------------------------------------------------+\nReturned 64 row(s) in 0.04s\n\n[localhost:21000] &gt; explain select count(*) from small join big where big.id = small.id;\nQuery: explain select count(*) from small join big where big.id = small.id\n+-----------------------------------------------------------+\n| Explain String                                            |\n+-----------------------------------------------------------+\n| Estimated Per-Host Requirements: Memory=101.15MB VCores=2 |\n|                                                           |\n| PLAN FRAGMENT 0                                           |\n|   PARTITION: UNPARTITIONED                                |\n|                                                           |\n|   6:AGGREGATE (merge finalize)                            |\n|   |  output: SUM(COUNT(*))                                |\n|   |  cardinality: 1                                       |\n|   |  per-host memory: unavailable                         |\n|   |  tuple ids: 2                                         |\n|   |                                                       |\n|   5:EXCHANGE                                              |\n|      cardinality: 1                                       |\n|      per-host memory: unavailable                         |\n|      tuple ids: 2                                         |\n|                                                           |\n| PLAN FRAGMENT 1                                           |\n|   PARTITION: RANDOM                                       |\n|                                                           |\n|   STREAM DATA SINK                                        |\n|     EXCHANGE ID: 5                                        |\n|     UNPARTITIONED                                         |\n|                                                           |\n|   3:AGGREGATE                                             |\n|   |  output: COUNT(*)                                     |\n|   |  cardinality: 1                                       |\n|   |  per-host memory: 10.00MB                             |\n|   |  tuple ids: 2                                         |\n|   |                                                       |\n|   2:HASH JOIN                                             |\n|   |  join op: INNER JOIN (BROADCAST)                      |\n|   |  hash predicates:                                     |\n|   |    big.id = small.id                                  |\n|   |  cardinality: 1000000000                              |\n|   |  per-host memory: 3.15MB                              |\n|   |  tuple ids: 1 0                                       |\n|   |                                                       |\n|   |----4:EXCHANGE                                         |\n|   |       cardinality: 1000000                            |\n|   |       per-host memory: 0B                             |\n|   |       tuple ids: 0                                    |\n|   |                                                       |\n|   1:SCAN HDFS                                             |\n|      table=join_order.big #partitions=1/1 size=23.12GB    |\n|      table stats: 1000000000 rows total                   |\n|      column stats: all                                    |\n|      cardinality: 1000000000                              |\n|      per-host memory: 88.00MB                             |\n|      tuple ids: 1                                         |\n|                                                           |\n| PLAN FRAGMENT 2                                           |\n|   PARTITION: RANDOM                                       |\n|                                                           |\n|   STREAM DATA SINK                                        |\n|     EXCHANGE ID: 4                                        |\n|     UNPARTITIONED                                         |\n|                                                           |\n|   0:SCAN HDFS                                             |\n|      table=join_order.small #partitions=1/1 size=17.93MB  |\n|      table stats: 1000000 rows total                      |\n|      column stats: all                                    |\n|      cardinality: 1000000                                 |\n|      per-host memory: 32.00MB                             |\n|      tuple ids: 0                                         |\n+-----------------------------------------------------------+\nReturned 64 row(s) in 0.03s</div><p>\n        When queries like these are actually run, the execution times are relatively consistent regardless of the\n        table order in the query text. Here are examples using both the unique <span class=\"hue-doc-codeph\">ID</span> column and the\n        <span class=\"hue-doc-codeph\">VAL</span> column containing duplicate values:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select count(*) from big join small on (big.id = small.id);\nQuery: select count(*) from big join small on (big.id = small.id)\n+----------+\n| count(*) |\n+----------+\n| 1000000  |\n+----------+\nReturned 1 row(s) in 21.68s\n[localhost:21000] &gt; select count(*) from small join big on (big.id = small.id);\nQuery: select count(*) from small join big on (big.id = small.id)\n+----------+\n| count(*) |\n+----------+\n| 1000000  |\n+----------+\nReturned 1 row(s) in 20.45s\n\n[localhost:21000] &gt; select count(*) from big join small on (big.val = small.val);\n+------------+\n| count(*)   |\n+------------+\n| 2000948962 |\n+------------+\nReturned 1 row(s) in 108.85s\n[localhost:21000] &gt; select count(*) from small join big on (big.val = small.val);\n+------------+\n| count(*)   |\n+------------+\n| 2000948962 |\n+------------+\nReturned 1 row(s) in 100.76s</div><div class=\"hue-doc-note\">        When examining the performance of join queries and the effectiveness of the join order optimization, make\n        sure the query involves enough data and cluster resources to see a difference depending on the query plan.\n        For example, a single data file of just a few megabytes will reside in a single HDFS block and be processed\n        on a single node. Likewise, if you use a single-node or two-node cluster, there might not be much\n        difference in efficiency for the broadcast or partitioned join strategies.\n      </div></div></div></div></div>","title":"Performance Considerations for Join Queries"}