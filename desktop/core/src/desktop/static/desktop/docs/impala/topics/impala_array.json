{"body":"<div><div id=\"array\"><div class=\"hue-doc-title\">ARRAY Complex Type (Impala 2.3 or higher only)</div><div><p>\n      A complex data type that can represent an arbitrary number of ordered elements.\n      The elements can be scalars or another complex type (<span class=\"hue-doc-codeph\">ARRAY</span>,\n      <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span>).\n    </p><p id=\"syntax_blurb\"><b>Syntax:</b></p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">column_name</span> ARRAY &lt; <span class=\"hue-doc-varname\">type</span> &gt;\n\ntype ::= <span class=\"hue-doc-varname\">primitive_type</span> | <span class=\"hue-doc-varname\">complex_type</span></div><p id=\"usage_notes_blurb\"><b>Usage notes:</b></p><p id=\"complex_types_combo\">\n        Because complex types are often used in combination, for example an\n        <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span> elements, if you are unfamiliar with\n        the Impala complex types, start with\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for background\n        information and usage examples.\n      </p><p>\n        The elements of the array have no names. You refer to the value of the array item using the\n        <span class=\"hue-doc-codeph\">ITEM</span> pseudocolumn, or its position in the array with the <span class=\"hue-doc-codeph\">POS</span>\n        pseudocolumn. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"item\">ITEM and POS Pseudocolumns</a> for information about\n        these pseudocolumns.\n      </p><p>\n      Each row can have a different number of elements (including none) in the array for that row.\n    </p><p>\n        When an array contains items of scalar types, you can use aggregation functions on the array elements without using join notation. For\n        example, you can find the <span class=\"hue-doc-codeph\">COUNT()</span>, <span class=\"hue-doc-codeph\">AVG()</span>, <span class=\"hue-doc-codeph\">SUM()</span>, and so on of numeric array\n        elements, or the <span class=\"hue-doc-codeph\">MAX()</span> and <span class=\"hue-doc-codeph\">MIN()</span> of any scalar array elements by referring to\n        <span class=\"hue-doc-codeph\"><span class=\"hue-doc-varname\">table_name</span>.<span class=\"hue-doc-varname\">array_column</span></span> in the <span class=\"hue-doc-codeph\">FROM</span> clause of the query. When\n        you need to cross-reference values from the array with scalar values from the same row, such as by including a <span class=\"hue-doc-codeph\">GROUP\n        BY</span> clause to produce a separate aggregated result for each row, then the join clause is required.\n      </p><p>\n        A common usage pattern with complex types is to have an array as the top-level type for the column:\n        an array of structs, an array of maps, or an array of arrays.\n        For example, you can model a denormalized table by creating a column that is an <span class=\"hue-doc-codeph\">ARRAY</span>\n        of <span class=\"hue-doc-codeph\">STRUCT</span> elements; each item in the array represents a row from a table that would\n        normally be used in a join query. This kind of data structure lets you essentially denormalize tables by\n        associating multiple rows from one table with the matching row in another table.\n      </p><p>\n        You typically do not create more than one top-level <span class=\"hue-doc-codeph\">ARRAY</span> column, because if there is\n        some relationship between the elements of multiple arrays, it is convenient to model the data as\n        an array of another complex type element (either <span class=\"hue-doc-codeph\">STRUCT</span> or <span class=\"hue-doc-codeph\">MAP</span>).\n      </p><p id=\"complex_types_describe\">\n        You can pass a multi-part qualified name to <span class=\"hue-doc-codeph\">DESCRIBE</span> to specify an\n        <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span> column and\n        visualize its structure as if it were a table. For example, if table <span class=\"hue-doc-codeph\">T1</span>\n        contains an <span class=\"hue-doc-codeph\">ARRAY</span> column <span class=\"hue-doc-codeph\">A1</span>, you could issue the\n        statement <span class=\"hue-doc-codeph\">DESCRIBE t1.a1</span>. If table <span class=\"hue-doc-codeph\">T1</span> contained a\n        <span class=\"hue-doc-codeph\">STRUCT</span> column <span class=\"hue-doc-codeph\">S1</span>, and a field <span class=\"hue-doc-codeph\">F1</span>\n        within the <span class=\"hue-doc-codeph\">STRUCT</span> was a <span class=\"hue-doc-codeph\">MAP</span>, you could issue the\n        statement <span class=\"hue-doc-codeph\">DESCRIBE t1.s1.f1</span>. An <span class=\"hue-doc-codeph\">ARRAY</span> is shown as a\n        two-column table, with <span class=\"hue-doc-codeph\">ITEM</span> and <span class=\"hue-doc-codeph\">POS</span> columns. A\n        <span class=\"hue-doc-codeph\">STRUCT</span> is shown as a table with each field representing a column in the\n        table. A <span class=\"hue-doc-codeph\">MAP</span> is shown as a two-column table, with <span class=\"hue-doc-codeph\">KEY</span>\n        and <span class=\"hue-doc-codeph\">VALUE</span> columns.\n      </p><p id=\"added_in_230\"><b>Added in:</b>Impala 2.3.0</p><p id=\"restrictions_blurb\"><b>Restrictions:</b></p><ul id=\"complex_types_restrictions\"><li><p>\n            Columns with this data type can only be used in tables or partitions with the\n            Parquet or ORC file format.\n          </p></li><li><p>\n            Columns with this data type cannot be used as partition key columns in a partitioned\n            table.\n          </p></li><li><p>\n            The <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement does not produce any statistics for\n            columns of this data type.\n          </p></li><li><p id=\"complex_types_max_length\">\n            The maximum length of the column definition for any complex type, including\n            declarations for any nested types, is 4000 characters.\n          </p></li><li><p>\n            See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types_limits\">Limitations and Restrictions for Complex Types</a> for a\n            full list of limitations and associated guidelines about complex type columns.\n          </p></li></ul><p id=\"kudu_blurb\"><b>Kudu considerations:</b></p><p id=\"kudu_unsupported_data_type\"> Currently, the data types\n        <span class=\"hue-doc-codeph\">CHAR</span>, <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">MAP</span>, and\n          <span class=\"hue-doc-codeph\">STRUCT</span> cannot be used with Kudu tables.\n      </p><p id=\"example_blurb\"><b>Examples:</b></p><div class=\"hue-doc-note\" id=\"complex_type_schema_pointer\">        Many of the complex type examples refer to tables such as <span class=\"hue-doc-codeph\">CUSTOMER</span> and\n        <span class=\"hue-doc-codeph\">REGION</span> adapted from the tables used in the TPC-H benchmark. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_sample_schema\">Sample Schema and Data for Experimenting with Impala Complex Types</a> for the table\n        definitions.\n      </div><p>\n        The following example shows how to construct a table with various kinds of <span class=\"hue-doc-codeph\">ARRAY</span> columns,\n        both at the top level and nested within other complex types.\n        Whenever the <span class=\"hue-doc-codeph\">ARRAY</span> consists of a scalar value, such as in the <span class=\"hue-doc-codeph\">PETS</span>\n        column or the <span class=\"hue-doc-codeph\">CHILDREN</span> field, you can see that future expansion is limited.\n        For example, you could not easily evolve the schema to record the kind of pet or the child's birthday alongside the name.\n        Therefore, it is more common to use an <span class=\"hue-doc-codeph\">ARRAY</span> whose elements are of <span class=\"hue-doc-codeph\">STRUCT</span> type,\n        to associate multiple fields with each array element.\n      </p><div class=\"hue-doc-note\">        Practice the <span class=\"hue-doc-codeph\">CREATE TABLE</span> and query notation for complex type columns\n        using empty tables, until you can visualize a complex data structure and construct corresponding SQL statements reliably.\n      </div><div class=\"hue-doc-codeblock\">CREATE TABLE array_demo\n(\n  id BIGINT,\n  name STRING,\n-- An ARRAY of scalar type as a top-level column.\n  pets ARRAY &lt;STRING&gt;,\n\n-- An ARRAY with elements of complex type (STRUCT).\n  places_lived ARRAY &lt; STRUCT &lt;\n    place: STRING,\n    start_year: INT\n  &gt;&gt;,\n\n-- An ARRAY as a field (CHILDREN) within a STRUCT.\n-- (The STRUCT is inside another ARRAY, because it is rare\n-- for a STRUCT to be a top-level column.)\n  marriages ARRAY &lt; STRUCT &lt;\n    spouse: STRING,\n    children: ARRAY &lt;STRING&gt;\n  &gt;&gt;,\n\n-- An ARRAY as the value part of a MAP.\n-- The first MAP field (the key) would be a value such as\n-- 'Parent' or 'Grandparent', and the corresponding array would\n-- represent 2 parents, 4 grandparents, and so on.\n  ancestors MAP &lt; STRING, ARRAY &lt;STRING&gt; &gt;\n)\nSTORED AS PARQUET;\n</div><p>\n      The following example shows how to examine the structure of a table containing one or more <span class=\"hue-doc-codeph\">ARRAY</span> columns by using the\n      <span class=\"hue-doc-codeph\">DESCRIBE</span> statement. You can visualize each <span class=\"hue-doc-codeph\">ARRAY</span> as its own two-column table, with columns\n      <span class=\"hue-doc-codeph\">ITEM</span> and <span class=\"hue-doc-codeph\">POS</span>.\n    </p><div class=\"hue-doc-codeblock\">DESCRIBE array_demo;\n+--------------+---------------------------+\n| name         | type                      |\n+--------------+---------------------------+\n| id           | bigint                    |\n| name         | string                    |\n| pets         | array&lt;string&gt;             |\n| marriages    | array&lt;struct&lt;             |\n|              |   spouse:string,          |\n|              |   children:array&lt;string&gt;  |\n|              | &gt;&gt;                        |\n| places_lived | array&lt;struct&lt;             |\n|              |   place:string,           |\n|              |   start_year:int          |\n|              | &gt;&gt;                        |\n| ancestors    | map&lt;string,array&lt;string&gt;&gt; |\n+--------------+---------------------------+\n\nDESCRIBE array_demo.pets;\n+------+--------+\n| name | type   |\n+------+--------+\n| item | string |\n| pos  | bigint |\n+------+--------+\n\nDESCRIBE array_demo.marriages;\n+------+--------------------------+\n| name | type                     |\n+------+--------------------------+\n| item | struct&lt;                  |\n|      |   spouse:string,         |\n|      |   children:array&lt;string&gt; |\n|      | &gt;                        |\n| pos  | bigint                   |\n+------+--------------------------+\n\nDESCRIBE array_demo.places_lived;\n+------+------------------+\n| name | type             |\n+------+------------------+\n| item | struct&lt;          |\n|      |   place:string,  |\n|      |   start_year:int |\n|      | &gt;                |\n| pos  | bigint           |\n+------+------------------+\n\nDESCRIBE array_demo.ancestors;\n+-------+---------------+\n| name  | type          |\n+-------+---------------+\n| key   | string        |\n| value | array&lt;string&gt; |\n+-------+---------------+\n</div><p>\n      The following example shows queries involving <span class=\"hue-doc-codeph\">ARRAY</span> columns containing elements of scalar or complex types. You\n      <q>unpack</q> each <span class=\"hue-doc-codeph\">ARRAY</span> column by referring to it in a join query, as if it were a separate table with\n      <span class=\"hue-doc-codeph\">ITEM</span> and <span class=\"hue-doc-codeph\">POS</span> columns. If the array element is a scalar type, you refer to its value using the\n      <span class=\"hue-doc-codeph\">ITEM</span> pseudocolumn. If the array element is a <span class=\"hue-doc-codeph\">STRUCT</span>, you refer to the <span class=\"hue-doc-codeph\">STRUCT</span> fields\n      using dot notation and the field names. If the array element is another <span class=\"hue-doc-codeph\">ARRAY</span> or a <span class=\"hue-doc-codeph\">MAP</span>, you use\n      another level of join to unpack the nested collection elements.\n    </p><div class=\"hue-doc-codeblock\">-- Array of scalar values.\n-- Each array element represents a single string, plus we know its position in the array.\nSELECT id, name, pets.pos, pets.item FROM array_demo, array_demo.pets;\n\n-- Array of structs.\n-- Now each array element has named fields, possibly of different types.\n-- You can consider an ARRAY of STRUCT to represent a table inside another table.\nSELECT id, name, places_lived.pos, places_lived.item.place, places_lived.item.start_year\nFROM array_demo, array_demo.places_lived;\n\n-- The .ITEM name is optional for array elements that are structs.\n-- The following query is equivalent to the previous one, with .ITEM\n-- removed from the column references.\nSELECT id, name, places_lived.pos, places_lived.place, places_lived.start_year\n  FROM array_demo, array_demo.places_lived;\n\n-- To filter specific items from the array, do comparisons against the .POS or .ITEM\n-- pseudocolumns, or names of struct fields, in the WHERE clause.\nSELECT id, name, pets.item FROM array_demo, array_demo.pets\n  WHERE pets.pos in (0, 1, 3);\n\nSELECT id, name, pets.item FROM array_demo, array_demo.pets\n  WHERE pets.item LIKE 'Mr. %';\n\nSELECT id, name, places_lived.pos, places_lived.place, places_lived.start_year\n  FROM array_demo, array_demo.places_lived\nWHERE places_lived.place like '%California%';\n</div><p id=\"related_info\"><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a>,\n<a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_struct.xml\" data-doc-anchor-id=\"struct\">STRUCT Complex Type (Impala 2.3 or higher only)</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_map.xml\" data-doc-anchor-id=\"map\">MAP Complex Type (Impala 2.3 or higher only)</a></p></div></div></div>","title":"ARRAY Complex Type (Impala 2.3 or higher only)"}