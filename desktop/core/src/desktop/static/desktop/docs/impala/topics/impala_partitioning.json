{"body":"<div><div id=\"partitioning\"><div class=\"hue-doc-title\">Partitioning for Impala Tables</div><div><p>\n      By default, all the data files for a table are located in a single directory. Partitioning is a technique for physically dividing the\n      data during loading, based on values from one or more columns, to speed up queries that test those columns. For example, with a\n      <span class=\"hue-doc-codeph\">school_records</span> table partitioned on a <span class=\"hue-doc-codeph\">year</span> column, there is a separate data directory for each\n      different year value, and all the data for that year is stored in a data file in that directory. A query that includes a\n      <span class=\"hue-doc-codeph\">WHERE</span> condition such as <span class=\"hue-doc-codeph\">YEAR=1966</span>, <span class=\"hue-doc-codeph\">YEAR IN (1989,1999)</span>, or <span class=\"hue-doc-codeph\">YEAR BETWEEN\n      1984 AND 1989</span> can examine only the data files from the appropriate directory or directories, greatly reducing the amount of\n      data to read and test.\n    </p><p/><p>\n      See <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_tutorial.html#tut_external_partition_data\" target=\"_blank\">Attaching an External Partitioned Table to an HDFS Directory Structure</a> for an example that illustrates the syntax for creating partitioned\n      tables, the underlying directory structure in HDFS, and how to attach a partitioned Impala external table to data files stored\n      elsewhere in HDFS.\n    </p><p>\n      Parquet is a popular format for partitioned Impala tables because it is well suited to handle huge data volumes. See\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_parquet.xml\" data-doc-anchor-id=\"parquet_performance\">Query Performance for Impala Parquet Tables</a> for performance considerations for partitioned Parquet tables.\n    </p><p>\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_literals.xml\" data-doc-anchor-id=\"null\">NULL</a> for details about how <span class=\"hue-doc-codeph\">NULL</span> values are represented in partitioned tables.\n    </p><p>\n      See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_s3.xml\" data-doc-anchor-id=\"s3\">Using Impala with Amazon S3 Object Store</a> for details about setting up tables where some or all partitions reside on the Amazon Simple\n      Storage Service (S3).\n    </p></div><div id=\"partitioning_choosing\"><div class=\"hue-doc-title\">When to Use Partitioned Tables</div><div><p>\n        Partitioning is typically appropriate for:\n      </p><ul><li>\n          Tables that are very large, where reading the entire data set takes an impractical amount of time.\n        </li><li>\n          Tables that are always or almost always queried with conditions on the partitioning columns. In our example of a table partitioned\n          by year, <span class=\"hue-doc-codeph\">SELECT COUNT(*) FROM school_records WHERE year = 1985</span> is efficient, only examining a small fraction of\n          the data; but <span class=\"hue-doc-codeph\">SELECT COUNT(*) FROM school_records</span> has to process a separate data file for each year, resulting in\n          more overall work than in an unpartitioned table. You would probably not partition this way if you frequently queried the table\n          based on last name, student ID, and so on without testing the year.\n        </li><li>\n          Columns that have reasonable cardinality (number of different values). If a column only has a small number of values, for example\n          <span class=\"hue-doc-codeph\">Male</span> or <span class=\"hue-doc-codeph\">Female</span>, you do not gain much efficiency by eliminating only about 50% of the data to\n          read for each query. If a column has only a few rows matching each value, the number of directories to process can become a\n          limiting factor, and the data file in each directory could be too small to take advantage of the Hadoop mechanism for transmitting\n          data in multi-megabyte blocks. For example, you might partition census data by year, store sales data by year and month, and web\n          traffic data by year, month, and day. (Some users with high volumes of incoming data might even partition down to the individual\n          hour and minute.)\n        </li><li>\n          Data that already passes through an extract, transform, and load (ETL) pipeline. The values of the partitioning columns are\n          stripped from the original data files and represented by directory names, so loading data into a partitioned table involves some\n          sort of transformation or preprocessing.\n        </li></ul></div></div><div id=\"partition_sql\"><div class=\"hue-doc-title\">SQL Statements for Partitioned Tables</div><div><p>\n        In terms of Impala SQL syntax, partitioning affects these statements:\n      </p><ul><li><span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_create_table.xml\" data-doc-anchor-id=\"create_table\">CREATE TABLE</a></span>: you specify a <span class=\"hue-doc-codeph\">PARTITIONED\n          BY</span> clause when creating the table to identify names and data types of the partitioning columns. These columns are not\n          included in the main list of columns for the table.\n        </li><li>\n          In Impala 2.5 and higher, you can also use the <span class=\"hue-doc-codeph\">PARTITIONED BY</span> clause in a <span class=\"hue-doc-codeph\">CREATE TABLE AS\n          SELECT</span> statement. This syntax lets you use a single statement to create a partitioned table, copy data into it, and\n          create new partitions based on the values in the inserted data.\n        </li><li><span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_alter_table.xml\" data-doc-anchor-id=\"alter_table\">ALTER\n              TABLE</a></span>: you can add or drop partitions, to work\n          with different portions of a huge data set. You can designate the HDFS\n          directory that holds the data files for a specific partition. With\n          data partitioned by date values, you might <q>age out</q> data that is\n          no longer relevant. <div class=\"hue-doc-note\" id=\"add_partition_set_location\">        If you are creating a partition for the first time and specifying its location, for\n        maximum efficiency, use a single <span class=\"hue-doc-codeph\">ALTER TABLE</span> statement including both\n        the <span class=\"hue-doc-codeph\">ADD PARTITION</span> and <span class=\"hue-doc-codeph\">LOCATION</span> clauses, rather than\n        separate statements with <span class=\"hue-doc-codeph\">ADD PARTITION</span> and <span class=\"hue-doc-codeph\">SET\n        LOCATION</span> clauses.\n      </div></li><li><span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_insert.xml\" data-doc-anchor-id=\"insert\">INSERT</a></span>:\n          When you insert data into a partitioned table, you identify the\n          partitioning columns. One or more values from each inserted row are\n          not stored in data files, but instead determine the directory where\n          that row value is stored. You can also specify which partition to load\n          a set of data into, with <span class=\"hue-doc-codeph\">INSERT OVERWRITE</span> statements;\n          you can replace the contents of a specific partition but you cannot\n          append data to a specific partition. <p id=\"insert_inherit_permissions\">\n        By default, if an <span class=\"hue-doc-codeph\">INSERT</span> statement creates any new subdirectories\n        underneath a partitioned table, those subdirectories are assigned default HDFS\n        permissions for the <span class=\"hue-doc-codeph\">impala</span> user. To make each subdirectory have the\n        same permissions as its parent directory in HDFS, specify the\n        <span class=\"hue-doc-codeph\">‑‑insert_inherit_permissions</span> startup option for the\n        <span class=\"hue-doc-cmdname\">impalad</span> daemon.\n      </p></li><li>\n          Although the syntax of the <span class=\"hue-doc-codeph\"><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_select.xml\" data-doc-anchor-id=\"select\">SELECT</a></span> statement is the same whether or\n          not the table is partitioned, the way queries interact with partitioned tables can have a dramatic impact on performance and\n          scalability. The mechanism that lets queries skip certain partitions during a query is known as partition pruning; see\n          <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"partition_pruning\">Partition Pruning for Queries</a> for details.\n        </li><li>\n          In Impala 1.4 and later, there is a <span class=\"hue-doc-codeph\">SHOW PARTITIONS</span> statement that displays information about each partition in a\n          table. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_show.xml\" data-doc-anchor-id=\"show\">SHOW Statement</a> for details.\n        </li></ul></div></div><div id=\"partition_static_dynamic\"><div class=\"hue-doc-title\">Static and Dynamic Partitioning Clauses</div><div><p>\n        Specifying all the partition columns in a SQL statement is called <span class=\"hue-doc-term\">static partitioning</span>, because the statement affects a\n        single predictable partition. For example, you use static partitioning with an <span class=\"hue-doc-codeph\">ALTER TABLE</span> statement that affects\n        only one partition, or with an <span class=\"hue-doc-codeph\">INSERT</span> statement that inserts all values into the same partition:\n      </p><div class=\"hue-doc-codeblock\">insert into t1 <b>partition(x=10, y='a')</b> select c1 from some_other_table;\n</div><p>\n        When you specify some partition key columns in an <span class=\"hue-doc-codeph\">INSERT</span> statement, but leave out the values, Impala determines\n        which partition to insert. This technique is called <span class=\"hue-doc-term\">dynamic partitioning</span>:\n      </p><div class=\"hue-doc-codeblock\">insert into t1 <b>partition(x, y='b')</b> select c1, c2 from some_other_table;\n-- Create new partition if necessary based on variable year, month, and day; insert a single value.\ninsert into weather <b>partition (year, month, day)</b> select 'cloudy',2014,4,21;\n-- Create new partition if necessary for specified year and month but variable day; insert a single value.\ninsert into weather <b>partition (year=2014, month=04, day)</b> select 'sunny',22;\n</div><p>\n        The more key columns you specify in the <span class=\"hue-doc-codeph\">PARTITION</span> clause, the fewer columns you need in the <span class=\"hue-doc-codeph\">SELECT</span>\n        list. The trailing columns in the <span class=\"hue-doc-codeph\">SELECT</span> list are substituted in order for the partition key columns with no\n        specified value.\n      </p></div></div><div id=\"partition_refresh\"><div class=\"hue-doc-title\">Refreshing a Single Partition</div><div><p>\n        The <span class=\"hue-doc-codeph\">REFRESH</span> statement is typically used with partitioned tables when new data files are loaded into a partition by\n        some non-Impala mechanism, such as a Hive or Spark job. The <span class=\"hue-doc-codeph\">REFRESH</span> statement makes Impala aware of the new data\n        files so that they can be used in Impala queries. Because partitioned tables typically contain a high volume of data, the\n        <span class=\"hue-doc-codeph\">REFRESH</span> operation for a full partitioned table can take significant time.\n      </p><p>\n        In Impala 2.7 and higher, you can include a <span class=\"hue-doc-codeph\">PARTITION (<span class=\"hue-doc-varname\">partition_spec</span>)</span> clause in the\n        <span class=\"hue-doc-codeph\">REFRESH</span> statement so that only a single partition is refreshed. For example, <span class=\"hue-doc-codeph\">REFRESH big_table PARTITION\n        (year=2017, month=9, day=30)</span>. The partition spec must include all the partition key columns. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_refresh.xml\" data-doc-anchor-id=\"refresh\">REFRESH Statement</a> for more details and examples of <span class=\"hue-doc-codeph\">REFRESH</span> syntax and usage.\n      </p></div></div><div id=\"partition_permissions\"><div class=\"hue-doc-title\">Permissions for Partition Subdirectories</div><div><p id=\"insert_inherit_permissions\">\n        By default, if an <span class=\"hue-doc-codeph\">INSERT</span> statement creates any new subdirectories\n        underneath a partitioned table, those subdirectories are assigned default HDFS\n        permissions for the <span class=\"hue-doc-codeph\">impala</span> user. To make each subdirectory have the\n        same permissions as its parent directory in HDFS, specify the\n        <span class=\"hue-doc-codeph\">‑‑insert_inherit_permissions</span> startup option for the\n        <span class=\"hue-doc-cmdname\">impalad</span> daemon.\n      </p></div></div><div id=\"partition_pruning\"><div class=\"hue-doc-title\">Partition Pruning for Queries</div><div><p>\n        Partition pruning refers to the mechanism where a query can skip reading the data files corresponding to one or more partitions. If\n        you can arrange for queries to prune large numbers of unnecessary partitions from the query execution plan, the queries use fewer\n        resources and are thus proportionally faster and more scalable.\n      </p><p>\n        For example, if a table is partitioned by columns <span class=\"hue-doc-codeph\">YEAR</span>, <span class=\"hue-doc-codeph\">MONTH</span>, and <span class=\"hue-doc-codeph\">DAY</span>, then\n        <span class=\"hue-doc-codeph\">WHERE</span> clauses such as <span class=\"hue-doc-codeph\">WHERE year = 2013</span>, <span class=\"hue-doc-codeph\">WHERE year &lt; 2010</span>, or <span class=\"hue-doc-codeph\">WHERE\n        year BETWEEN 1995 AND 1998</span> allow Impala to skip the data files in all partitions outside the specified range. Likewise,\n        <span class=\"hue-doc-codeph\">WHERE year = 2013 AND month BETWEEN 1 AND 3</span> could prune even more partitions, reading the data files for only a\n        portion of one year.\n      </p><p/></div><div id=\"partition_pruning_checking\"><div class=\"hue-doc-title\">Checking if Partition Pruning Happens for a Query</div><div><p>\n          To check the effectiveness of partition pruning for a query, check the <span class=\"hue-doc-codeph\">EXPLAIN</span> output for the query before\n          running it. For example, this example shows a table with 3 partitions, where the query only reads 1 of them. The notation\n          <span class=\"hue-doc-codeph\">#partitions=1/3</span> in the <span class=\"hue-doc-codeph\">EXPLAIN</span> plan confirms that Impala can do the appropriate partition\n          pruning.\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; insert into census partition (year=2010) values ('Smith'),('Jones');\n[localhost:21000] &gt; insert into census partition (year=2011) values ('Smith'),('Jones'),('Doe');\n[localhost:21000] &gt; insert into census partition (year=2012) values ('Smith'),('Doe');\n[localhost:21000] &gt; select name from census where year=2010;\n+-------+\n| name  |\n+-------+\n| Smith |\n| Jones |\n+-------+\n[localhost:21000] &gt; explain select name from census <b>where year=2010</b>;\n+------------------------------------------------------------------+\n| Explain String                                                   |\n+------------------------------------------------------------------+\n| PLAN FRAGMENT 0                                                  |\n|   PARTITION: UNPARTITIONED                                       |\n|                                                                  |\n|   1:EXCHANGE                                                     |\n|                                                                  |\n| PLAN FRAGMENT 1                                                  |\n|   PARTITION: RANDOM                                              |\n|                                                                  |\n|   STREAM DATA SINK                                               |\n|     EXCHANGE ID: 1                                               |\n|     UNPARTITIONED                                                |\n|                                                                  |\n|   0:SCAN HDFS                                                    |\n|      table=predicate_propagation.census <b>#partitions=1/3</b> size=12B |\n+------------------------------------------------------------------+</div><p>\n          For a report of the volume of data that was actually read and processed at each stage of the query, check the output of the\n          <span class=\"hue-doc-codeph\">SUMMARY</span> command immediately after running the query. For a more detailed analysis, look at the output of the\n          <span class=\"hue-doc-codeph\">PROFILE</span> command; it includes this same summary report near the start of the profile output.\n        </p></div></div><div id=\"partition_pruning_sql\"><div class=\"hue-doc-title\">What SQL Constructs Work with Partition Pruning</div><div><p>\n          Impala can even do partition pruning in cases where the partition key column is not directly compared to a constant, by applying\n          the transitive property to other parts of the <span class=\"hue-doc-codeph\">WHERE</span> clause. This technique is known as predicate propagation, and\n          is available in Impala 1.2.2 and later. In this example, the census table includes another column indicating when the data was\n          collected, which happens in 10-year intervals. Even though the query does not compare the partition key column\n          (<span class=\"hue-doc-codeph\">YEAR</span>) to a constant value, Impala can deduce that only the partition <span class=\"hue-doc-codeph\">YEAR=2010</span> is required, and\n          again only reads 1 out of 3 partitions.\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; drop table census;\n[localhost:21000] &gt; create table census (name string, census_year int) partitioned by (year int);\n[localhost:21000] &gt; insert into census partition (year=2010) values ('Smith',2010),('Jones',2010);\n[localhost:21000] &gt; insert into census partition (year=2011) values ('Smith',2020),('Jones',2020),('Doe',2020);\n[localhost:21000] &gt; insert into census partition (year=2012) values ('Smith',2020),('Doe',2020);\n[localhost:21000] &gt; select name from census where year = census_year and census_year=2010;\n+-------+\n| name  |\n+-------+\n| Smith |\n| Jones |\n+-------+\n[localhost:21000] &gt; explain select name from census <b>where year = census_year and census_year=2010</b>;\n+------------------------------------------------------------------+\n| Explain String                                                   |\n+------------------------------------------------------------------+\n| PLAN FRAGMENT 0                                                  |\n|   PARTITION: UNPARTITIONED                                       |\n|                                                                  |\n|   1:EXCHANGE                                                     |\n|                                                                  |\n| PLAN FRAGMENT 1                                                  |\n|   PARTITION: RANDOM                                              |\n|                                                                  |\n|   STREAM DATA SINK                                               |\n|     EXCHANGE ID: 1                                               |\n|     UNPARTITIONED                                                |\n|                                                                  |\n|   0:SCAN HDFS                                                    |\n|      table=predicate_propagation.census <b>#partitions=1/3</b> size=22B |\n|      predicates: census_year = 2010, year = census_year          |\n+------------------------------------------------------------------+\n</div><p id=\"partitions_and_views\">\n        If a view applies to a partitioned table, any partition pruning considers the clauses on\n        both the original query and any additional <span class=\"hue-doc-codeph\">WHERE</span> predicates in the\n        query that refers to the view. Prior to Impala 1.4, only the <span class=\"hue-doc-codeph\">WHERE</span>\n        clauses on the original query from the <span class=\"hue-doc-codeph\">CREATE VIEW</span> statement were used\n        for partition pruning.\n      </p><p id=\"analytic_partition_pruning_caveat\">\n        In queries involving both analytic functions and partitioned tables, partition pruning\n        only occurs for columns named in the <span class=\"hue-doc-codeph\">PARTITION BY</span> clause of the\n        analytic function call. For example, if an analytic function query has a clause such as\n        <span class=\"hue-doc-codeph\">WHERE year=2016</span>, the way to make the query prune all other\n        <span class=\"hue-doc-codeph\">YEAR</span> partitions is to include <span class=\"hue-doc-codeph\">PARTITION BY year</span> in the\n        analytic function call; for example, <span class=\"hue-doc-codeph\">OVER (PARTITION BY\n        year,<span class=\"hue-doc-varname\">other_columns</span><span class=\"hue-doc-varname\">other_analytic_clauses</span>)</span>.\n</p></div></div><div id=\"dynamic_partition_pruning\"><div class=\"hue-doc-title\">Dynamic Partition Pruning</div><div><p>\n          The original mechanism uses to prune partitions is <span class=\"hue-doc-term\">static partition pruning</span>, in which the conditions in the\n          <span class=\"hue-doc-codeph\">WHERE</span> clause are analyzed to determine in advance which partitions can be safely skipped. In Impala 2.5\n          and higher, Impala can perform <span class=\"hue-doc-term\">dynamic partition pruning</span>, where information about the partitions is collected during\n          the query, and Impala prunes unnecessary partitions in ways that were impractical to predict in advance.\n        </p><p>\n          For example, if partition key columns are compared to literal values in a <span class=\"hue-doc-codeph\">WHERE</span> clause, Impala can perform static\n          partition pruning during the planning phase to only read the relevant partitions:\n        </p><div class=\"hue-doc-codeblock\">-- The query only needs to read 3 partitions whose key values are known ahead of time.\n-- That's static partition pruning.\nSELECT COUNT(*) FROM sales_table WHERE year IN (2005, 2010, 2015);\n</div><p>\n          Dynamic partition pruning involves using information only available\n          at run time, such as the result of a subquery. The following example\n          shows a simple dynamic partition pruning.\n        </p><div class=\"hue-doc-codeblock\" id=\"simple_dpp_example\">CREATE TABLE yy (s STRING) PARTITIONED BY (year INT);\nINSERT INTO yy PARTITION (year) VALUES ('1999', 1999), ('2000', 2000),\n  ('2001', 2001), ('2010', 2010), ('2018', 2018);\nCOMPUTE STATS yy;\n\nCREATE TABLE yy2 (s STRING, year INT);\nINSERT INTO yy2 VALUES ('1999', 1999), ('2000', 2000), ('2001', 2001);\nCOMPUTE STATS yy2;\n\n-- The following query reads an unknown number of partitions, whose key values\n-- are only known at run time. The <b>runtime filters</b> line shows the\n-- information used in query fragment 02 to decide which partitions to skip.\n\nEXPLAIN SELECT s FROM yy WHERE year IN (SELECT year FROM yy2);\n+--------------------------------------------------------------------------+\n| PLAN-ROOT SINK                                                           |\n| |                                                                        |\n| 04:EXCHANGE [UNPARTITIONED]                                              |\n| |                                                                        |\n| 02:HASH JOIN [LEFT SEMI JOIN, BROADCAST]                                 |\n| |  hash predicates: year = year                                          |\n| |  <b>runtime filters: RF000 &lt;- year</b>                                   |\n| |                                                                        |\n| |--03:EXCHANGE [BROADCAST]                                               |\n| |  |                                                                     |\n| |  01:SCAN HDFS [default.yy2]                                            |\n| |     partitions=1/1 files=1 size=620B                                   |\n| |                                                                        |\n| 00:SCAN HDFS [default.yy]                                                |\n|    <b>partitions=5/5</b> files=5 size=1.71KB                               |\n|    runtime filters: RF000 -&gt; year                                        |\n+--------------------------------------------------------------------------+\n\nSELECT s FROM yy WHERE year IN (SELECT year FROM yy2); -- Returns 3 rows from yy\nPROFILE;\n</div><p>\n          In the above example, Impala evaluates the subquery, sends the\n          subquery results to all Impala nodes participating in the query, and\n          then each <span class=\"hue-doc-cmdname\">impalad</span> daemon uses the dynamic partition\n          pruning optimization to read only the partitions with the relevant key\n          values.\n        </p><p>\n          The output query plan from the <span class=\"hue-doc-codeph\">EXPLAIN</span> statement\n          shows that runtime filters are enabled. The plan also shows that it\n          expects to read all 5 partitions of the <span class=\"hue-doc-codeph\">yy</span> table,\n          indicating that static partition pruning will not happen.\n        </p><p>\n          The Filter summary in the <span class=\"hue-doc-codeph\">PROFILE</span> output shows that\n          the scan node filtered out based on a runtime filter of dynamic\n          partition pruning.\n        </p><div class=\"hue-doc-codeblock\">Filter 0 (1.00 MB):\n - Files processed: 3\n - <b>Files rejected: 1 (1)</b>\n - Files total: 3 (3)\n</div><p>\n          Dynamic partition pruning is especially effective for queries involving joins of several large partitioned tables. Evaluating the\n          <span class=\"hue-doc-codeph\">ON</span> clauses of the join predicates might normally require reading data from all partitions of certain tables. If\n          the <span class=\"hue-doc-codeph\">WHERE</span> clauses of the query refer to the partition key columns, Impala can now often skip reading many of the\n          partitions while evaluating the <span class=\"hue-doc-codeph\">ON</span> clauses. The dynamic partition pruning optimization reduces the amount of I/O\n          and the amount of intermediate data stored and transmitted across the network during the query.\n        </p><p id=\"spill_to_disk_vs_dynamic_partition_pruning\">\n        When the spill-to-disk feature is activated for a join node within a query, Impala does\n        not produce any runtime filters for that join operation on that host. Other join nodes\n        within the query are not affected.\n      </p><p>\n          Dynamic partition pruning is part of the runtime filtering feature, which applies to other kinds of queries in addition to queries\n          against partitioned tables. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_runtime_filtering.xml\" data-doc-anchor-id=\"runtime_filtering\">Runtime Filtering for Impala Queries (Impala 2.5 or higher only)</a> for full details about this feature.\n        </p></div></div></div><div id=\"partition_key_columns\"><div class=\"hue-doc-title\">Partition Key Columns</div><div><p>\n        The columns you choose as the partition keys should be ones that are frequently used to filter query results in important,\n        large-scale queries. Popular examples are some combination of year, month, and day when the data has associated time values, and\n        geographic region when the data is associated with some place.\n      </p><ul><li><p>\n            For time-based data, split out the separate parts into their own columns, because Impala cannot partition based on a\n            <span class=\"hue-doc-codeph\">TIMESTAMP</span> column.\n          </p></li><li><p>\n            The data type of the partition columns does not have a significant effect on the storage required, because the values from those\n            columns are not stored in the data files, rather they are represented as strings inside HDFS directory names.\n          </p></li><li><p>\n            In Impala 2.5 and higher, you can enable the <span class=\"hue-doc-codeph\">OPTIMIZE_PARTITION_KEY_SCANS</span> query option to speed up\n            queries that only refer to partition key columns, such as <span class=\"hue-doc-codeph\">SELECT MAX(year)</span>. This setting is not enabled by\n            default because the query behavior is slightly different if the table contains partition directories without actual data inside.\n            See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_optimize_partition_key_scans.xml\" data-doc-anchor-id=\"optimize_partition_key_scans\">OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)</a> for details.\n          </p></li><li><p id=\"complex_types_partitioning\">\n        Partitioned tables can contain complex type columns. All the partition key columns must\n        be scalar types.\n      </p></li><li><p>\n            Remember that when Impala queries data stored in HDFS, it is most efficient to use multi-megabyte files to take advantage of the\n            HDFS block size. For Parquet tables, the block size (and ideal size of the data files) is <span class=\"hue-doc-ph\">256 MB in\n            Impala 2.0 and later</span>. Therefore, avoid specifying too many partition key columns, which could result in individual\n            partitions containing only small amounts of data. For example, if you receive 1 GB of data per day, you might partition by year,\n            month, and day; while if you receive 5 GB of data per minute, you might partition by year, month, day, hour, and minute. If you\n            have data with a geographic component, you might partition based on postal code if you have many megabytes of data for each\n            postal code, but if not, you might partition by some larger region such as city, state, or country. state\n          </p></li></ul><p id=\"partition_key_optimization\">\n        If you frequently run aggregate functions such as <span class=\"hue-doc-codeph\">MIN()</span>,\n        <span class=\"hue-doc-codeph\">MAX()</span>, and <span class=\"hue-doc-codeph\">COUNT(DISTINCT)</span> on partition key columns,\n        consider enabling the <span class=\"hue-doc-codeph\">OPTIMIZE_PARTITION_KEY_SCANS</span> query option, which\n        optimizes such queries. This feature is available in Impala 2.5\n        and higher. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_optimize_partition_key_scans.xml\">OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)</a> for the\n        kinds of queries that this option applies to, and slight differences in how partitions\n        are evaluated when this query option is enabled.\n      </p></div></div><div id=\"mixed_format_partitions\"><div class=\"hue-doc-title\">Setting Different File Formats for Partitions</div><div><p>\n        Partitioned tables have the flexibility to use different file formats for different partitions. (For background information about\n        the different file formats Impala supports, see <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_file_formats.xml\" data-doc-anchor-id=\"file_formats\">How Impala Works with Hadoop File Formats</a>.) For example, if you originally\n        received data in text format, then received new data in RCFile format, and eventually began receiving data in Parquet format, all\n        that data could reside in the same table for queries. You just need to ensure that the table is structured so that the data files\n        that use different file formats reside in separate partitions.\n      </p><p>\n        For example, here is how you might switch from text to Parquet data as you receive data for different years:\n      </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table census (name string) partitioned by (year smallint);\n[localhost:21000] &gt; alter table census add partition (year=2012); -- Text format;\n\n[localhost:21000] &gt; alter table census add partition (year=2013); -- Text format switches to Parquet before data loaded;\n[localhost:21000] &gt; alter table census partition (year=2013) set fileformat parquet;\n\n[localhost:21000] &gt; insert into census partition (year=2012) values ('Smith'),('Jones'),('Lee'),('Singh');\n[localhost:21000] &gt; insert into census partition (year=2013) values ('Flores'),('Bogomolov'),('Cooper'),('Appiah');</div><p>\n        At this point, the HDFS directory for <span class=\"hue-doc-codeph\">year=2012</span> contains a text-format data file, while the HDFS directory for\n        <span class=\"hue-doc-codeph\">year=2013</span> contains a Parquet data file. As always, when loading non-trivial data, you would use <span class=\"hue-doc-codeph\">INSERT ...\n        SELECT</span> or <span class=\"hue-doc-codeph\">LOAD DATA</span> to import data in large batches, rather than <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> which\n        produces small files that are inefficient for real-world queries.\n      </p><p>\n        For other file types that Impala cannot create natively, you can switch into Hive and issue the <span class=\"hue-doc-codeph\">ALTER TABLE ... SET\n        FILEFORMAT</span> statements and <span class=\"hue-doc-codeph\">INSERT</span> or <span class=\"hue-doc-codeph\">LOAD DATA</span> statements there. After switching back to\n        Impala, issue a <span class=\"hue-doc-codeph\">REFRESH <span class=\"hue-doc-varname\">table_name</span></span> statement so that Impala recognizes any partitions or new\n        data added through Hive.\n      </p></div></div><div id=\"partition_management\"><div class=\"hue-doc-title\">Managing Partitions</div><div><p>\n        You can add, drop, set the expected file format, or set the HDFS location of the data files for individual partitions within an\n        Impala table. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_alter_table.xml\" data-doc-anchor-id=\"alter_table\">ALTER TABLE Statement</a> for syntax details, and\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_partitioning.xml\" data-doc-anchor-id=\"mixed_format_partitions\">Setting Different File Formats for Partitions</a> for tips on managing tables containing partitions with different file\n        formats.\n      </p><div class=\"hue-doc-note\" id=\"add_partition_set_location\">        If you are creating a partition for the first time and specifying its location, for\n        maximum efficiency, use a single <span class=\"hue-doc-codeph\">ALTER TABLE</span> statement including both\n        the <span class=\"hue-doc-codeph\">ADD PARTITION</span> and <span class=\"hue-doc-codeph\">LOCATION</span> clauses, rather than\n        separate statements with <span class=\"hue-doc-codeph\">ADD PARTITION</span> and <span class=\"hue-doc-codeph\">SET\n        LOCATION</span> clauses.\n      </div><p>\n        What happens to the data files when a partition is dropped depends on whether the partitioned table is designated as internal or\n        external. For an internal (managed) table, the data files are deleted. For example, if data in the partitioned table is a copy of\n        raw data files stored elsewhere, you might save disk space by dropping older partitions that are no longer required for reporting,\n        knowing that the original data is still available if needed later. For an external table, the data files are left alone. For\n        example, dropping a partition without deleting the associated files lets Impala consider a smaller set of partitions, improving\n        query efficiency and reducing overhead for DDL operations on the table; if the data is needed again later, you can add the partition\n        again. See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tables.xml\" data-doc-anchor-id=\"tables\">Overview of Impala Tables</a> for details and examples.\n      </p></div></div><div id=\"partition_kudu\"><div class=\"hue-doc-title\">Using Partitioning with Kudu Tables</div><div><p>\n        Kudu tables use a more fine-grained partitioning scheme than tables containing HDFS data files. You specify a <span class=\"hue-doc-codeph\">PARTITION\n        BY</span> clause with the <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement to identify how to divide the values from the partition key\n        columns.\n      </p><p>\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_kudu.xml\" data-doc-anchor-id=\"kudu_partitioning\">Partitioning for Kudu Tables</a> for\n        details and examples of the partitioning techniques\n        for Kudu tables.\n      </p></div></div><div id=\"partition_stats\"><div class=\"hue-doc-title\">Keeping Statistics Up to Date for Partitioned Tables</div><div><p>\n        Because the <span class=\"hue-doc-codeph\">COMPUTE STATS</span> statement can be resource-intensive to run on a partitioned table\n        as new partitions are added, Impala includes a variation of this statement that allows computing statistics\n        on a per-partition basis such that stats can be incrementally updated when new partitions are added.\n      </p><div class=\"hue-doc-note\"><p id=\"cs_or_cis\">\n        For a particular table, use either <span class=\"hue-doc-codeph\">COMPUTE STATS</span> or <span class=\"hue-doc-codeph\">COMPUTE\n        INCREMENTAL STATS</span>, but never combine the two or alternate between them. If you\n        switch from <span class=\"hue-doc-codeph\">COMPUTE STATS</span> to <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span>\n        during the lifetime of a table, or vice versa, drop all statistics by running\n        <span class=\"hue-doc-codeph\">DROP STATS</span> before making the switch.\n      </p><p id=\"incremental_stats_after_full\">\n        When you run <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span> on a table for the first time,\n        the statistics are computed again from scratch regardless of whether the table already\n        has statistics. Therefore, expect a one-time resource-intensive operation for scanning\n        the entire table when running <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span> for the first\n        time on a given table.\n      </p><p id=\"incremental_stats_caveats\">\n        In Impala 3.0 and lower, approximately 400 bytes of metadata per column per partition\n        are needed for caching. Tables with a big number of partitions and many columns can add\n        up to a significant memory overhead as the metadata must be cached on the\n        <span class=\"hue-doc-cmdname\">catalogd</span> host and on every <span class=\"hue-doc-cmdname\">impalad</span> host that is\n        eligible to be a coordinator. If this metadata for all tables exceeds 2 GB, you might\n        experience service downtime. In Impala 3.1 and higher, the issue was alleviated with an\n        improved handling of incremental stats.\n      </p></div><p>\n        The <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span> variation computes statistics only for partitions that were\n        added or changed since the last <span class=\"hue-doc-codeph\">COMPUTE INCREMENTAL STATS</span> statement, rather than the entire\n        table. It is typically used for tables where a full <span class=\"hue-doc-codeph\">COMPUTE STATS</span>\n        operation takes too long to be practical each time a partition is added or dropped. See\n        <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_perf_stats.xml\" data-doc-anchor-id=\"perf_stats_incremental\">Table and Column Statistics</a> for full usage details.\n      </p><div class=\"hue-doc-codeblock\" id=\"compute_stats_walkthrough\">-- Initially the table has no incremental stats, as indicated\n-- 'false' under Incremental stats.\nshow table stats item_partitioned;\n+-------------+-------+--------+----------+--------------+---------+------------------\n| i_category  | #Rows | #Files | Size     | Bytes Cached | Format  | Incremental stats\n+-------------+-------+--------+----------+--------------+---------+------------------\n| Books       | -1    | 1      | 223.74KB | NOT CACHED   | PARQUET | false\n| Children    | -1    | 1      | 230.05KB | NOT CACHED   | PARQUET | false\n| Electronics | -1    | 1      | 232.67KB | NOT CACHED   | PARQUET | false\n| Home        | -1    | 1      | 232.56KB | NOT CACHED   | PARQUET | false\n| Jewelry     | -1    | 1      | 223.72KB | NOT CACHED   | PARQUET | false\n| Men         | -1    | 1      | 231.25KB | NOT CACHED   | PARQUET | false\n| Music       | -1    | 1      | 237.90KB | NOT CACHED   | PARQUET | false\n| Shoes       | -1    | 1      | 234.90KB | NOT CACHED   | PARQUET | false\n| Sports      | -1    | 1      | 227.97KB | NOT CACHED   | PARQUET | false\n| Women       | -1    | 1      | 226.27KB | NOT CACHED   | PARQUET | false\n| Total       | -1    | 10     | 2.25MB   | 0B           |         |\n+-------------+-------+--------+----------+--------------+---------+------------------\n\n-- After the first COMPUTE INCREMENTAL STATS,\n-- all partitions have stats. The first\n-- COMPUTE INCREMENTAL STATS scans the whole\n-- table, discarding any previous stats from\n-- a traditional COMPUTE STATS statement.\ncompute incremental stats item_partitioned;\n+-------------------------------------------+\n| summary                                   |\n+-------------------------------------------+\n| Updated 10 partition(s) and 21 column(s). |\n+-------------------------------------------+\nshow table stats item_partitioned;\n+-------------+-------+--------+----------+--------------+---------+------------------\n| i_category  | #Rows | #Files | Size     | Bytes Cached | Format  | Incremental stats\n+-------------+-------+--------+----------+--------------+---------+------------------\n| Books       | 1733  | 1      | 223.74KB | NOT CACHED   | PARQUET | true\n| Children    | 1786  | 1      | 230.05KB | NOT CACHED   | PARQUET | true\n| Electronics | 1812  | 1      | 232.67KB | NOT CACHED   | PARQUET | true\n| Home        | 1807  | 1      | 232.56KB | NOT CACHED   | PARQUET | true\n| Jewelry     | 1740  | 1      | 223.72KB | NOT CACHED   | PARQUET | true\n| Men         | 1811  | 1      | 231.25KB | NOT CACHED   | PARQUET | true\n| Music       | 1860  | 1      | 237.90KB | NOT CACHED   | PARQUET | true\n| Shoes       | 1835  | 1      | 234.90KB | NOT CACHED   | PARQUET | true\n| Sports      | 1783  | 1      | 227.97KB | NOT CACHED   | PARQUET | true\n| Women       | 1790  | 1      | 226.27KB | NOT CACHED   | PARQUET | true\n| Total       | 17957 | 10     | 2.25MB   | 0B           |         |\n+-------------+-------+--------+----------+--------------+---------+------------------\n\n-- Add a new partition...\nalter table item_partitioned add partition (i_category='Camping');\n-- Add or replace files in HDFS outside of Impala,\n-- rendering the stats for a partition obsolete.\n!import_data_into_sports_partition.sh\nrefresh item_partitioned;\ndrop incremental stats item_partitioned partition (i_category='Sports');\n-- Now some partitions have incremental stats\n-- and some do not.\nshow table stats item_partitioned;\n+-------------+-------+--------+----------+--------------+---------+------------------\n| i_category  | #Rows | #Files | Size     | Bytes Cached | Format  | Incremental stats\n+-------------+-------+--------+----------+--------------+---------+------------------\n| Books       | 1733  | 1      | 223.74KB | NOT CACHED   | PARQUET | true\n| Camping     | -1    | 1      | 408.02KB | NOT CACHED   | PARQUET | false\n| Children    | 1786  | 1      | 230.05KB | NOT CACHED   | PARQUET | true\n| Electronics | 1812  | 1      | 232.67KB | NOT CACHED   | PARQUET | true\n| Home        | 1807  | 1      | 232.56KB | NOT CACHED   | PARQUET | true\n| Jewelry     | 1740  | 1      | 223.72KB | NOT CACHED   | PARQUET | true\n| Men         | 1811  | 1      | 231.25KB | NOT CACHED   | PARQUET | true\n| Music       | 1860  | 1      | 237.90KB | NOT CACHED   | PARQUET | true\n| Shoes       | 1835  | 1      | 234.90KB | NOT CACHED   | PARQUET | true\n| Sports      | -1    | 1      | 227.97KB | NOT CACHED   | PARQUET | false\n| Women       | 1790  | 1      | 226.27KB | NOT CACHED   | PARQUET | true\n| Total       | 17957 | 11     | 2.65MB   | 0B           |         |\n+-------------+-------+--------+----------+--------------+---------+------------------\n\n-- After another COMPUTE INCREMENTAL STATS,\n-- all partitions have incremental stats, and only the 2\n-- partitions without incremental stats were scanned.\ncompute incremental stats item_partitioned;\n+------------------------------------------+\n| summary                                  |\n+------------------------------------------+\n| Updated 2 partition(s) and 21 column(s). |\n+------------------------------------------+\nshow table stats item_partitioned;\n+-------------+-------+--------+----------+--------------+---------+------------------\n| i_category  | #Rows | #Files | Size     | Bytes Cached | Format  | Incremental stats\n+-------------+-------+--------+----------+--------------+---------+------------------\n| Books       | 1733  | 1      | 223.74KB | NOT CACHED   | PARQUET | true\n| Camping     | 5328  | 1      | 408.02KB | NOT CACHED   | PARQUET | true\n| Children    | 1786  | 1      | 230.05KB | NOT CACHED   | PARQUET | true\n| Electronics | 1812  | 1      | 232.67KB | NOT CACHED   | PARQUET | true\n| Home        | 1807  | 1      | 232.56KB | NOT CACHED   | PARQUET | true\n| Jewelry     | 1740  | 1      | 223.72KB | NOT CACHED   | PARQUET | true\n| Men         | 1811  | 1      | 231.25KB | NOT CACHED   | PARQUET | true\n| Music       | 1860  | 1      | 237.90KB | NOT CACHED   | PARQUET | true\n| Shoes       | 1835  | 1      | 234.90KB | NOT CACHED   | PARQUET | true\n| Sports      | 1783  | 1      | 227.97KB | NOT CACHED   | PARQUET | true\n| Women       | 1790  | 1      | 226.27KB | NOT CACHED   | PARQUET | true\n| Total       | 17957 | 11     | 2.65MB   | 0B           |         |\n+-------------+-------+--------+----------+--------------+---------+------------------\n</div></div></div></div></div>","title":"Partitioning for Impala Tables"}