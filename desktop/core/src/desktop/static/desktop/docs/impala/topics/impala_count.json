{"body":"<div><div><div class=\"hue-doc-title\">COUNT Function</div><div><p>\n      An aggregate function that returns the number of rows, or the number of non-<span class=\"hue-doc-codeph\">NULL</span> rows.\n    </p><p><b>Syntax:</b></p><div class=\"hue-doc-codeblock\">COUNT([DISTINCT | ALL] <span class=\"hue-doc-varname\">expression</span>) [OVER (<span class=\"hue-doc-varname\">analytic_clause</span>)]</div><p>\n      Depending on the argument, <span class=\"hue-doc-codeph\">COUNT()</span> considers rows that meet certain conditions:\n    </p><ul><li>\n        The notation <span class=\"hue-doc-codeph\">COUNT(*)</span> includes <span class=\"hue-doc-codeph\">NULL</span> values in the total.\n      </li><li>\n        The notation <span class=\"hue-doc-codeph\">COUNT(<span class=\"hue-doc-varname\">column_name</span>)</span> only considers rows where the column\n        contains a non-<span class=\"hue-doc-codeph\">NULL</span> value.\n      </li><li>\n        You can also combine <span class=\"hue-doc-codeph\">COUNT</span> with the <span class=\"hue-doc-codeph\">DISTINCT</span> operator to eliminate\n        duplicates before counting, and to count the combinations of values across multiple columns.\n      </li></ul><p>\n      When the query contains a <span class=\"hue-doc-codeph\">GROUP BY</span> clause, returns one value for each combination of\n      grouping values.\n    </p><p><b>Return type:</b><span class=\"hue-doc-codeph\">BIGINT</span></p><p><b>Usage notes:</b></p><p>\n        If you frequently run aggregate functions such as <span class=\"hue-doc-codeph\">MIN()</span>, <span class=\"hue-doc-codeph\">MAX()</span>, and\n        <span class=\"hue-doc-codeph\">COUNT(DISTINCT)</span> on partition key columns, consider enabling the <span class=\"hue-doc-codeph\">OPTIMIZE_PARTITION_KEY_SCANS</span>\n        query option, which optimizes such queries. This feature is available in Impala 2.5 and higher.\n        See <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_optimize_partition_key_scans.html\" target=\"_blank\">OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)</a>\n        for the kinds of queries that this option applies to, and slight differences in how partitions are\n        evaluated when this query option is enabled.\n      </p><p><b>Complex type considerations:</b></p><p>\n        To access a column with a complex type (<span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">STRUCT</span>, or <span class=\"hue-doc-codeph\">MAP</span>)\n        in an aggregation function, you unpack the individual elements using join notation in the query,\n        and then apply the function to the final scalar item, field, key, or value at the bottom of any nested type hierarchy in the column.\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_complex_types.xml\" data-doc-anchor-id=\"complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about using complex types in Impala.\n      </p><p>\nThe following example demonstrates calls to several aggregation functions\nusing values from a column containing nested complex types\n(an <span class=\"hue-doc-codeph\">ARRAY</span> of <span class=\"hue-doc-codeph\">STRUCT</span> items).\nThe array is unpacked inside the query using join notation.\nThe array elements are referenced using the <span class=\"hue-doc-codeph\">ITEM</span>\npseudocolumn, and the structure fields inside the array elements\nare referenced using dot notation.\nNumeric values such as <span class=\"hue-doc-codeph\">SUM()</span> and <span class=\"hue-doc-codeph\">AVG()</span>\nare computed using the numeric <span class=\"hue-doc-codeph\">R_NATIONKEY</span> field, and\nthe general-purpose <span class=\"hue-doc-codeph\">MAX()</span> and <span class=\"hue-doc-codeph\">MIN()</span>\nvalues are computed from the string <span class=\"hue-doc-codeph\">N_NAME</span> field.\n<div class=\"hue-doc-codeblock\">describe region;\n+-------------+-------------------------+---------+\n| name        | type                    | comment |\n+-------------+-------------------------+---------+\n| r_regionkey | smallint                |         |\n| r_name      | string                  |         |\n| r_comment   | string                  |         |\n| r_nations   | array&lt;struct&lt;           |         |\n|             |   n_nationkey:smallint, |         |\n|             |   n_name:string,        |         |\n|             |   n_comment:string      |         |\n|             | &gt;&gt;                      |         |\n+-------------+-------------------------+---------+\n\nselect r_name, r_nations.item.n_nationkey\n  from region, region.r_nations as r_nations\norder by r_name, r_nations.item.n_nationkey;\n+-------------+------------------+\n| r_name      | item.n_nationkey |\n+-------------+------------------+\n| AFRICA      | 0                |\n| AFRICA      | 5                |\n| AFRICA      | 14               |\n| AFRICA      | 15               |\n| AFRICA      | 16               |\n| AMERICA     | 1                |\n| AMERICA     | 2                |\n| AMERICA     | 3                |\n| AMERICA     | 17               |\n| AMERICA     | 24               |\n| ASIA        | 8                |\n| ASIA        | 9                |\n| ASIA        | 12               |\n| ASIA        | 18               |\n| ASIA        | 21               |\n| EUROPE      | 6                |\n| EUROPE      | 7                |\n| EUROPE      | 19               |\n| EUROPE      | 22               |\n| EUROPE      | 23               |\n| MIDDLE EAST | 4                |\n| MIDDLE EAST | 10               |\n| MIDDLE EAST | 11               |\n| MIDDLE EAST | 13               |\n| MIDDLE EAST | 20               |\n+-------------+------------------+\n\nselect\n  r_name,\n  count(r_nations.item.n_nationkey) as count,\n  sum(r_nations.item.n_nationkey) as sum,\n  avg(r_nations.item.n_nationkey) as avg,\n  min(r_nations.item.n_name) as minimum,\n  max(r_nations.item.n_name) as maximum,\n  ndv(r_nations.item.n_nationkey) as distinct_vals\nfrom\n  region, region.r_nations as r_nations\ngroup by r_name\norder by r_name;\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |\n| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |\n| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |\n| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |\n| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |\n+-------------+-------+-----+------+-----------+----------------+---------------+\n</div></p><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">-- How many rows total are in the table, regardless of NULL values?\nselect count(*) from t1;\n-- How many rows are in the table with non-NULL values for a column?\nselect count(c1) from t1;\n-- Count the rows that meet certain conditions.\n-- Again, * includes NULLs, so COUNT(*) might be greater than COUNT(col).\nselect count(*) from t1 where x &gt; 10;\nselect count(c1) from t1 where x &gt; 10;\n-- Can also be used in combination with DISTINCT and/or GROUP BY.\n-- Combine COUNT and DISTINCT to find the number of unique values.\n-- Must use column names rather than * with COUNT(DISTINCT ...) syntax.\n-- Rows with NULL values are not counted.\nselect count(distinct c1) from t1;\n-- Rows with a NULL value in _either_ column are not counted.\nselect count(distinct c1, c2) from t1;\n-- Return more than one result.\nselect month, year, count(distinct visitor_id) from web_stats group by month, year;\n</div><p>\n      The following examples show how to use <span class=\"hue-doc-codeph\">COUNT()</span> in an analytic context. They use a table\n      containing integers from 1 to 10. Notice how the <span class=\"hue-doc-codeph\">COUNT()</span> is reported for each input value, as\n      opposed to the <span class=\"hue-doc-codeph\">GROUP BY</span> clause which condenses the result set.\n<div class=\"hue-doc-codeblock\">select x, property, count(x) over (partition by property) as count from int_t where property in ('odd','even');\n+----+----------+-------+\n| x  | property | count |\n+----+----------+-------+\n| 2  | even     | 5     |\n| 4  | even     | 5     |\n| 6  | even     | 5     |\n| 8  | even     | 5     |\n| 10 | even     | 5     |\n| 1  | odd      | 5     |\n| 3  | odd      | 5     |\n| 5  | odd      | 5     |\n| 7  | odd      | 5     |\n| 9  | odd      | 5     |\n+----+----------+-------+\n</div>\n\nAdding an <span class=\"hue-doc-codeph\">ORDER BY</span> clause lets you experiment with results that are cumulative or apply to a moving\nset of rows (the <q>window</q>). The following examples use <span class=\"hue-doc-codeph\">COUNT()</span> in an analytic context\n(that is, with an <span class=\"hue-doc-codeph\">OVER()</span> clause) to produce a running count of all the even values,\nthen a running count of all the odd values. The basic <span class=\"hue-doc-codeph\">ORDER BY x</span> clause implicitly\nactivates a window clause of <span class=\"hue-doc-codeph\">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\nwhich is effectively the same as <span class=\"hue-doc-codeph\">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\ntherefore all of these examples produce the same results:\n<div class=\"hue-doc-codeblock\">select x, property,\n  count(x) over (partition by property <b>order by x</b>) as 'cumulative count'\n  from int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative count |\n+----+----------+------------------+\n| 2  | even     | 1                |\n| 4  | even     | 2                |\n| 6  | even     | 3                |\n| 8  | even     | 4                |\n| 10 | even     | 5                |\n| 1  | odd      | 1                |\n| 3  | odd      | 2                |\n| 5  | odd      | 3                |\n| 7  | odd      | 4                |\n| 9  | odd      | 5                |\n+----+----------+------------------+\n\nselect x, property,\n  count(x) over\n  (\n    partition by property\n    <b>order by x</b><b>range between unbounded preceding and current row</b>\n  ) as 'cumulative total'\nfrom int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative count |\n+----+----------+------------------+\n| 2  | even     | 1                |\n| 4  | even     | 2                |\n| 6  | even     | 3                |\n| 8  | even     | 4                |\n| 10 | even     | 5                |\n| 1  | odd      | 1                |\n| 3  | odd      | 2                |\n| 5  | odd      | 3                |\n| 7  | odd      | 4                |\n| 9  | odd      | 5                |\n+----+----------+------------------+\n\nselect x, property,\n  count(x) over\n  (\n    partition by property\n    <b>order by x</b><b>rows between unbounded preceding and current row</b>\n  ) as 'cumulative total'\n  from int_t where property in ('odd','even');\n+----+----------+------------------+\n| x  | property | cumulative count |\n+----+----------+------------------+\n| 2  | even     | 1                |\n| 4  | even     | 2                |\n| 6  | even     | 3                |\n| 8  | even     | 4                |\n| 10 | even     | 5                |\n| 1  | odd      | 1                |\n| 3  | odd      | 2                |\n| 5  | odd      | 3                |\n| 7  | odd      | 4                |\n| 9  | odd      | 5                |\n+----+----------+------------------+\n</div>\n\nThe following examples show how to construct a moving window, with a running count taking into account 1 row before\nand 1 row after the current row, within the same partition (all the even values or all the odd values).\nTherefore, the count is consistently 3 for rows in the middle of the window, and 2 for\nrows near the ends of the window, where there is no preceding or no following row in the partition.\nBecause of a restriction in the Impala <span class=\"hue-doc-codeph\">RANGE</span> syntax, this type of\nmoving window is possible with the <span class=\"hue-doc-codeph\">ROWS BETWEEN</span> clause but not the <span class=\"hue-doc-codeph\">RANGE BETWEEN</span>\nclause:\n<div class=\"hue-doc-codeblock\">select x, property,\n  count(x) over\n  (\n    partition by property\n    <b>order by x</b><b>rows between 1 preceding and 1 following</b>\n  ) as 'moving total'\n  from int_t where property in ('odd','even');\n+----+----------+--------------+\n| x  | property | moving total |\n+----+----------+--------------+\n| 2  | even     | 2            |\n| 4  | even     | 3            |\n| 6  | even     | 3            |\n| 8  | even     | 3            |\n| 10 | even     | 2            |\n| 1  | odd      | 2            |\n| 3  | odd      | 3            |\n| 5  | odd      | 3            |\n| 7  | odd      | 3            |\n| 9  | odd      | 2            |\n+----+----------+--------------+\n\n-- Doesn't work because of syntax restriction on RANGE clause.\nselect x, property,\n  count(x) over\n  (\n    partition by property\n    <b>order by x</b><b>range between 1 preceding and 1 following</b>\n  ) as 'moving total'\nfrom int_t where property in ('odd','even');\nERROR: AnalysisException: RANGE is only supported with both the lower and upper bounds UNBOUNDED or one UNBOUNDED and the other CURRENT ROW.\n</div></p><div class=\"hue-doc-note\"><p>\n          By default, Impala only allows a single <span class=\"hue-doc-codeph\">COUNT(DISTINCT <span class=\"hue-doc-varname\">columns</span>)</span>\n          expression in each query.\n        </p><p>\n          If you do not need precise accuracy, you can produce an estimate of the distinct values for a column by\n          specifying <span class=\"hue-doc-codeph\">NDV(<span class=\"hue-doc-varname\">column</span>)</span>; a query can contain multiple instances of\n          <span class=\"hue-doc-codeph\">NDV(<span class=\"hue-doc-varname\">column</span>)</span>. To make Impala automatically rewrite\n          <span class=\"hue-doc-codeph\">COUNT(DISTINCT)</span> expressions to <span class=\"hue-doc-codeph\">NDV()</span>, enable the\n          <span class=\"hue-doc-codeph\">APPX_COUNT_DISTINCT</span> query option.\n        </p><p>\n          To produce the same result as multiple <span class=\"hue-doc-codeph\">COUNT(DISTINCT)</span> expressions, you can use the\n          following technique for queries involving a single table:\n        </p><div class=\"hue-doc-codeblock\">select v1.c1 result1, v2.c1 result2 from\n  (select count(distinct col1) as c1 from t1) v1\n    cross join\n  (select count(distinct col2) as c1 from t1) v2;\n</div><p>\n          Because <span class=\"hue-doc-codeph\">CROSS JOIN</span> is an expensive operation, prefer to use the <span class=\"hue-doc-codeph\">NDV()</span>\n          technique wherever practical.\n        </p></div><p><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_analytic_functions.xml\" data-doc-anchor-id=\"analytic_functions\">Impala Analytic Functions</a></p></div></div></div>","title":"COUNT Function"}