{"body":"<div><div><div class=\"hue-doc-title\">DECIMAL Data Type (Impala 1.4 or higher only)</div><div><p>\n      A numeric data type with fixed scale and precision, used in <span class=\"hue-doc-codeph\">CREATE TABLE</span> and <span class=\"hue-doc-codeph\">ALTER\n      TABLE</span> statements. Suitable for financial and other arithmetic calculations where the imprecise\n      representation and rounding behavior of <span class=\"hue-doc-codeph\">FLOAT</span> and <span class=\"hue-doc-codeph\">DOUBLE</span> make those types\n      impractical.\n    </p><p><b>Syntax:</b></p><p>\n      In the column definition of a <span class=\"hue-doc-codeph\">CREATE TABLE</span> statement:\n    </p><div class=\"hue-doc-codeblock\"><span class=\"hue-doc-varname\">column_name</span> DECIMAL[(<span class=\"hue-doc-varname\">precision</span>[,<span class=\"hue-doc-varname\">scale</span>])]</div><p><span class=\"hue-doc-codeph\">DECIMAL</span> with no precision or scale values is equivalent to <span class=\"hue-doc-codeph\">DECIMAL(9,0)</span>.\n    </p><p><b>Precision and Scale:</b></p><p><span class=\"hue-doc-varname\">precision</span> represents the total number of digits that can be represented by the column,\n      regardless of the location of the decimal point. This value must be between 1 and 38. For example,\n      representing integer values up to 9999, and floating-point values up to 99.99, both require a precision of 4.\n      You can also represent corresponding negative values, without any change in the precision. For example, the\n      range -9999 to 9999 still only requires a precision of 4.\n    </p><p><span class=\"hue-doc-varname\">scale</span> represents the number of fractional digits. This value must be less than or equal to\n      <span class=\"hue-doc-varname\">precision</span>. A scale of 0 produces integral values, with no fractional part. If precision\n      and scale are equal, all the digits come after the decimal point, making all the values between 0 and\n      0.999... or 0 and -0.999...\n    </p><p>\n      When <span class=\"hue-doc-varname\">precision</span> and <span class=\"hue-doc-varname\">scale</span> are omitted, a <span class=\"hue-doc-codeph\">DECIMAL</span> value\n      is treated as <span class=\"hue-doc-codeph\">DECIMAL(9,0)</span>, that is, an integer value ranging from\n      <span class=\"hue-doc-codeph\">-999,999,999</span> to <span class=\"hue-doc-codeph\">999,999,999</span>. This is the largest <span class=\"hue-doc-codeph\">DECIMAL</span>\n      value that can still be represented in 4 bytes. If precision is specified but scale is omitted, Impala uses a\n      value of zero for the scale.\n    </p><p>\n      Both <span class=\"hue-doc-varname\">precision</span> and <span class=\"hue-doc-varname\">scale</span> must be specified as integer literals, not any\n      other kind of constant expressions.\n    </p><p>\n      To check the precision or scale for arbitrary values, you can call the\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_math_functions.xml\" data-doc-anchor-id=\"math_functions\"><span class=\"hue-doc-codeph\">precision()</span> and\n      <span class=\"hue-doc-codeph\">scale()</span> built-in functions</a>. For example, you might use these values to figure out how\n      many characters are required for various fields in a report, or to understand the rounding characteristics of\n      a formula as applied to a particular <span class=\"hue-doc-codeph\">DECIMAL</span> column.\n    </p><p><b>Range:</b></p><p>\n      The maximum precision value is 38. Thus, the largest integral value is represented by\n      <span class=\"hue-doc-codeph\">DECIMAL(38,0)</span> (999... with 9 repeated 38 times). The most precise fractional value (between\n      0 and 1, or 0 and -1) is represented by <span class=\"hue-doc-codeph\">DECIMAL(38,38)</span>, with 38 digits to the right of the\n      decimal point. The value closest to 0 would be .0000...1 (37 zeros and the final 1). The value closest to 1\n      would be .999... (9 repeated 38 times).\n    </p><p>\n      For a given precision and scale, the range of <span class=\"hue-doc-codeph\">DECIMAL</span> values is the same in the positive and\n      negative directions. For example, <span class=\"hue-doc-codeph\">DECIMAL(4,2)</span> can represent from -99.99 to 99.99. This is\n      different from other integral numeric types where the positive and negative bounds differ slightly.\n    </p><p>\n      When you use <span class=\"hue-doc-codeph\">DECIMAL</span> values in arithmetic expressions, the precision and scale of the result\n      value are determined as follows:\n    </p><ul><li><p>\n          For addition and subtraction, the precision and scale are based on the maximum possible result, that is,\n          if all the digits of the input values were 9s and the absolute values were added together.\n        </p></li><li><p>\n          For multiplication, the precision is the sum of the precisions of the input values. The scale is the sum\n          of the scales of the input values.\n        </p></li><li><p>\n          For division, Impala sets the precision and scale to values large enough to represent the whole and\n          fractional parts of the result.\n        </p></li><li><p>\n          For <span class=\"hue-doc-codeph\">UNION</span>, the scale is the larger of the scales of the input values, and the precision\n          is increased if necessary to accommodate any additional fractional digits. If the same input value has\n          the largest precision and the largest scale, the result value has the same precision and scale. If one\n          value has a larger precision but smaller scale, the scale of the result value is increased. For example,\n          <span class=\"hue-doc-codeph\">DECIMAL(20,2) UNION DECIMAL(8,6)</span> produces a result of type\n          <span class=\"hue-doc-codeph\">DECIMAL(24,6)</span>. The extra 4 fractional digits of scale (6-2) are accommodated by\n          extending the precision by the same amount (20+4).\n        </p></li><li><p>\n          To doublecheck, you can always call the <span class=\"hue-doc-codeph\">PRECISION()</span> and <span class=\"hue-doc-codeph\">SCALE()</span>\n          functions on the results of an arithmetic expression to see the relevant values, or use a <span class=\"hue-doc-codeph\">CREATE\n          TABLE AS SELECT</span> statement to define a column based on the return type of the expression.\n        </p></li></ul><p><b>Compatibility:</b></p><ul><li>\n        Using the <span class=\"hue-doc-codeph\">DECIMAL</span> type is only supported under Impala 1.4 and higher.\n      </li><li>\n        Use the <span class=\"hue-doc-codeph\">DECIMAL</span> data type in Impala for applications where you used the\n        <span class=\"hue-doc-codeph\">NUMBER</span> data type in Oracle. The Impala <span class=\"hue-doc-codeph\">DECIMAL</span> type does not support the\n        Oracle idioms of <span class=\"hue-doc-codeph\">*</span> for scale or negative values for precision.\n      </li></ul><p><b>Conversions and casting:</b></p><p><span class=\"hue-doc-ph\">\n          Casting an integer or floating-point value <span class=\"hue-doc-codeph\">N</span> to\n        <span class=\"hue-doc-codeph\">TIMESTAMP</span> produces a value that is <span class=\"hue-doc-codeph\">N</span> seconds past the start of the epoch\n        date (January 1, 1970). By default, the result value represents a date and time in the UTC time zone.\n        If the setting <span class=\"hue-doc-codeph\">--use_local_tz_for_unix_timestamp_conversions=true</span> is in effect,\n        the resulting <span class=\"hue-doc-codeph\">TIMESTAMP</span> represents a date and time in the local time zone.\n        </span></p><p>\n      Impala automatically converts between <span class=\"hue-doc-codeph\">DECIMAL</span> and other numeric types where possible. A\n      <span class=\"hue-doc-codeph\">DECIMAL</span> with zero scale is converted to or from the smallest appropriate integral type. A\n      <span class=\"hue-doc-codeph\">DECIMAL</span> with a fractional part is automatically converted to or from the smallest\n      appropriate floating-point type. If the destination type does not have sufficient precision or scale to hold\n      all possible values of the source type, Impala raises an error and does not convert the value.\n    </p><p>\n      For example, these statements show how expressions of <span class=\"hue-doc-codeph\">DECIMAL</span> and other types are reconciled\n      to the same type in the context of <span class=\"hue-doc-codeph\">UNION</span> queries and <span class=\"hue-doc-codeph\">INSERT</span> statements:\n    </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select cast(1 as int) as x union select cast(1.5 as decimal(9,4)) as x;\n+----------------+\n| x              |\n+----------------+\n| 1.5000         |\n| 1.0000         |\n+----------------+\n[localhost:21000] &gt; create table int_vs_decimal as select cast(1 as int) as x union select cast(1.5 as decimal(9,4)) as x;\n+-------------------+\n| summary           |\n+-------------------+\n| Inserted 2 row(s) |\n+-------------------+\n[localhost:21000] &gt; desc int_vs_decimal;\n+------+---------------+---------+\n| name | type          | comment |\n+------+---------------+---------+\n| x    | decimal(14,4) |         |\n+------+---------------+---------+\n</div><p>\n      To avoid potential conversion errors, you can use <span class=\"hue-doc-codeph\">CAST()</span> to convert <span class=\"hue-doc-codeph\">DECIMAL</span>\n      values to <span class=\"hue-doc-codeph\">FLOAT</span>, <span class=\"hue-doc-codeph\">TINYINT</span>, <span class=\"hue-doc-codeph\">SMALLINT</span>, <span class=\"hue-doc-codeph\">INT</span>,\n      <span class=\"hue-doc-codeph\">BIGINT</span>, <span class=\"hue-doc-codeph\">STRING</span>, <span class=\"hue-doc-codeph\">TIMESTAMP</span>, or <span class=\"hue-doc-codeph\">BOOLEAN</span>.\n      You can use exponential notation in <span class=\"hue-doc-codeph\">DECIMAL</span> literals or when casting from\n      <span class=\"hue-doc-codeph\">STRING</span>, for example <span class=\"hue-doc-codeph\">1.0e6</span> to represent one million.\n    </p><p>\n      If you cast a value with more fractional digits than the scale of the destination type, any extra fractional\n      digits are truncated (not rounded). Casting a value to a target type with not enough precision produces a\n      result of <span class=\"hue-doc-codeph\">NULL</span> and displays a runtime warning.\n    </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select cast(1.239 as decimal(3,2));\n+-----------------------------+\n| cast(1.239 as decimal(3,2)) |\n+-----------------------------+\n| 1.23                        |\n+-----------------------------+\n[localhost:21000] &gt; select cast(1234 as decimal(3));\n+----------------------------+\n| cast(1234 as decimal(3,0)) |\n+----------------------------+\n| NULL                       |\n+----------------------------+\nWARNINGS: Expression overflowed, returning NULL\n</div><p>\n      When you specify integer literals, for example in <span class=\"hue-doc-codeph\">INSERT ... VALUES</span> statements or arithmetic\n      expressions, those numbers are interpreted as the smallest applicable integer type. You must use\n      <span class=\"hue-doc-codeph\">CAST()</span> calls for some combinations of integer literals and <span class=\"hue-doc-codeph\">DECIMAL</span>\n      precision. For example, <span class=\"hue-doc-codeph\">INT</span> has a maximum value that is 10 digits long,\n      <span class=\"hue-doc-codeph\">TINYINT</span> has a maximum value that is 3 digits long, and so on. If you specify a value such as\n      123456 to go into a <span class=\"hue-doc-codeph\">DECIMAL</span> column, Impala checks if the column has enough precision to\n      represent the largest value of that integer type, and raises an error if not. Therefore, use an expression\n      like <span class=\"hue-doc-codeph\">CAST(123456 TO DECIMAL(9,0))</span> for <span class=\"hue-doc-codeph\">DECIMAL</span> columns with precision 9 or\n      less, <span class=\"hue-doc-codeph\">CAST(50 TO DECIMAL(2,0))</span> for <span class=\"hue-doc-codeph\">DECIMAL</span> columns with precision 2 or\n      less, and so on. For <span class=\"hue-doc-codeph\">DECIMAL</span> columns with precision 10 or greater, Impala automatically\n      interprets the value as the correct <span class=\"hue-doc-codeph\">DECIMAL</span> type; however, because\n      <span class=\"hue-doc-codeph\">DECIMAL(10)</span> requires 8 bytes of storage while <span class=\"hue-doc-codeph\">DECIMAL(9)</span> requires only 4\n      bytes, only use precision of 10 or higher when actually needed.\n    </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table decimals_9_0 (x decimal);\n[localhost:21000] &gt; insert into decimals_9_0 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000);\nERROR: AnalysisException: Possible loss of precision for target table 'decimal_testing.decimals_9_0'.\nExpression '1' (type: INT) would need to be cast to DECIMAL(9,0) for column 'x'\n[localhost:21000] &gt; insert into decimals_9_0 values (cast(1 as decimal)), (cast(2 as decimal)), (cast(4 as decimal)), (cast(8 as decimal)), (cast(16 as decimal)), (cast(1024 as decimal)), (cast(32768 as decimal)), (cast(65536 as decimal)), (cast(1000000 as decimal));\n\n[localhost:21000] &gt; create table decimals_10_0 (x decimal(10,0));\n[localhost:21000] &gt; insert into decimals_10_0 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000);\n</div><p>\n      Be aware that in memory and for binary file formats such as Parquet or Avro, <span class=\"hue-doc-codeph\">DECIMAL(10)</span> or\n      higher consumes 8 bytes while <span class=\"hue-doc-codeph\">DECIMAL(9)</span> (the default for <span class=\"hue-doc-codeph\">DECIMAL</span>) or lower\n      consumes 4 bytes. Therefore, to conserve space in large tables, use the smallest-precision\n      <span class=\"hue-doc-codeph\">DECIMAL</span> type that is appropriate and <span class=\"hue-doc-codeph\">CAST()</span> literal values where necessary,\n      rather than declaring <span class=\"hue-doc-codeph\">DECIMAL</span> columns with high precision for convenience.\n    </p><p>\n      To represent a very large or precise <span class=\"hue-doc-codeph\">DECIMAL</span> value as a literal, for example one that\n      contains more digits than can be represented by a <span class=\"hue-doc-codeph\">BIGINT</span> literal, use a quoted string or a\n      floating-point value for the number, and <span class=\"hue-doc-codeph\">CAST()</span> to the desired <span class=\"hue-doc-codeph\">DECIMAL</span>\n      type:\n    </p><div class=\"hue-doc-codeblock\">insert into decimals_38_5 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000),\n  (cast(\"999999999999999999999999999999\" as decimal(38,5))),\n  (cast(999999999999999999999999999999. as decimal(38,5)));\n</div><ul><li><p> The result of the <span class=\"hue-doc-codeph\">SUM()</span> aggregate function on\n            <span class=\"hue-doc-codeph\">DECIMAL</span> values is promoted to a precision of 38,\n          with the same precision as the underlying column. Thus, the result can\n          represent the largest possible value at that particular precision. </p></li><li><p><span class=\"hue-doc-codeph\">STRING</span> columns, literals, or expressions can be converted to <span class=\"hue-doc-codeph\">DECIMAL</span> as\n          long as the overall number of digits and digits to the right of the decimal point fit within the\n          specified precision and scale for the declared <span class=\"hue-doc-codeph\">DECIMAL</span> type. By default, a\n          <span class=\"hue-doc-codeph\">DECIMAL</span> value with no specified scale or precision can hold a maximum of 9 digits of an\n          integer value. If there are more digits in the string value than are allowed by the\n          <span class=\"hue-doc-codeph\">DECIMAL</span> scale and precision, the result is <span class=\"hue-doc-codeph\">NULL</span>.\n        </p><p>\n          The following examples demonstrate how <span class=\"hue-doc-codeph\">STRING</span> values with integer and fractional parts\n          are represented when converted to <span class=\"hue-doc-codeph\">DECIMAL</span>. If the scale is 0, the number is treated\n          as an integer value with a maximum of <span class=\"hue-doc-varname\">precision</span> digits. If the precision is greater than\n          0, the scale must be increased to account for the digits both to the left and right of the decimal point.\n          As the precision increases, output values are printed with additional trailing zeros after the decimal\n          point if needed. Any trailing zeros after the decimal point in the <span class=\"hue-doc-codeph\">STRING</span> value must fit\n          within the number of digits specified by the precision.\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select cast('100' as decimal); -- Small integer value fits within 9 digits of scale.\n+-----------------------------+\n| cast('100' as decimal(9,0)) |\n+-----------------------------+\n| 100                         |\n+-----------------------------+\n[localhost:21000] &gt; select cast('100' as decimal(3,0)); -- Small integer value fits within 3 digits of scale.\n+-----------------------------+\n| cast('100' as decimal(3,0)) |\n+-----------------------------+\n| 100                         |\n+-----------------------------+\n[localhost:21000] &gt; select cast('100' as decimal(2,0)); -- 2 digits of scale is not enough!\n+-----------------------------+\n| cast('100' as decimal(2,0)) |\n+-----------------------------+\n| NULL                        |\n+-----------------------------+\n[localhost:21000] &gt; select cast('100' as decimal(3,1)); -- (3,1) = 2 digits left of the decimal point, 1 to the right. Not enough.\n+-----------------------------+\n| cast('100' as decimal(3,1)) |\n+-----------------------------+\n| NULL                        |\n+-----------------------------+\n[localhost:21000] &gt; select cast('100' as decimal(4,1)); -- 4 digits total, 1 to the right of the decimal point.\n+-----------------------------+\n| cast('100' as decimal(4,1)) |\n+-----------------------------+\n| 100.0                       |\n+-----------------------------+\n[localhost:21000] &gt; select cast('98.6' as decimal(3,1)); -- (3,1) can hold a 3 digit number with 1 fractional digit.\n+------------------------------+\n| cast('98.6' as decimal(3,1)) |\n+------------------------------+\n| 98.6                         |\n+------------------------------+\n[localhost:21000] &gt; select cast('98.6' as decimal(15,1)); -- Larger scale allows bigger numbers but still only 1 fractional digit.\n+-------------------------------+\n| cast('98.6' as decimal(15,1)) |\n+-------------------------------+\n| 98.6                          |\n+-------------------------------+\n[localhost:21000] &gt; select cast('98.6' as decimal(15,5)); -- Larger precision allows more fractional digits, outputs trailing zeros.\n+-------------------------------+\n| cast('98.6' as decimal(15,5)) |\n+-------------------------------+\n| 98.60000                      |\n+-------------------------------+\n[localhost:21000] &gt; select cast('98.60000' as decimal(15,1)); -- Trailing zeros in the string must fit within 'scale' digits (1 in this case).\n+-----------------------------------+\n| cast('98.60000' as decimal(15,1)) |\n+-----------------------------------+\n| NULL                              |\n+-----------------------------------+\n</div></li><li>\n        Most built-in arithmetic functions such as <span class=\"hue-doc-codeph\">SIN()</span> and <span class=\"hue-doc-codeph\">COS()</span> continue to\n        accept only <span class=\"hue-doc-codeph\">DOUBLE</span> values because they are so commonly used in scientific context for\n        calculations of IEEE 954-compliant values. The built-in functions that accept and return\n        <span class=\"hue-doc-codeph\">DECIMAL</span> are:\n<ul><li><span class=\"hue-doc-codeph\">ABS()</span></li><li><span class=\"hue-doc-codeph\">CEIL()</span></li><li><span class=\"hue-doc-codeph\">COALESCE()</span></li><li><span class=\"hue-doc-codeph\">FLOOR()</span></li><li><span class=\"hue-doc-codeph\">FNV_HASH()</span></li><li><span class=\"hue-doc-codeph\">GREATEST()</span></li><li><span class=\"hue-doc-codeph\">IF()</span></li><li><span class=\"hue-doc-codeph\">ISNULL()</span></li><li><span class=\"hue-doc-codeph\">LEAST()</span></li><li><span class=\"hue-doc-codeph\">NEGATIVE()</span></li><li><span class=\"hue-doc-codeph\">NULLIF()</span></li><li><span class=\"hue-doc-codeph\">POSITIVE()</span></li><li><span class=\"hue-doc-codeph\">PRECISION()</span></li><li><span class=\"hue-doc-codeph\">ROUND()</span></li><li><span class=\"hue-doc-codeph\">SCALE()</span></li><li><span class=\"hue-doc-codeph\">TRUNCATE()</span></li><li><span class=\"hue-doc-codeph\">ZEROIFNULL()</span></li></ul>\n        See <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_functions.xml\" data-doc-anchor-id=\"builtins\">Impala Built-In Functions</a> for details.\n      </li><li><p><span class=\"hue-doc-codeph\">BIGINT</span>, <span class=\"hue-doc-codeph\">INT</span>, <span class=\"hue-doc-codeph\">SMALLINT</span>, and <span class=\"hue-doc-codeph\">TINYINT</span>\n          values can all be cast to <span class=\"hue-doc-codeph\">DECIMAL</span>. The number of digits to the left of the decimal point\n          in the <span class=\"hue-doc-codeph\">DECIMAL</span> type must be sufficient to hold the largest value of the corresponding\n          integer type. Note that integer literals are treated as the smallest appropriate integer type, meaning\n          there is sometimes a range of values that require one more digit of <span class=\"hue-doc-codeph\">DECIMAL</span> scale than\n          you might expect. For integer values, the precision of the <span class=\"hue-doc-codeph\">DECIMAL</span> type can be zero; if\n          the precision is greater than zero, remember to increase the scale value by an equivalent amount to hold\n          the required number of digits to the left of the decimal point.\n        </p><p>\n          The following examples show how different integer types are converted to <span class=\"hue-doc-codeph\">DECIMAL</span>.\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select cast(1 as decimal(1,0));\n+-------------------------+\n| cast(1 as decimal(1,0)) |\n+-------------------------+\n| 1                       |\n+-------------------------+\n[localhost:21000] &gt; select cast(9 as decimal(1,0));\n+-------------------------+\n| cast(9 as decimal(1,0)) |\n+-------------------------+\n| 9                       |\n+-------------------------+\n[localhost:21000] &gt; select cast(10 as decimal(1,0));\n+--------------------------+\n| cast(10 as decimal(1,0)) |\n+--------------------------+\n| 10                       |\n+--------------------------+\n[localhost:21000] &gt; select cast(10 as decimal(1,1));\n+--------------------------+\n| cast(10 as decimal(1,1)) |\n+--------------------------+\n| 10.0                     |\n+--------------------------+\n[localhost:21000] &gt; select cast(100 as decimal(1,1));\n+---------------------------+\n| cast(100 as decimal(1,1)) |\n+---------------------------+\n| 100.0                     |\n+---------------------------+\n[localhost:21000] &gt; select cast(1000 as decimal(1,1));\n+----------------------------+\n| cast(1000 as decimal(1,1)) |\n+----------------------------+\n| 1000.0                     |\n+----------------------------+\n</div></li><li><p>\n          When a <span class=\"hue-doc-codeph\">DECIMAL</span> value is converted to any of the integer types, any fractional part is\n          truncated (that is, rounded towards zero):\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table num_dec_days (x decimal(4,1));\n[localhost:21000] &gt; insert into num_dec_days values (1), (2), (cast(4.5 as decimal(4,1)));\n[localhost:21000] &gt; insert into num_dec_days values (cast(0.1 as decimal(4,1))), (cast(.9 as decimal(4,1))), (cast(9.1 as decimal(4,1))), (cast(9.9 as decimal(4,1)));\n[localhost:21000] &gt; select cast(x as int) from num_dec_days;\n+----------------+\n| cast(x as int) |\n+----------------+\n| 1              |\n| 2              |\n| 4              |\n| 0              |\n| 0              |\n| 9              |\n| 9              |\n+----------------+\n</div></li><li><p>\n          You cannot directly cast <span class=\"hue-doc-codeph\">TIMESTAMP</span> or <span class=\"hue-doc-codeph\">BOOLEAN</span> values to or from\n          <span class=\"hue-doc-codeph\">DECIMAL</span> values. You can turn a <span class=\"hue-doc-codeph\">DECIMAL</span> value into a time-related\n          representation using a two-step process, by converting it to an integer value and then using that result\n          in a call to a date and time function such as <span class=\"hue-doc-codeph\">from_unixtime()</span>.\n        </p><div class=\"hue-doc-codeblock\">[localhost:21000] &gt; select from_unixtime(cast(cast(1000.0 as decimal) as bigint));\n+-------------------------------------------------------------+\n| from_unixtime(cast(cast(1000.0 as decimal(9,0)) as bigint)) |\n+-------------------------------------------------------------+\n| 1970-01-01 00:16:40                                         |\n+-------------------------------------------------------------+\n[localhost:21000] &gt; select now() + interval cast(x as int) days from num_dec_days; -- x is a DECIMAL column.\n\n[localhost:21000] &gt; create table num_dec_days (x decimal(4,1));\n[localhost:21000] &gt; insert into num_dec_days values (1), (2), (cast(4.5 as decimal(4,1)));\n[localhost:21000] &gt; select now() + interval cast(x as int) days from num_dec_days; -- The 4.5 value is truncated to 4 and becomes '4 days'.\n+--------------------------------------+\n| now() + interval cast(x as int) days |\n+--------------------------------------+\n| 2014-05-13 23:11:55.163284000        |\n| 2014-05-14 23:11:55.163284000        |\n| 2014-05-16 23:11:55.163284000        |\n+--------------------------------------+\n</div></li><li><p>\n          Because values in <span class=\"hue-doc-codeph\">INSERT</span> statements are checked rigorously for type compatibility, be\n          prepared to use <span class=\"hue-doc-codeph\">CAST()</span> function calls around literals, column references, or other\n          expressions that you are inserting into a <span class=\"hue-doc-codeph\">DECIMAL</span> column.\n        </p></li></ul><p><b>NULL considerations:</b> Casting any non-numeric value to this type produces a <span class=\"hue-doc-codeph\">NULL</span>\n        value.\n      </p><p><b>DECIMAL differences from integer and floating-point types:</b></p><p>\n      With the <span class=\"hue-doc-codeph\">DECIMAL</span> type, you are concerned with the number of overall digits of a number\n      rather than powers of 2 (as in <span class=\"hue-doc-codeph\">TINYINT</span>, <span class=\"hue-doc-codeph\">SMALLINT</span>, and so on). Therefore,\n      the limits with integral values of <span class=\"hue-doc-codeph\">DECIMAL</span> types fall around 99, 999, 9999, and so on rather\n      than 32767, 65535, 2\n      <sup>32</sup>\n      -1, and so on. For fractional values, you do not need to account for imprecise representation of the\n      fractional part according to the IEEE-954 standard (as in <span class=\"hue-doc-codeph\">FLOAT</span> and\n      <span class=\"hue-doc-codeph\">DOUBLE</span>). Therefore, when you insert a fractional value into a <span class=\"hue-doc-codeph\">DECIMAL</span>\n      column, you can compare, sum, query, <span class=\"hue-doc-codeph\">GROUP BY</span>, and so on that column and get back the\n      original values rather than some <q>close but not identical</q> value.\n    </p><p><span class=\"hue-doc-codeph\">FLOAT</span> and <span class=\"hue-doc-codeph\">DOUBLE</span> can cause problems or unexpected behavior due to inability\n      to precisely represent certain fractional values, for example dollar and cents values for currency. You might\n      find output values slightly different than you inserted, equality tests that do not match precisely, or\n      unexpected values for <span class=\"hue-doc-codeph\">GROUP BY</span> columns. <span class=\"hue-doc-codeph\">DECIMAL</span> can help reduce unexpected\n      behavior and rounding errors, at the expense of some performance overhead for assignments and comparisons.\n    </p><p><b>Literals and expressions:</b><ul><li><p>\n            When you use an integer literal such as <span class=\"hue-doc-codeph\">1</span> or <span class=\"hue-doc-codeph\">999</span> in a SQL statement,\n            depending on the context, Impala will treat it as either the smallest appropriate\n            <span class=\"hue-doc-codeph\">DECIMAL</span> type, or the smallest integer type (<span class=\"hue-doc-codeph\">TINYINT</span>,\n            <span class=\"hue-doc-codeph\">SMALLINT</span>, <span class=\"hue-doc-codeph\">INT</span>, or <span class=\"hue-doc-codeph\">BIGINT</span>). To minimize memory usage,\n            Impala prefers to treat the literal as the smallest appropriate integer type.\n          </p></li><li><p>\n            When you use a floating-point literal such as <span class=\"hue-doc-codeph\">1.1</span> or <span class=\"hue-doc-codeph\">999.44</span> in a SQL\n            statement, depending on the context, Impala will treat it as either the smallest appropriate\n            <span class=\"hue-doc-codeph\">DECIMAL</span> type, or the smallest floating-point type (<span class=\"hue-doc-codeph\">FLOAT</span> or\n            <span class=\"hue-doc-codeph\">DOUBLE</span>). To avoid loss of accuracy, Impala prefers to treat the literal as a\n            <span class=\"hue-doc-codeph\">DECIMAL</span>.\n          </p></li></ul></p><p><b>Storage considerations:</b></p><ul><li>\n        Only the precision determines the storage size for <span class=\"hue-doc-codeph\">DECIMAL</span> values; the scale setting has\n        no effect on the storage size.\n      </li><li>\n        Text, RCFile, and SequenceFile tables all use ASCII-based formats. In these text-based file formats,\n        leading zeros are not stored, but trailing zeros are stored. In these tables, each <span class=\"hue-doc-codeph\">DECIMAL</span>\n        value takes up as many bytes as there are digits in the value, plus an extra byte if the decimal point is\n        present and an extra byte for negative values. Once the values are loaded into memory, they are represented\n        in 4, 8, or 16 bytes as described in the following list items. The on-disk representation varies depending\n        on the file format of the table.\n      </li><li>\n        Parquet and Avro tables use binary formats, In these tables, Impala stores each value in as few bytes as\n        possible\n\n        depending on the precision specified for the <span class=\"hue-doc-codeph\">DECIMAL</span> column.\n        <ul><li>\n            In memory, <span class=\"hue-doc-codeph\">DECIMAL</span> values with precision of 9 or less are stored in 4 bytes.\n          </li><li>\n            In memory, <span class=\"hue-doc-codeph\">DECIMAL</span> values with precision of 10 through 18 are stored in 8 bytes.\n          </li><li>\n            In memory, <span class=\"hue-doc-codeph\">DECIMAL</span> values with precision greater than 18 are stored in 16 bytes.\n          </li></ul></li></ul><p><b>File format considerations:</b></p><ul><li>\n        The <span class=\"hue-doc-codeph\">DECIMAL</span> data type can be stored in any of the file formats supported by Impala, as\n        described in <a class=\"hue-doc-external-link\" href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_file_formats.html#file_formats\" target=\"_blank\">How Impala Works with Hadoop File Formats</a>. Impala only writes to tables that use the\n        Parquet and text formats, so those formats are the focus for file format compatibility.\n      </li><li>\n        Impala can query Avro, RCFile, or SequenceFile tables containing <span class=\"hue-doc-codeph\">DECIMAL</span> columns, created\n        by other Hadoop components.\n      </li><li>\n        You can use <span class=\"hue-doc-codeph\">DECIMAL</span> columns in Impala tables that are mapped to HBase tables. Impala can\n        query and insert into such tables.\n      </li><li>\n        Text, RCFile, and SequenceFile tables all use ASCII-based formats. In these tables, each\n        <span class=\"hue-doc-codeph\">DECIMAL</span> value takes up as many bytes as there are digits in the value, plus an extra byte\n        if the decimal point is present. The binary format of Parquet or Avro files offers more compact storage for\n        <span class=\"hue-doc-codeph\">DECIMAL</span> columns.\n      </li><li>\n        Parquet and Avro tables use binary formats, In these tables, Impala stores each value in 4, 8, or 16 bytes\n        depending on the precision specified for the <span class=\"hue-doc-codeph\">DECIMAL</span> column.\n      </li></ul><p><b>UDF considerations:</b> When writing a C++ UDF, use the <span class=\"hue-doc-codeph\">DecimalVal</span> data type defined in\n      <span class=\"hue-doc-filepath\">/usr/include/impala_udf/udf.h</span>.\n    </p><p><b>Partitioning:</b></p><p>\n      You can use a <span class=\"hue-doc-codeph\">DECIMAL</span> column as a partition key. Doing so provides a better match between\n      the partition key values and the HDFS directory names than using a <span class=\"hue-doc-codeph\">DOUBLE</span> or\n      <span class=\"hue-doc-codeph\">FLOAT</span> partitioning column:\n    </p><p><b>Schema evolution considerations:</b></p><ul><li>\n        For text-based formats (text, RCFile, and SequenceFile tables), you can issue an <span class=\"hue-doc-codeph\">ALTER TABLE ...\n        REPLACE COLUMNS</span> statement to change the precision and scale of an existing\n        <span class=\"hue-doc-codeph\">DECIMAL</span> column. As long as the values in the column fit within the new precision and\n        scale, they are returned correctly by a query. Any values that do not fit within the new precision and\n        scale are returned as <span class=\"hue-doc-codeph\">NULL</span>, and Impala reports the conversion error. Leading zeros do not\n        count against the precision value, but trailing zeros after the decimal point do.\n<div class=\"hue-doc-codeblock\">[localhost:21000] &gt; create table text_decimals (x string);\n[localhost:21000] &gt; insert into text_decimals values (\"1\"), (\"2\"), (\"99.99\"), (\"1.234\"), (\"000001\"), (\"1.000000000\");\n[localhost:21000] &gt; select * from text_decimals;\n+-------------+\n| x           |\n+-------------+\n| 1           |\n| 2           |\n| 99.99       |\n| 1.234       |\n| 000001      |\n| 1.000000000 |\n+-------------+\n[localhost:21000] &gt; alter table text_decimals replace columns (x decimal(4,2));\n[localhost:21000] &gt; select * from text_decimals;\n+-------+\n| x     |\n+-------+\n| 1.00  |\n| 2.00  |\n| 99.99 |\n| NULL  |\n| 1.00  |\n| NULL  |\n+-------+\nERRORS:\nBackend 0:Error converting column: 0 TO DECIMAL(4, 2) (Data is: 1.234)\nfile: hdfs://127.0.0.1:8020/user/hive/warehouse/decimal_testing.db/text_decimals/634d4bd3aa0\ne8420-b4b13bab7f1be787_56794587_data.0\nrecord: 1.234\nError converting column: 0 TO DECIMAL(4, 2) (Data is: 1.000000000)\nfile: hdfs://127.0.0.1:8020/user/hive/warehouse/decimal_testing.db/text_decimals/cd40dc68e20\nc565a-cc4bd86c724c96ba_311873428_data.0\nrecord: 1.000000000\n</div></li><li>\n        For binary formats (Parquet and Avro tables), although an <span class=\"hue-doc-codeph\">ALTER TABLE ... REPLACE COLUMNS</span>\n        statement that changes the precision or scale of a <span class=\"hue-doc-codeph\">DECIMAL</span> column succeeds, any subsequent\n        attempt to query the changed column results in a fatal error. (The other columns can still be queried\n        successfully.) This is because the metadata about the columns is stored in the data files themselves, and\n        <span class=\"hue-doc-codeph\">ALTER TABLE</span> does not actually make any updates to the data files. If the metadata in the\n        data files disagrees with the metadata in the metastore database, Impala cancels the query.\n      </li></ul><p><b>Examples:</b></p><div class=\"hue-doc-codeblock\">CREATE TABLE t1 (x DECIMAL, y DECIMAL(5,2), z DECIMAL(25,0));\nINSERT INTO t1 VALUES (5, 99.44, 123456), (300, 6.7, 999999999);\nSELECT x+y, ROUND(y,1), z/98.6 FROM t1;\nSELECT CAST(1000.5 AS DECIMAL);\n</div><p><b>HBase considerations:</b> This data type is fully compatible with HBase tables.\n      </p><p><b>Parquet considerations:</b> This type is fully compatible with Parquet tables.\n      </p><p><b>Text table considerations:</b> Values of this type are potentially larger in text tables than in tables\n        using Parquet or other binary formats.\n      </p><p><b>Column statistics considerations:</b> Because this type has a fixed size, the maximum and average size\n        fields are always filled in for column statistics, even before you run the <span class=\"hue-doc-codeph\">COMPUTE STATS</span>\n        statement.\n      </p><p><b>Kudu considerations:</b></p><p>\n        Currently, the data types <span class=\"hue-doc-codeph\">CHAR</span>, <span class=\"hue-doc-codeph\">VARCHAR</span>,\n        <span class=\"hue-doc-codeph\">ARRAY</span>, <span class=\"hue-doc-codeph\">MAP</span>, and <span class=\"hue-doc-codeph\">STRUCT</span> cannot be used with Kudu tables.\n      </p><p><b>Related information:</b></p><p><a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_literals.xml\" data-doc-anchor-id=\"numeric_literals\">Numeric Literals</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_tinyint.xml\" data-doc-anchor-id=\"tinyint\">TINYINT Data Type</a>,\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_smallint.xml\" data-doc-anchor-id=\"smallint\">SMALLINT Data Type</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_int.xml\" data-doc-anchor-id=\"int\">INT Data Type</a>,\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_bigint.xml\" data-doc-anchor-id=\"bigint\">BIGINT Data Type</a>, <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_decimal.xml\" data-doc-anchor-id=\"decimal\">DECIMAL Data Type (Impala 1.4 or higher only)</a>,\n      <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"topics/impala_math_functions.xml\" data-doc-anchor-id=\"math_functions\">Impala Mathematical Functions</a> (especially <span class=\"hue-doc-codeph\">PRECISION()</span> and\n      <span class=\"hue-doc-codeph\">SCALE()</span>)\n    </p></div></div></div>","title":"DECIMAL Data Type (Impala 1.4 or higher only)"}