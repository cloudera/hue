{"body":"<div><div>\n        <div id=\"title\">\n                        <h1 class=\"hue-doc-title-hive\">DDL BucketedTables</h1>\n        </div>\n\n        <!--<div id=\"toc\" class=\"content prepend-top\">\n            <h1>Table of Contents</h1>\n            $replacement.render(\"toc\")\n        </div>-->\n\n        <div id=\"src-27362035\">\n            <p>\n    This is a brief example on creating and populating bucketed tables. (For another example, see <a data-doc-anchor-id=\"src-27362034_LanguageManualDDL-BucketedSortedTables\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27362034\">Bucketed Sorted Tables</a>.)            </p>\n                <p>\n    Bucketed tables are fantastic in that they allow much more efficient <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27362042\">sampling</a> than do non-bucketed tables, and they may later allow for time saving operations such as mapside joins. However, the bucketing specified at table creation is not enforced when the table is written to, and so it is possible for the table's metadata to advertise properties which are not upheld by the table's actual layout. This should obviously be avoided. Here's how to do it right.            </p>\n                <p>\n    First, <a data-doc-anchor-id=\"src-27362034_safe-id-TGFuZ3VhZ2VNYW51YWxEREwtQ3JlYXRlL0Ryb3AvVHJ1bmNhdGVUYWJsZQ\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27362034\">table creation</a>:            </p>\n        <div style=\"counter-reset: scroll-code-numbering 1\">\n                <div class=\"hue-doc-codeblock\">CREATE TABLE user_info_bucketed(user_id BIGINT, firstname STRING, lastname STRING)\nCOMMENT 'A bucketed copy of user_info'\nPARTITIONED BY(ds STRING)\nCLUSTERED BY(user_id) INTO <span class=\"hue-doc-varname\">256</span> BUCKETS;\n</div>\n    </div>\n            <p>\n    Note that we specify a column (user_id) to base the bucketing.            </p>\n                <p>\n    Then we populate the table            </p>\n        <div style=\"counter-reset: scroll-code-numbering 1\">\n                <div class=\"hue-doc-codeblock\">set hive.enforce.bucketing = true;  -- (Note: Not needed in Hive <span class=\"hue-doc-varname\">2</span>.x onward)\nFROM user_id\nINSERT OVERWRITE TABLE user_info_bucketed\nPARTITION (ds='2009-02-25')\nSELECT userid, firstname, lastname WHERE ds='2009-02-25';\n</div>\n    </div>\n    <div class=\"hue-doc-note-hive\">\n            <div>Version 0.x and 1.x only</div>\n                    <p>\n    The command <tt>set hive.enforce.bucketing = true;</tt> allows the correct number of reducers and the cluster by column to be automatically selected based on the table. Otherwise, you would need to set the number of reducers to be the same as the number of buckets as in <tt>set mapred.reduce.tasks = 256;</tt> and have a <tt>CLUSTER BY ...</tt> clause in the select.            </p>\n        </div>\n                <p>\n    How does Hive distribute the rows across the buckets? In general, the bucket number is determined by the expression <tt>hash_function(bucketing_column) mod num_buckets</tt>. (There's a '0x7FFFFFFF in there too, but that's not that important). The hash_function depends on the type of the bucketing column. For an int, it's easy, <tt>hash_int(i) == i</tt>. For example, if user_id were an int, and there were 10 buckets, we would expect all user_id's that end in 0 to be in bucket 1, all user_id's that end in a 1 to be in bucket 2, etc. For other datatypes, it's a little tricky. In particular, the hash of a BIGINT is not the same as the BIGINT. And the hash of a string or a complex datatype will be some number that's derived from the value, but not anything humanly-recognizable. For example, if user_id were a STRING, then the user_id's in bucket 1 would probably not end in 0. In general, distributing rows based on the hash will give you a even distribution in the buckets.            </p>\n                <p>\n    So, what can go wrong? As long as you use the syntax above and <tt>set hive.enforce.bucketing = true</tt> (for Hive 0.x and 1.x), the tables should be populated properly. Things can go wrong if the bucketing column type is different during the insert and on read, or if you manually cluster by a value that's different from the table definition.            </p>\n            </div>\n    </div></div>","title":"DDL BucketedTables"}