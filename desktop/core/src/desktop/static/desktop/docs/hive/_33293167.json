{"body":"<div><div>\n        <div id=\"title\">\n                        <h1 class=\"hue-doc-title-hive\">Join Optimization</h1>\n        </div>\n\n        <!--<div id=\"toc\" class=\"content prepend-top\">\n            <h1>Table of Contents</h1>\n            $replacement.render(\"toc\")\n        </div>-->\n\n        <div id=\"src-33293167\">\n            <p>\n                </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-JoinOptimization\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Join Optimization</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-ImprovementstotheHiveOptimizer\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Improvements to the Hive Optimizer</a>            </p>\n    </li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-StarJoinOptimization\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Star Join Optimization</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-StarSchemaExample\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Star Schema Example</a>            </p>\n    </li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-PriorSupportforMAPJOIN\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Prior Support for MAPJOIN</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-LimitationsofPriorImplementation\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Limitations of Prior Implementation</a>            </p>\n    </li></ul></li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-EnhancementsforStarJoins\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Enhancements for Star Joins</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-OptimizeChainsofMapJoins\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Optimize Chains of Map Joins</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-CurrentandFutureOptimizations\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Current and Future Optimizations</a>            </p>\n    </li></ul></li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-OptimizeAutoJoinConversion\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Optimize Auto Join Conversion</a>            </p>\n    <ul></ul><ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-CurrentOptimization\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Current Optimization</a>            </p>\n    </li></ul></li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-AutoConversiontoSMBMapJoin\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Auto Conversion to SMB Map Join</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-SMBJoinacrossTableswithDifferentKeys\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">SMB Join across Tables with Different Keys</a>            </p>\n    </li></ul></li></ul></li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-GenerateHashTablesontheTaskSide\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Generate Hash Tables on the Task Side</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-ProsandConsofClient-SideHashTables\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Pros and Cons of Client-Side Hash Tables</a>            </p>\n    </li><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-Task-SideGenerationofHashTables\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Task-Side Generation of Hash Tables</a>            </p>\n    <ul><li>            <p>\n    <a data-doc-anchor-id=\"src-33293167_LanguageManualJoinOptimization-FurtherOptionsforOptimization\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_33293167\">Further Options for Optimization</a>            </p>\n    </li></ul></li></ul></li></ul></li></ul></li></ul>            <p>\n    For a general discussion of Hive joins including syntax, examples, and restrictions, see the <a class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27362039\">Joins</a> wiki doc.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-ImprovementstotheHiveOptimizer\">\n        <h2><span>Improvements to the Hive Optimizer</span></h2>\n    <div class=\"hue-doc-note-hive\">\n            <div>Version</div>\n                    <p>\n    The join optimizations described here were added in Hive version 0.11.0. See <a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-3784\" target=\"_blank\">HIVE-3784</a> and related JIRAs.            </p>\n        </div>\n                <p>\n    This document describes optimizations of Hive's query execution planning to improve the efficiency of joins and reduce the need for user hints.            </p>\n                <p>\n    Hive automatically recognizes various use cases and optimizes for them. Hive 0.11 improves the optimizer for these cases:            </p>\n    <ul><li>            <p>\n    Joins where one side fits in memory. In the new optimization:            </p>\n    <ul><li>            <p>\n    that side is loaded into memory as a hash table            </p>\n    </li><li>            <p>\n    only the larger table needs to be scanned            </p>\n    </li><li>            <p>\n    fact tables have a smaller footprint in memory            </p>\n    </li></ul></li><li>            <p>\n    Star-schema joins            </p>\n    </li><li>            <p>\n    Hints are no longer needed for many cases.            </p>\n    </li><li>            <p>\n    Map joins are automatically picked up by the optimizer.            </p>\n    </li></ul>    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-StarJoinOptimization\">\n        <h2><span>Star Join Optimization</span></h2>\n            <p>\n    A simple schema for decision support systems or data warehouses is the star schema, where events are collected in large <i>fact tables</i>, while smaller supporting tables (<i>dimensions</i>) are used to describe the data.            </p>\n                <p>\n    The <a class=\"hue-doc-external-link\" href=\"http://www.tpc.org/tpcds/\" target=\"_blank\">TPC DS</a> is an example of such a schema. It models a typical retail warehouse where the events are sales and typical dimensions are date of sale, time of sale, or demographic of the purchasing party. Typical queries aggregate and filter fact tables along properties in the dimension tables.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-StarSchemaExample\">\n        <h3><span>Star Schema Example</span></h3>\n    <div>\n                <div>\n        <pre><code>Select count(*) cnt\nFrom store_sales ss\n     join household_demographics hd on (ss.ss_hdemo_sk = hd.hd_demo_sk)\n     join time_dim t on (ss.ss_sold_time_sk = t.t_time_sk)\n     join store s on (s.s_store_sk = ss.ss_store_sk)\nWhere\n     t.t_hour = 8\n     t.t_minute &gt;= 30\n     hd.hd_dep_count = 2\norder by cnt;</code></pre>\n        </div>\n    </div>\n    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-PriorSupportforMAPJOIN\">\n        <h3><span>Prior Support for MAPJOIN</span></h3>\n            <p>\n    Hive supports MAPJOINs, which are well suited for this scenario – at least for dimensions small enough to fit in memory. Before release 0.11, a MAPJOIN could be invoked either through an optimizer hint:            </p>\n        <div>\n                <div>\n        <pre><code>select /*+ MAPJOIN(time_dim) */ count(*) from\nstore_sales join time_dim on (ss_sold_time_sk = t_time_sk)</code></pre>\n        </div>\n    </div>\n            <p>\n    or via auto join conversion:            </p>\n        <div>\n                <div>\n        <pre><code>set hive.auto.convert.join=true;\nselect count(*) from\nstore_sales join time_dim on (ss_sold_time_sk = t_time_sk)</code></pre>\n        </div>\n    </div>\n            <p>\n    The default value for <a data-doc-anchor-id=\"src-27842758_ConfigurationProperties-hive.auto.convert.join\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27842758\">hive.auto.convert.join</a> was false in Hive 0.10.0. Hive 0.11.0 changed the default to true (<a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-3297\" target=\"_blank\">HIVE-3297</a>). Note that <a class=\"hue-doc-external-link\" href=\"https://cwiki.apache.org/confluence/display/Hive/AdminManual+Configuration#AdminManualConfiguration-hive-site.xmlandhive-default.xml.template\" target=\"_blank\">hive-default.xml.template</a> incorrectly gives the default as false in Hive 0.11.0 through 0.13.1.            </p>\n                <p>\n    MAPJOINs are processed by loading the smaller table into an in-memory hash map and matching keys with the larger table as they are streamed through. The prior implementation has this division of labor:            </p>\n    <ul><li>            <p>\n    Local work:            </p>\n    <ul><li>            <p>\n    read records via standard table scan (including filters and projections) from source on local machine            </p>\n    </li><li>            <p>\n    build hashtable in memory            </p>\n    </li><li>            <p>\n    write hashtable to local disk            </p>\n    </li><li>            <p>\n    upload hashtable to dfs            </p>\n    </li><li>            <p>\n    add hashtable to distributed cache            </p>\n    </li></ul></li><li>            <p>\n    Map task            </p>\n    <ul><li>            <p>\n    read hashtable from local disk (distributed cache) into memory            </p>\n    </li><li>            <p>\n    match records' keys against hashtable            </p>\n    </li><li>            <p>\n    combine matches and write to output            </p>\n    </li></ul></li><li>            <p>\n    No reduce task            </p>\n    </li></ul>    <div id=\"src-33293167_LanguageManualJoinOptimization-LimitationsofPriorImplementation\">\n        <h4><span>Limitations of Prior Implementation</span></h4>\n            <p>\n    The MAPJOIN implementation prior to Hive 0.11 has these limitations:            </p>\n    <ul><li>            <p>\n    The mapjoin operator can only handle one key at a time; that is, it can perform a multi-table join, but only if all the tables are joined on the same key. (Typical star schema joins do not fall into this category.)            </p>\n    </li><li>            <p>\n    Hints are cumbersome for users to apply correctly and auto conversion doesn't have enough logic to consistently predict if a MAPJOIN will fit into memory or not.            </p>\n    </li><li>            <p>\n    A chain of MAPJOINs is not coalesced into a single map-only job, unless the query is written as a cascading sequence of <tt>mapjoin(table, subquery(mapjoin(table, subquery....)</tt>. Auto conversion never produces a single map-only job.            </p>\n    </li><li>            <p>\n    The hashtable for the mapjoin operator has to be generated for each run of the query, which involves downloading all the data to the Hive client machine as well as uploading the generated hashtable files.            </p>\n    </li></ul>    </div>\n    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-EnhancementsforStarJoins\">\n        <h3><span>Enhancements for Star Joins</span></h3>\n            <p>\n    The optimizer enhancements in Hive 0.11 focus on efficient processing of the joins needed in star schema configurations. The initial work was limited to star schema joins where all dimension tables after filtering and projecting fit into memory at the same time. Scenarios where only some of the dimension tables fit into memory are now implemented as well (<a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-3996\" target=\"_blank\">HIVE-3996</a>).            </p>\n                <p>\n    The join optimizations can be grouped into three parts:            </p>\n    <ul><li>            <p>\n    Execute chains of mapjoins in the operator tree in a single map-only job, when maphints are used.            </p>\n    </li><li>            <p>\n    Extend optimization to the auto-conversion case (generating an appropriate backup plan when optimizing).            </p>\n    </li><li>            <p>\n    Generate in-memory hashtable completely on the task side. (Future work.)            </p>\n    </li></ul>            <p>\n    The following sections describe each of these optimizer enhancements.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-OptimizeChainsofMapJoins\">\n        <h4><span>Optimize Chains of Map Joins</span></h4>\n            <p>\n    The following query will produce two separate map-only jobs when executed:            </p>\n        <div>\n                <div>\n        <pre><code>select /*+ MAPJOIN(time_dim, date_dim) */ count(*) from\nstore_sales \njoin time_dim on (ss_sold_time_sk = t_time_sk) \njoin date_dim on (ss_sold_date_sk = d_date_sk)\nwhere t_hour = 8 and d_year = 2002</code></pre>\n        </div>\n    </div>\n            <p>\n    It is likely, though, that for small dimension tables the parts of both tables needed would fit into memory at the same time. This reduces the time needed to execute this query dramatically, as the fact table is only read once instead of reading it twice and writing it to HDFS to communicate between the jobs.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-CurrentandFutureOptimizations\">\n        <h5><span>Current and Future Optimizations</span></h5>\n<ol><li>            <p>\n    Merge M*-MR patterns into a single MR.            </p>\n    </li><li>            <p>\n    Merge MJ-&gt;MJ into a single MJ when possible.            </p>\n    </li><li>            <p>\n    Merge MJ* patterns into a single Map stage as a chain of MJ operators. (Not yet implemented.)            </p>\n    </li></ol>            <p>\n    If <tt>hive.auto.convert.join</tt> is set to true the optimizer not only converts joins to mapjoins but also merges MJ* patterns as much as possible.            </p>\n        </div>\n    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-OptimizeAutoJoinConversion\">\n        <h4><span>Optimize Auto Join Conversion</span></h4>\n            <p>\n    When auto join is enabled, there is no longer a need to provide the map-join hints in the query. The auto join option can be enabled with two configuration parameters:            </p>\n        <div>\n                <div>\n        <pre><code>set hive.auto.convert.join.noconditionaltask = true;\nset hive.auto.convert.join.noconditionaltask.size = 10000000;</code></pre>\n        </div>\n    </div>\n            <p>\n    The default for <tt>hive.auto.convert.join.noconditionaltask</tt> is true which means auto conversion is enabled. (Originally the default was false – see <a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-3784\" target=\"_blank\">HIVE-3784</a> – but it was changed to true by <a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-4146\" target=\"_blank\">HIVE-4146</a> before Hive 0.11.0 was released.)            </p>\n                <p>\n    The <a data-doc-anchor-id=\"src-27842758_ConfigurationProperties-hive.auto.convert.join.noconditionaltask.size\" class=\"hue-doc-internal-link\" href=\"javascript:void(0);\" data-doc-ref=\"_27842758\">size configuration</a> enables the user to control what size table can fit in memory. This value represents the sum of the sizes of tables that can be converted to hashmaps that fit in memory. Currently, n-1 tables of the join have to fit in memory for the map-join optimization to take effect. There is no check to see if the table is a compressed one or not and what the potential size of the table can be. The effect of this assumption on the results is discussed in the next section.            </p>\n                <p>\n    For example, the previous query just becomes:            </p>\n        <div>\n                <div>\n        <pre><code>select count(*) from\nstore_sales \njoin time_dim on (ss_sold_time_sk = t_time_sk)\njoin date_dim on (ss_sold_date_sk = d_date_sk)\nwhere t_hour = 8 and d_year = 2002</code></pre>\n        </div>\n    </div>\n            <p>\n    If time_dim and date_dim fit in the size configuration provided, the respective joins are converted to map-joins. If the sum of the sizes of the tables can fit in the configured size, then the two map-joins are combined resulting in a single map-join. This reduces the number of MR-jobs required and significantly boosts the speed of execution of this query. This example can be easily extended for multi-way joins as well and will work as expected.            </p>\n                <p>\n    Outer joins offer more challenges. Since a map-join operator can only stream one table, the streamed table needs to be the one from which all of the rows are required. For the left outer join, this is the table on the left side of the join; for the right outer join, the table on the right side, etc. This means that even though an inner join can be converted to a map-join, an outer join cannot be converted. An outer join can only be converted if the table(s) apart from the one that needs to be streamed can be fit in the size configuration. A full outer join cannot be converted to a map-join at all since both tables need to be streamed.            </p>\n                <p>\n    Auto join conversion also affects the sort-merge-bucket joins.            </p>\n        <div class=\"hue-doc-note-hive\">\n            <div>Version 0.13.0 and later</div>\n                    <p>\n    Hive 0.13.0 introduced <tt>hive.auto.convert.join.use.nonstaged</tt> with a default of false (<a class=\"hue-doc-external-link\" href=\"https://issues.apache.org/jira/browse/HIVE-6144\" target=\"_blank\">HIVE-6144</a>).            </p>\n                <p>\n    For conditional joins, if the input stream from a small alias can be directly applied to the join operator without filtering or projection, then it does not need to be pre-staged in the distributed cache via a MapReduce local task. Setting <tt>hive.auto.convert.join.use.nonstaged</tt> to true avoids pre-staging in those cases.            </p>\n        </div>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-CurrentOptimization\">\n        <h5><span>Current Optimization</span></h5>\n<ol><li>            <p>\n    Group as many MJ operators as possible into one MJ.            </p>\n    </li></ol>            <p>\n    As Hive goes through the conversion to map-joins for join operators based on the configuration flags, an effort is made at the end of these conversions to group as many together as possible. Going through in a sequence, if the sum of the sizes of the tables participating in the individual map-join operators is within the limit configured by the <tt>noConditionalTask.size</tt> flag, these MJ operators are combined together. This ensures more speedup with regard to these queries.            </p>\n        </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-AutoConversiontoSMBMapJoin\">\n        <h5><span>Auto Conversion to SMB Map Join</span></h5>\n            <p>\n    Sort-Merge-Bucket (SMB) joins can be converted to SMB map joins as well. SMB joins are used wherever the tables are sorted and bucketed. The join boils down to just merging the already sorted tables, allowing this operation to be faster than an ordinary map-join. However, if the tables are partitioned, there could be a slow down as each mapper would need to get a very small chunk of a partition which has a single key.            </p>\n                <p>\n    The following configuration settings enable the conversion of an SMB to a map-join SMB:            </p>\n        <div>\n                <div>\n        <pre><code>set hive.auto.convert.sortmerge.join=true;\nset hive.optimize.bucketmapjoin = true;\nset hive.optimize.bucketmapjoin.sortedmerge = true;</code></pre>\n        </div>\n    </div>\n            <p>\n    There is an option to set the big table selection policy using the following configuration:            </p>\n        <div>\n                <div>\n        <pre><code>set hive.auto.convert.sortmerge.join.bigtable.selection.policy \n    = org.apache.hadoop.hive.ql.optimizer.TableSizeBasedBigTableSelectorForAutoSMJ;</code></pre>\n        </div>\n    </div>\n            <p>\n    By default, the selection policy is average partition size. The big table selection policy helps determine which table to choose for only streaming, as compared to hashing and streaming.            </p>\n                <p>\n    The available selection policies are:            </p>\n        <div>\n                <div>\n        <pre><code>org.apache.hadoop.hive.ql.optimizer.AvgPartitionSizeBasedBigTableSelectorForAutoSMJ (default)\norg.apache.hadoop.hive.ql.optimizer.LeftmostBigTableSelectorForAutoSMJ\norg.apache.hadoop.hive.ql.optimizer.TableSizeBasedBigTableSelectorForAutoSMJ</code></pre>\n        </div>\n    </div>\n            <p>\n    The names describe their uses. This is especially useful for the fact-fact join (query 82 in the <a class=\"hue-doc-external-link\" href=\"http://www.tpc.org/tpcds/\" target=\"_blank\">TPC DS</a> benchmark).            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-SMBJoinacrossTableswithDifferentKeys\">\n        <h6><span>SMB Join across Tables with Different Keys</span></h6>\n            <p>\n    If the tables have differing number of keys, for example Table A has 2 SORT columns and Table B has 1 SORT column, then you might get an index out of bounds exception.            </p>\n                <p>\n    The following query results in an index out of bounds exception because emp_person let us say for example has 1 sort column while emp_pay_history has 2 sort columns.            </p>\n        <div style=\"counter-reset: scroll-code-numbering 1\">\n                    <div>Error Hive 0.11</div>\n                <div class=\"hue-doc-codeblock\">SELECT p.*, py.*\nFROM emp_person p INNER JOIN emp_pay_history py\nON   p.empid = py.empid\n</div>\n    </div>\n            <p>\n    This works fine.            </p>\n        <div style=\"counter-reset: scroll-code-numbering 1\">\n                    <div>Working query Hive 0.11</div>\n                <div class=\"hue-doc-codeblock\">SELECT p.*, py.*\nFROM emp_pay_history py INNER JOIN emp_person p\nON   p.empid = py.empid\n</div>\n    </div>\n            <p>\n                </p>\n        </div>\n    </div>\n    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-GenerateHashTablesontheTaskSide\">\n        <h4><span>Generate Hash Tables on the Task Side</span></h4>\n            <p>\n    Future work will make it possible to generate in-memory hashtables completely on the task side.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-ProsandConsofClient-SideHashTables\">\n        <h5><span>Pros and Cons of Client-Side Hash Tables</span></h5>\n            <p>\n    Generating the hashtable (or multiple hashtables for multitable joins) on the client machine has drawbacks. (The <i>client machine</i> is the host that is used to run the Hive client and submit jobs.)            </p>\n    <ul><li>            <p>\n    <strong>Data locality:</strong> The client machine typically is not a data node. All the data accessed is remote and has to be read via the network.            </p>\n    </li><li>            <p>\n    <strong>Specs:</strong> For the same reason, it is not clear what the specifications of the machine running this processing will be. It might have limitations in memory, hard drive, or CPU that the task nodes do not have.            </p>\n    </li><li>            <p>\n    <strong>HDFS upload:</strong> The data has to be brought back to the cluster and replicated via the distributed cache to be used by task nodes.            </p>\n    </li></ul>            <p>\n    Pre-processing the hashtables on the client machine also has some benefits:            </p>\n    <ul><li>            <p>\n    What is stored in the distributed cache is likely to be smaller than the original table (filter and projection).            </p>\n    </li><li>            <p>\n    In contrast, loading hashtables directly on the task nodes using the distributed cache means larger objects in the cache, potentially reducing opportunities for using MAPJOIN.            </p>\n    </li></ul>    </div>\n    <div id=\"src-33293167_LanguageManualJoinOptimization-Task-SideGenerationofHashTables\">\n        <h5><span>Task-Side Generation of Hash Tables</span></h5>\n            <p>\n    When the hashtables are generated completely on the task side, all task nodes have to access the original data source to generate the hashtable. Since in the normal case this will happen in parallel it will not affect latency, but Hive has a concept of storage handlers and having many tasks access the same external data source (HBase, database, etc.) might overwhelm or slow down the source.            </p>\n        <div id=\"src-33293167_LanguageManualJoinOptimization-FurtherOptionsforOptimization\">\n        <h6><span>Further Options for Optimization</span></h6>\n<ol><li>            <p>\n    Increase the replication factor on dimension tables.            </p>\n    </li><li>            <p>\n    Use the distributed cache to hold dimension tables.            </p>\n    </li></ol>    </div>\n    </div>\n    </div>\n    </div>\n    </div>\n        </div>\n    </div></div>","title":"JoinOptimization"}