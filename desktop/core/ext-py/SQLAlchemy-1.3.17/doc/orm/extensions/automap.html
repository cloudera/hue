<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    Automap
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
        <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../../index.html" />
        <link rel="up" title="ORM Extensions" href="index.html" />
        <link rel="next" title="Baked Queries" href="baked.html" />
        <link rel="prev" title="Association Proxy" href="associationproxy.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.17</span>


        | Release Date: May 13, 2020

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../../contents.html">Contents</a> |
                <a href="../../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="../tutorial.html">Object Relational Tutorial</a></span></li>
<li><span class="link-container"><a class="reference external" href="../mapper_config.html">Mapper Configuration</a></span></li>
<li><span class="link-container"><a class="reference external" href="../relationships.html">Relationship Configuration</a></span></li>
<li><span class="link-container"><a class="reference external" href="../loading_objects.html">Loading Objects</a></span></li>
<li><span class="link-container"><a class="reference external" href="../session.html">Using the Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="../extending.html">Events and Internals</a></span></li>
<li><span class="link-container"><a class="reference external" href="index.html">ORM Extensions</a></span><ul>
<li><span class="link-container"><a class="reference external" href="associationproxy.html">Association Proxy</a></span></li>
<li class="selected"><span class="link-container"><strong>Automap</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#basic-use">Basic Use</a></span></li>
<li><span class="link-container"><a class="reference external" href="#generating-mappings-from-an-existing-metadata">Generating Mappings from an Existing MetaData</a></span></li>
<li><span class="link-container"><a class="reference external" href="#specifying-classes-explicitly">Specifying Classes Explicitly</a></span></li>
<li><span class="link-container"><a class="reference external" href="#overriding-naming-schemes">Overriding Naming Schemes</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationship-detection">Relationship Detection</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#custom-relationship-arguments">Custom Relationship Arguments</a></span></li>
<li><span class="link-container"><a class="reference external" href="#many-to-many-relationships">Many-to-Many relationships</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationships-with-inheritance">Relationships with Inheritance</a></span></li>
<li><span class="link-container"><a class="reference external" href="#handling-simple-naming-conflicts">Handling Simple Naming Conflicts</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#using-automap-with-explicit-declarations">Using Automap with Explicit Declarations</a></span></li>
<li><span class="link-container"><a class="reference external" href="#api-reference">API Reference</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="baked.html">Baked Queries</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative/index.html">Declarative</a></span></li>
<li><span class="link-container"><a class="reference external" href="mutable.html">Mutation Tracking</a></span></li>
<li><span class="link-container"><a class="reference external" href="orderinglist.html">Ordering List</a></span></li>
<li><span class="link-container"><a class="reference external" href="horizontal_shard.html">Horizontal Sharding</a></span></li>
<li><span class="link-container"><a class="reference external" href="hybrid.html">Hybrid Attributes</a></span></li>
<li><span class="link-container"><a class="reference external" href="indexable.html">Indexable</a></span></li>
<li><span class="link-container"><a class="reference external" href="instrumentation.html">Alternate Class Instrumentation</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="../examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.ext.automap">
<span id="automap"></span><span id="automap-toplevel"></span><h1>Automap<a class="headerlink" href="#module-sqlalchemy.ext.automap" title="Permalink to this headline">¶</a></h1>
<p>Define an extension to the <a class="reference internal" href="declarative/api.html#module-sqlalchemy.ext.declarative" title="sqlalchemy.ext.declarative"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.declarative</span></code></a> system
which automatically generates mapped classes and relationships from a database
schema, typically though not necessarily one which is reflected.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.1: </span>Added <a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a>.</p>
</div>
<p>It is hoped that the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> system provides a quick
and modernized solution to the problem that the very famous
<a class="reference external" href="https://sqlsoup.readthedocs.io/en/latest/">SQLSoup</a>
also tries to solve, that of generating a quick and rudimentary object
model from an existing database on the fly.  By addressing the issue strictly
at the mapper configuration level, and integrating fully with existing
Declarative class techniques, <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> seeks to provide
a well-integrated approach to the issue of expediently auto-generating ad-hoc
mappings.</p>
<div class="section" id="basic-use">
<h2>Basic Use<a class="headerlink" href="#basic-use" title="Permalink to this headline">¶</a></h2>
<p>The simplest usage is to reflect an existing database into a new model.
We create a new <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class in a similar manner as to how
we create a declarative base class, using <a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a>.
We then call <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> on the resulting base class,
asking it to reflect the schema and produce mappings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="c1"># engine, suppose it has two tables &#39;user&#39; and &#39;address&#39; set up</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># reflect the tables</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># mapped classes are now created with names by default</span>
<span class="c1"># matching that of the table name.</span>
<span class="n">User</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># rudimentary relationships are produced</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)))</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="c1"># collection-based relationships are by default named</span>
<span class="c1"># &quot;&lt;classname&gt;_collection&quot;</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span></pre></div>
</div>
<p>Above, calling <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> while passing along the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a> parameter indicates that the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>
method will be called on this declarative base
classes’ <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection; then, each <strong>viable</strong>
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> within the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
will get a new mapped class
generated automatically.  The <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects which
link the various tables together will be used to produce new, bidirectional
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects between classes.
The classes and relationships
follow along a default naming scheme that we can customize.  At this point,
our basic mapping consisting of related <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> classes is
ready to use in the traditional way.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By <strong>viable</strong>, we mean that for a table to be mapped, it must
specify a primary key.  Additionally, if the table is detected as being
a pure association table between two other tables, it will not be directly
mapped and will instead be configured as a many-to-many table between
the mappings for the two referring tables.</p>
</div>
</div>
<div class="section" id="generating-mappings-from-an-existing-metadata">
<h2>Generating Mappings from an Existing MetaData<a class="headerlink" href="#generating-mappings-from-an-existing-metadata" title="Permalink to this headline">¶</a></h2>
<p>We can pass a pre-declared <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object to
<a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a>.
This object can be constructed in any way, including programmatically, from
a serialized file, or from itself being reflected using
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>.
Below we illustrate a combination of reflection and
explicit table declaration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># produce our own MetaData object</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="c1"># we can reflect it ourselves from a database, using options</span>
<span class="c1"># such as &#39;only&#39; to limit what tables we look at...</span>
<span class="n">metadata</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">])</span>

<span class="c1"># ... or just define our own Table objects with it (or combine both)</span>
<span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_order&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>
            <span class="p">)</span>

<span class="c1"># we can then produce a set of mappings from this MetaData.</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

<span class="c1"># calling prepare() just sets up mapped classes and relationships.</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapped classes are ready</span>
<span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">,</span> <span class="n">Order</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>\
    <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user_order</span></pre></div>
</div>
</div>
<div class="section" id="specifying-classes-explicitly">
<h2>Specifying Classes Explicitly<a class="headerlink" href="#specifying-classes-explicitly" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a> extension allows classes to be defined
explicitly, in a way similar to that of the <a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a> class.
Classes that extend from <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> act like regular declarative
classes, but are not immediately mapped after their construction, and are
instead mapped when we call <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a>.  The
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method will make use of the classes we’ve
established based on the table name we use.  If our schema contains tables
<code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">address</span></code>, we can define one or both of the classes to be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="c1"># pre-declare User for the &#39;user&#39; table</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="c1"># override schema elements like Columns</span>
    <span class="n">user_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

    <span class="c1"># override relationships too, if desired.</span>
    <span class="c1"># we must use the same name that automap would use for the</span>
    <span class="c1"># relationship, and also must refer to the class name that automap will</span>
    <span class="c1"># generate for &quot;address&quot;</span>
    <span class="n">address_collection</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="n">collection_class</span><span class="o">=</span><span class="nb">set</span><span class="p">)</span>

<span class="c1"># reflect</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># we still have Address generated from the tablename &quot;address&quot;,</span>
<span class="c1"># but User is the same as Base.classes.User now</span>

<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span>

<span class="c1"># the backref is still there:</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user</span><span class="p">)</span></pre></div>
</div>
<p>Above, one of the more intricate details is that we illustrated overriding
one of the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects that automap would have created.
To do this, we needed to make sure the names match up with what automap
would normally generate, in that the relationship name would be
<code class="docutils literal notranslate"><span class="pre">User.address_collection</span></code> and the name of the class referred to, from
automap’s perspective, is called <code class="docutils literal notranslate"><span class="pre">address</span></code>, even though we are referring to
it as <code class="docutils literal notranslate"><span class="pre">Address</span></code> within our usage of this class.</p>
</div>
<div class="section" id="overriding-naming-schemes">
<h2>Overriding Naming Schemes<a class="headerlink" href="#overriding-naming-schemes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a> is tasked with producing mapped classes and
relationship names based on a schema, which means it has decision points in how
these names are determined.  These three decision points are provided using
functions which can be passed to the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method, and
are known as <a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a>.  Any or all of these
functions are provided as in the example below, where we use a “camel case”
scheme for class names and a “pluralizer” for collection names using the
<a class="reference external" href="https://pypi.python.org/pypi/inflect">Inflect</a> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inflect</span>

<span class="k">def</span> <span class="nf">camelize_classname</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="s2">&quot;Produce a &#39;camelized&#39; class name, e.g. &quot;</span>
    <span class="s2">&quot;&#39;words_and_underscores&#39; -&gt; &#39;WordsAndUnderscores&#39;&quot;</span>

    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">tablename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> \
            <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_([a-z])&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">tablename</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

<span class="n">_pluralizer</span> <span class="o">=</span> <span class="n">inflect</span><span class="o">.</span><span class="n">engine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pluralize_collection</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="s2">&quot;Produce an &#39;uncamelized&#39;, &#39;pluralized&#39; class name, e.g. &quot;</span>
    <span class="s2">&quot;&#39;SomeTerm&#39; -&gt; &#39;some_terms&#39;&quot;</span>

    <span class="n">referred_name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">uncamelized</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[A-Z]&#39;</span><span class="p">,</span>
                         <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                         <span class="n">referred_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">pluralized</span> <span class="o">=</span> <span class="n">_pluralizer</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="n">uncamelized</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pluralized</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">classname_for_table</span><span class="o">=</span><span class="n">camelize_classname</span><span class="p">,</span>
            <span class="n">name_for_collection_relationship</span><span class="o">=</span><span class="n">pluralize_collection</span>
    <span class="p">)</span></pre></div>
</div>
<p>From the above mapping, we would now have classes <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>,
where the collection from <code class="docutils literal notranslate"><span class="pre">User</span></code> to <code class="docutils literal notranslate"><span class="pre">Address</span></code> is called
<code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">addresses</span><span class="o">=</span><span class="p">[</span><span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">)])</span></pre></div>
</div>
</div>
<div class="section" id="relationship-detection">
<h2>Relationship Detection<a class="headerlink" href="#relationship-detection" title="Permalink to this headline">¶</a></h2>
<p>The vast majority of what automap accomplishes is the generation of
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> structures based on foreign keys.  The mechanism
by which this works for many-to-one and one-to-many relationships is as
follows:</p>
<ol class="arabic">
<li><p>A given <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, known to be mapped to a particular class,
is examined for <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> objects.</p></li>
<li><p>From each <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>, the remote
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
object present is matched up to the class to which it is to be mapped,
if any, else it is skipped.</p></li>
<li><p>As the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
we are examining corresponds to a
reference from the immediate mapped class,  the relationship will be set up
as a many-to-one referring to the referred class; a corresponding
one-to-many backref will be created on the referred class referring
to this class.</p></li>
<li><p>If any of the columns that are part of the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
are not nullable (e.g. <code class="docutils literal notranslate"><span class="pre">nullable=False</span></code>), a
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> keyword argument
of <code class="docutils literal notranslate"><span class="pre">all,</span> <span class="pre">delete-orphan</span></code> will be added to the keyword arguments to
be passed to the relationship or backref.  If the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> reports that
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ForeignKeyConstraint.ondelete</span></code></a>
is set to <code class="docutils literal notranslate"><span class="pre">CASCADE</span></code> for a not null or <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">NULL</span></code> for a nullable
set of columns, the option <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.passive_deletes</span></code></a>
flag is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in the set of relationship keyword arguments.
Note that not all backends support reflection of ON DELETE.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.0: </span>- automap will detect non-nullable foreign key
constraints when producing a one-to-many relationship and establish
a default cascade of <code class="docutils literal notranslate"><span class="pre">all,</span> <span class="pre">delete-orphan</span></code> if so; additionally,
if the constraint specifies
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ForeignKeyConstraint.ondelete</span></code></a>
of <code class="docutils literal notranslate"><span class="pre">CASCADE</span></code> for non-nullable or <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">NULL</span></code> for nullable columns,
the <code class="docutils literal notranslate"><span class="pre">passive_deletes=True</span></code> option is also added.</p>
</div>
</li>
<li><p>The names of the relationships are determined using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_scalar_relationship</span></code></a> and
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_collection_relationship</span></code></a>
callable functions.  It is important to note that the default relationship
naming derives the name from the <strong>the actual class name</strong>.  If you’ve
given a particular class an explicit name by declaring it, or specified an
alternate class naming scheme, that’s the name from which the relationship
name will be derived.</p></li>
<li><p>The classes are inspected for an existing mapped property matching these
names.  If one is detected on one side, but none on the other side,
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> attempts to create a relationship on the missing side,
then uses the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a>
parameter in order to
point the new relationship to the other side.</p></li>
<li><p>In the usual case where no relationship is on either side,
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> produces a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> on the
“many-to-one” side and matches it to the other using the
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code></a> parameter.</p></li>
<li><p>Production of the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> and optionally the
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
is handed off to the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a>
function, which can be supplied by the end-user in order to augment
the arguments passed to <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> or to
make use of custom implementations of these functions.</p></li>
</ol>
<div class="section" id="custom-relationship-arguments">
<h3>Custom Relationship Arguments<a class="headerlink" href="#custom-relationship-arguments" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a> hook can be used
to add parameters to relationships.  For most cases, we can make use of the
existing <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a> function to return
the object, after augmenting the given keyword dictionary with our own
arguments.</p>
<p>Below is an illustration of how to send
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> and
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.passive_deletes</span></code></a>
options along to all one-to-many relationships:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">generate_relationship</span>

<span class="k">def</span> <span class="nf">_gen_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span>
                                <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">ONETOMANY</span><span class="p">:</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;cascade&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all, delete-orphan&#39;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;passive_deletes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># make use of the built-in function to actually return</span>
    <span class="c1"># the result.</span>
    <span class="k">return</span> <span class="n">generate_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span>
                                 <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">generate_relationship</span><span class="o">=</span><span class="n">_gen_relationship</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="many-to-many-relationships">
<h3>Many-to-Many relationships<a class="headerlink" href="#many-to-many-relationships" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a> will generate many-to-many relationships, e.g.
those which contain a <code class="docutils literal notranslate"><span class="pre">secondary</span></code> argument.  The process for producing these
is as follows:</p>
<ol class="arabic simple">
<li><p>A given <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is examined for
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects, before any mapped class has been assigned to it.</p></li>
<li><p>If the table contains two and exactly two
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
objects, and all columns within this table are members of these two
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> objects, the table is assumed to be a
“secondary” table, and will <strong>not be mapped directly</strong>.</p></li>
<li><p>The two (or one, for self-referential) external tables to which the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
refers to are matched to the classes to which they will be
mapped, if any.</p></li>
<li><p>If mapped classes for both sides are located, a many-to-many bi-directional
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> / <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
pair is created between the two
classes.</p></li>
<li><p>The override logic for many-to-many works the same as that of one-to-many/
many-to-one; the <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a> function is called upon
to generate the structures and existing attributes will be maintained.</p></li>
</ol>
</div>
<div class="section" id="relationships-with-inheritance">
<h3>Relationships with Inheritance<a class="headerlink" href="#relationships-with-inheritance" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a> will not generate any relationships between
two classes that are in an inheritance relationship.   That is, with two
classes given as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span> <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span> <span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
    <span class="p">}</span></pre></div>
</div>
<p>The foreign key from <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> to <code class="docutils literal notranslate"><span class="pre">Employee</span></code> is used not for a
relationship, but to establish joined inheritance between the two classes.</p>
<p>Note that this means automap will not generate <em>any</em> relationships
for foreign keys that link from a subclass to a superclass.  If a mapping
has actual relationships from subclass to superclass as well, those
need to be explicit.  Below, as we have two separate foreign keys
from <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> to <code class="docutils literal notranslate"><span class="pre">Employee</span></code>, we need to set up both the relationship
we want as well as the <code class="docutils literal notranslate"><span class="pre">inherit_condition</span></code>, as these are not things
SQLAlchemy can guess:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span> <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">favorite_employee_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">))</span>

    <span class="n">favorite_employee</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span>
                                     <span class="n">foreign_keys</span><span class="o">=</span><span class="n">favorite_employee_id</span><span class="p">)</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
        <span class="s1">&#39;inherit_condition&#39;</span><span class="p">:</span> <span class="nb">id</span> <span class="o">==</span> <span class="n">Employee</span><span class="o">.</span><span class="n">id</span>
    <span class="p">}</span></pre></div>
</div>
</div>
<div class="section" id="handling-simple-naming-conflicts">
<h3>Handling Simple Naming Conflicts<a class="headerlink" href="#handling-simple-naming-conflicts" title="Permalink to this headline">¶</a></h3>
<p>In the case of naming conflicts during mapping, override any of
<a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>, <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a> as needed.  For example, if
automap is attempting to name a many-to-one relationship the same as an
existing column, an alternate convention can be conditionally selected.  Given
a schema:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">table_a</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">table_b</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">table_a</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">table_a</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">table_a</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></pre></div>
</div>
<p>The above schema will first automap the <code class="docutils literal notranslate"><span class="pre">table_a</span></code> table as a class named
<code class="docutils literal notranslate"><span class="pre">table_a</span></code>; it will then automap a relationship onto the class for <code class="docutils literal notranslate"><span class="pre">table_b</span></code>
with the same name as this related class, e.g. <code class="docutils literal notranslate"><span class="pre">table_a</span></code>.  This
relationship name conflicts with the mapping column <code class="docutils literal notranslate"><span class="pre">table_b.table_a</span></code>,
and will emit an error on mapping.</p>
<p>We can resolve this conflict by using an underscore as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">name_for_scalar_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">local_table</span> <span class="o">=</span> <span class="n">local_cls</span><span class="o">.</span><span class="n">__table__</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">local_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">newname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Already detected name </span><span class="si">%s</span><span class="s2"> present.  using </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">newname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">newname</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name_for_scalar_relationship</span><span class="o">=</span><span class="n">name_for_scalar_relationship</span><span class="p">)</span></pre></div>
</div>
<p>Alternatively, we can change the name on the column side.   The columns
that are mapped can be modified using the technique described at
<a class="reference internal" href="../mapping_columns.html#mapper-column-distinct-names"><span class="std std-ref">Naming Columns Distinctly from Attribute Names</span></a>, by assigning the column explicitly
to a new name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">TableB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;table_b&#39;</span>
    <span class="n">_table_a</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;table_a&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;table_a.id&#39;</span><span class="p">))</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</div>
</div>
<div class="section" id="using-automap-with-explicit-declarations">
<h2>Using Automap with Explicit Declarations<a class="headerlink" href="#using-automap-with-explicit-declarations" title="Permalink to this headline">¶</a></h2>
<p>As noted previously, automap has no dependency on reflection, and can make
use of any collection of <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects within a
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
collection.  From this, it follows that automap can also be used
generate missing relationships given an otherwise complete model that fully
defines table metadata:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>

<span class="c1"># produce relationships</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapping is complete, with &quot;address_collection&quot; and</span>
<span class="c1"># &quot;user&quot; relationships</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">&#39;u2&#39;</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">address_collection</span><span class="o">=</span><span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="n">u1</span></pre></div>
</div>
<p>Above, given mostly complete <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> mappings, the
<a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> which we defined on <code class="docutils literal notranslate"><span class="pre">Address.user_id</span></code> allowed a
bidirectional relationship pair <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> and
<code class="docutils literal notranslate"><span class="pre">User.address_collection</span></code> to be generated on the mapped classes.</p>
<p>Note that when subclassing <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a>,
the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AutomapBase.prepare()</span></code></a> method is required; if not called, the classes
we’ve declared are in an un-mapped state.</p>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sqlalchemy.ext.automap.automap_base">
<em class="property">function </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">automap_base</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">declarative_base</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.automap_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a declarative automap base.</p>
<p>This function produces a new base class that is a product of the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class as well a declarative base produced by
<a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>.</p>
<p>All parameters other than <code class="docutils literal notranslate"><span class="pre">declarative_base</span></code> are keyword arguments
that are passed directly to the <a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.automap_base.params.declarative_base"></span><strong>declarative_base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.declarative_base">¶</a> – an existing class produced by
<a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>.  When this is passed, the function
no longer invokes <a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a> itself, and all
other keyword arguments are ignored.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.automap_base.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.**kw">¶</a> – keyword arguments are passed along to
<a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="sqlalchemy.ext.automap.AutomapBase">
<em class="property">class </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">AutomapBase</code><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for an “automap” schema.</p>
<p>The <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class can be compared to the “declarative base”
class that is produced by the <a class="reference internal" href="declarative/api.html#sqlalchemy.ext.declarative.declarative_base" title="sqlalchemy.ext.declarative.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>
function.  In practice, the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class is always used
as a mixin along with an actual declarative base.</p>
<p>A new subclassable <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> is typically instantiated
using the <a class="reference internal" href="#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a> function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#"><span class="std std-ref">Automap</span></a></p>
</div>
<dl class="py attribute">
<dt id="sqlalchemy.ext.automap.AutomapBase.classes">
<em class="property">attribute </em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><code class="sig-name descname">classes</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Properties</span></code> containing classes.</p>
<p>This object behaves much like the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection on a table.  Classes
are present under the name they were given, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="n">some_engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span></pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sqlalchemy.ext.automap.AutomapBase.prepare">
<em class="property">method </em><a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase"><code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap.AutomapBase.</span></code></a><em class="property">classmethod </em><code class="sig-name descname">prepare</code><span class="sig-paren">(</span><em class="sig-param">engine=None</em>, <em class="sig-param">reflect=False</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">classname_for_table=&lt;function classname_for_table&gt;</em>, <em class="sig-param">collection_class=&lt;class 'list'&gt;</em>, <em class="sig-param">name_for_scalar_relationship=&lt;function name_for_scalar_relationship&gt;</em>, <em class="sig-param">name_for_collection_relationship=&lt;function name_for_collection_relationship&gt;</em>, <em class="sig-param">generate_relationship=&lt;function generate_relationship&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract mapped classes and relationships from the
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> and
perform mappings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.engine"></span><strong>engine</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine">¶</a> – an <a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> or
<a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> with which
to perform schema reflection, if specified.
If the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a> argument is False,
this object is not used.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect"></span><strong>reflect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect">¶</a> – if True, the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>
method is called
on the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> associated with this
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a>.
The <a class="reference internal" href="../../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> passed via
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.engine</span></code></a> will be used to perform the
reflection if present; else, the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
should already be
bound to some engine else the operation will fail.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table"></span><strong>classname_for_table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table">¶</a> – callable function which will be used to
produce new class names, given a table name.  Defaults to
<a class="reference internal" href="#sqlalchemy.ext.automap.classname_for_table" title="sqlalchemy.ext.automap.classname_for_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">classname_for_table()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship"></span><strong>name_for_scalar_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship">¶</a> – callable function which will be
used to produce relationship names for scalar relationships.  Defaults
to <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="sqlalchemy.ext.automap.name_for_scalar_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_scalar_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship"></span><strong>name_for_collection_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship">¶</a> – callable function which will
be used to produce relationship names for collection-oriented
relationships.  Defaults to <a class="reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="sqlalchemy.ext.automap.name_for_collection_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">name_for_collection_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship"></span><strong>generate_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship">¶</a> – callable function which will be used to
actually generate <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> and <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
constructs.  Defaults to <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_relationship()</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class"></span><strong>collection_class</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class">¶</a> – the Python collection class that will be used
when a new <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
object is created that represents a
collection.  Defaults to <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.schema"></span><strong>schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema">¶</a> – <p>When present in conjunction with the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a> flag, is passed to
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a>
to indicate the primary schema where tables
should be reflected from.  When omitted, the default schema in use
by the database connection is used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.1.</span></p>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="sqlalchemy.ext.automap.classname_for_table">
<em class="property">function </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">classname_for_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">tablename</span></em>, <em class="sig-param"><span class="n">table</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.classname_for_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the class name that should be used, given the name
of a table.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">tablename</span><span class="p">)</span></pre></div>
</div>
<p>Alternate implementations can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.classname_for_table</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.tablename"></span><strong>tablename</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.tablename">¶</a> – string name of the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.table"></span><strong>table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.table">¶</a> – the <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object itself.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a string class name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Python 2, the string used for the class name <strong>must</strong> be a
non-Unicode object, e.g. a <code class="docutils literal notranslate"><span class="pre">str()</span></code> object.  The <code class="docutils literal notranslate"><span class="pre">.name</span></code> attribute
of <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is typically a Python unicode subclass,
so the
<code class="docutils literal notranslate"><span class="pre">str()</span></code> function should be applied to this name, after accounting for
any non-ASCII characters.</p>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sqlalchemy.ext.automap.name_for_scalar_relationship">
<em class="property">function </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">name_for_scalar_relationship</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">local_cls</span></em>, <em class="sig-param"><span class="n">referred_cls</span></em>, <em class="sig-param"><span class="n">constraint</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute name that should be used to refer from one
class to another, for a scalar object reference.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></pre></div>
</div>
<p>Alternate implementations can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_scalar_relationship</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls">¶</a> – the class to be mapped on the local side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls">¶</a> – the class to be mapped on the referring side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint">¶</a> – the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> that is being
inspected to produce this relationship.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sqlalchemy.ext.automap.name_for_collection_relationship">
<em class="property">function </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">name_for_collection_relationship</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">local_cls</span></em>, <em class="sig-param"><span class="n">referred_cls</span></em>, <em class="sig-param"><span class="n">constraint</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute name that should be used to refer from one
class to another, for a collection reference.</p>
<p>The default implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_collection&quot;</span></pre></div>
</div>
<p>Alternate implementations
can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.name_for_collection_relationship</span></code></a>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls">¶</a> – the class to be mapped on the local side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls">¶</a> – the class to be mapped on the referring side.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint">¶</a> – the <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> that is being
inspected to produce this relationship.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sqlalchemy.ext.automap.generate_relationship">
<em class="property">function </em><code class="sig-prename descclassname">sqlalchemy.ext.automap.</code><code class="sig-name descname">generate_relationship</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">return_fn</span></em>, <em class="sig-param"><span class="n">attrname</span></em>, <em class="sig-param"><span class="n">local_cls</span></em>, <em class="sig-param"><span class="n">referred_cls</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.generate_relationship" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
on behalf of two
mapped classes.</p>
<p>An alternate implementation of this function can be specified using the
<a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.generate_relationship</span></code></a> parameter.</p>
<p>The default implementation of this function is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">backref</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">relationship</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown relationship function: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">return_fn</span><span class="p">)</span></pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.base">¶</a> – the <a class="reference internal" href="#sqlalchemy.ext.automap.AutomapBase" title="sqlalchemy.ext.automap.AutomapBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutomapBase</span></code></a> class doing the prepare.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.direction"></span><strong>direction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.direction">¶</a> – indicate the “direction” of the relationship; this will
be one of <a class="reference internal" href="../internals.html#sqlalchemy.orm.interfaces.ONETOMANY" title="sqlalchemy.orm.interfaces.ONETOMANY"><code class="xref py py-data docutils literal notranslate"><span class="pre">ONETOMANY</span></code></a>, <a class="reference internal" href="../internals.html#sqlalchemy.orm.interfaces.MANYTOONE" title="sqlalchemy.orm.interfaces.MANYTOONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">MANYTOONE</span></code></a>, <a class="reference internal" href="../internals.html#sqlalchemy.orm.interfaces.MANYTOMANY" title="sqlalchemy.orm.interfaces.MANYTOMANY"><code class="xref py py-data docutils literal notranslate"><span class="pre">MANYTOMANY</span></code></a>.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.return_fn"></span><strong>return_fn</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn">¶</a> – the function that is used by default to create the
relationship.  This will be either <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or
<a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>.  The <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> function’s result will be used to
produce a new <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> in a second step,
so it is critical
that user-defined implementations correctly differentiate between the two
functions, if a custom relationship function is being used.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.attrname"></span><strong>attrname</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.attrname">¶</a> – the attribute name to which this relationship is being
assigned. If the value of <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">generate_relationship.return_fn</span></code></a> is
the <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> function, then this name is the name that is being
assigned to the backref.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.local_cls">¶</a> – the “local” class to which this relationship or backref
will be locally present.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.referred_cls">¶</a> – the “referred” class to which the relationship or
backref refers to.</p></li>
<li><p><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.**kw">¶</a> – all additional keyword arguments are passed along to the
function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> or <a class="reference internal" href="../relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a> construct,
as dictated
by the <a class="reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn" title="sqlalchemy.ext.automap.generate_relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">generate_relationship.return_fn</span></code></a> parameter.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="associationproxy.html" title="previous chapter">Association Proxy</a>
        Next:
        <a href="baked.html" title="next chapter">Baked Queries</a>

    <div id="docs-copyright">
        &copy; <a href="../../copyright.html">Copyright</a> 2007-2020, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.0.3.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../../',
          VERSION:     '1.3.17',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../../_static/init.js"></script>


    </body>
</html>


