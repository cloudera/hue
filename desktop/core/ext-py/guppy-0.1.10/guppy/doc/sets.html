<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
   "http://www.w3.org/TR/REC-html40/strict.dtd">

<html lang=en>
 <head>
  <meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
  <title></title></head>
 <body>
  <div><a name='sets.module_sets'>
   <h1>.tgt.sets.module_sets</h1></a>
  <dl>
   <dt>
    <h2>Name</h2></dt>
   <dd>
    <h2>module_sets</h2></dd>
   <dt>
    <h2>Synopsis</h2></dt>
   <dd>
    <dl>
     <dt><strong><big>Methods</big></strong></dt>
     <dd><big><a href='#sets.module_sets.mutnodeset'>mutnodeset</a></big>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.MutNodeSet'>MutNodeSet</a></dd>
     <dd><big><a href='#sets.module_sets.immnodeset'>immnodeset</a></big>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dd></dl></dd>
   <dt>
    <h2>Methods</h2></dt>
   <dd><a name='sets.module_sets.mutnodeset'><strong><big>mutnodeset</big></strong></a>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.MutNodeSet'>MutNodeSet</a>
    <dl>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Returns </strong>
 a new mutable nodeset with specified elements.
</dt></dl></dd></dl></dd>
   <dd><a name='sets.module_sets.immnodeset'><strong><big>immnodeset</big></strong></a>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>
    <dl>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Returns </strong>
 a new immutable nodeset with specified elements.
</dt></dl></dd></dl></dd></dl><a name='kindnames.CommonSet'>
   <h1>.tgt.kindnames.CommonSet</h1></a>
  <dl>
   <dt>
    <h2>Name</h2></dt>
   <dd>
    <h2>CommonSet</h2></dd>
   <dt>
    <h2>Synopsis</h2></dt>
   <dd>
    <dl>
     <dt><strong><big>Conditions</big></strong></dt>
     <dd><a href='#sets.CommonSet.cond:contains'><strong><big>cond:contains</big></strong></a>(x, y)</dd>
     <dd><a href='#sets.CommonSet.cond:empty'><strong><big>cond:empty</big></strong></a>(x)</dd>
     <dd><a href='#sets.CommonSet.cond:equalset'><strong><big>cond:equalset</big></strong></a>(x, y)</dd>
     <dd><a href='#sets.CommonSet.cond:istrue'><strong><big>cond:istrue</big></strong></a>(x)</dd>
     <dd><a href='#sets.CommonSet.cond:subset'><strong><big>cond:subset</big></strong></a>(x, y)</dd></dl></dd>
   <dt>
    <h2>Conditions</h2></dt>
   <dt><a name='sets.CommonSet.cond:contains'><strong><big>cond:contains</big></strong></a>(x, y)</dt>
   <dd> True if the set x contains the element y.</dd>
   <dd>
    <dl>
     <dt><strong>Python code: </strong><code>y in x</code></dt></dl></dd>
   <dt><a name='sets.CommonSet.cond:empty'><strong><big>cond:empty</big></strong></a>(x)</dt>
   <dd> True if the set x is empty.</dd>
   <dd>
    <dl>
     <dt><strong>Python code: </strong><code>not x</code></dt></dl></dd>
   <dt><a name='sets.CommonSet.cond:equalset'><strong><big>cond:equalset</big></strong></a>(x, y)</dt>
   <dd> True if x contains the same elements as y.</dd>
   <dd>
    <dl>
     <dt><strong>Python code: </strong><code>immnodeset(x) == immnodeset(y)</code></dt>
     <dd>
      <dl>
       <dt><strong>in context: </strong><code>from guppy.sets import immnodeset</code></dt></dl></dd></dl></dd>
   <dt><a name='sets.CommonSet.cond:istrue'><strong><big>cond:istrue</big></strong></a>(x)</dt>
   <dd> True if the argument is true in the Python sense.</dd>
   <dd>
    <dl>
     <dt><strong>Python code: </strong><code>bool(x)</code></dt></dl></dd>
   <dt><a name='sets.CommonSet.cond:subset'><strong><big>cond:subset</big></strong></a>(x, y)</dt>
   <dd> True if x represents a non-strict subset of y:</dd>
   <dd> all elements in x are also in y.</dd>
   <dd>
    <dl>
     <dt><strong>Python code: </strong><code>immnodeset(x) &lt;= immnodeset(y)</code></dt>
     <dd>
      <dl>
       <dt><strong>in context: </strong><code>from guppy.sets import immnodeset</code></dt></dl></dd></dl></dd></dl><a name='kindnames.NodeSet'>
   <h1>.tgt.kindnames.NodeSet</h1></a>
  <dl>
   <dt>
    <h2>Name</h2></dt>
   <dd>
    <h2>NodeSet</h2></dd>
   <dt>
    <h2>Synopsis</h2></dt>
   <dd>
    <dl>
     <dt>
      <h3>For any object <var>x</var> of kind <a href='#kindnames.NodeSet'>NodeSet</a>:</h3></dt>
     <dt><strong><big>Operators</big></strong></dt>
     <dd><a href='#sets.NodeSet.op:-38-'># </a>x <big><strong>&amp;</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dd>
     <dd><a href='#sets.NodeSet.op:-124-'># </a>x <big><strong>|</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dd>
     <dd><a href='#sets.NodeSet.op:-94-'># </a>x <big><strong>^</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dd>
     <dd><a href='#sets.NodeSet.op:--'># </a>x <big><strong>-</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dd>
     <dd><a href='#sets.NodeSet.iop:-38--61-'># </a>x <big><strong>&amp;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a></dd>
     <dd><a href='#sets.NodeSet.iop:-124--61-'># </a>x <big><strong>|=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a></dd>
     <dd><a href='#sets.NodeSet.iop:-94--61-'># </a>x <big><strong>^=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a></dd>
     <dd><a href='#sets.NodeSet.iop:---61-'># </a>x <big><strong>-=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a></dd>
     <dd><a href='#sets.NodeSet.rop:in'># </a><var>y</var><code>:</code>&nbsp;<em>Any+</em><big> <strong>in</strong> </big>x <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-61--61-'># </a>x <big><strong>==</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-33--61-'># </a>x <big><strong>!=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-60--61-'># </a>x <big><strong>&lt;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-60-'># </a>x <big><strong>&lt;</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-62--61-'># </a>x <big><strong>&gt;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.op:-62-'># </a>x <big><strong>&gt;</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em></dd>
     <dd><a href='#sets.NodeSet.fop:iter'><big><strong>iter</strong></big></a>(x) <strong>-></strong> <em>iterator</em></dd>
     <dd><a href='#sets.NodeSet.fop:len'><big><strong>len</strong></big></a>(x) <strong>-></strong> <em>int</em></dd></dl></dd>
   <dt>
    <h2>Description</h2></dt>
   <dd>
A nodeset is a set of objects with equality based on heap address.
</dd>
   <dt>
    <h2>Operators</h2></dt>
   <dd><a name='sets.NodeSet.op:-38-'></a>x <big><strong>&amp;</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>
    <dl>
     <dd>

Intersection: the set of objects that are in both x and y.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(<em>returned value</em>, x)</dt>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(<em>returned value</em>, y)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-124-'></a>x <big><strong>|</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>
    <dl>
     <dd>

Union: the set of objects that are in either x or y.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(x, <em>returned value</em>)</dt>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(y, <em>returned value</em>)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-94-'></a>x <big><strong>^</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>
    <dl>
     <dd>

Symmetric set difference: the set of objects that are in exactly one of x and y.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:--'></a>x <big><strong>-</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>
    <dl>
     <dd>

Set difference: the set of objects that are in x but not in y.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.iop:-38--61-'></a>x <big><strong>&amp;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a>
    <dl>
     <dd>

In-place intersection.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(<em>returned value</em>, x)</dt>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(<em>returned value</em>, y)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.iop:-124--61-'></a>x <big><strong>|=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a>
    <dl>
     <dd>

In-place union.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(x, <em>returned value</em>)</dt>
         <dt><a href='#sets.CommonSet.cond:subset'>CommonSet.cond:subset</a>(y, <em>returned value</em>)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.iop:-94--61-'></a>x <big><strong>^=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a>
    <dl>
     <dd>

In-place symmetric set difference.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.iop:---61-'></a>x <big><strong>-=</strong></big> <var>y</var><code>:</code>&nbsp;<em>iterable+</em> <strong>-></strong> <a href='#kindnames.NodeSet'>NodeSet</a>
    <dl>
     <dd>

In-place set difference.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.rop:in'></a><var>y</var><code>:</code>&nbsp;<em>Any+</em><big> <strong>in</strong> </big>x <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Inclusion test.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-61--61-'></a>x <big><strong>==</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Equal:
    x and y contain the same elements.
</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-33--61-'></a>x <big><strong>!=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Not equal:
             x and y do not contain the same elements.
</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-60--61-'></a>x <big><strong>&lt;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Subset, non-strict:
             all elements in x are also in y.</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-60-'></a>x <big><strong>&lt;</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Subset, strict:
             all elements in x are also in y,
             and y contains some element not in x.
</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-62--61-'></a>x <big><strong>&gt;=</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Superset, non-strict:
             all elements in y are also in x.
</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.op:-62-'></a>x <big><strong>&gt;</strong></big> <var>y</var><code>:</code>&nbsp;<em>NodeSet+</em> <strong>-></strong> <em>boolean</em>
    <dl>
     <dd>

Superset, strict:
             all elements in y are also in x,
             and x contains some element not in y.
</dd>
     <dd>
      <dl></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.fop:iter'><big><strong>iter</strong></big></a>(x) <strong>-></strong> <em>iterator</em>
    <dl>
     <dd> Iteration</dd>
     <dd>
      <dl>
       <dt><strong>Returns </strong>an iterator yielding the elements of x.</dt>
       <dd>(The order is implementation dependent.)</dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:equalset'>CommonSet.cond:equalset</a>(<em>returned value</em>, x)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='sets.NodeSet.fop:len'><big><strong>len</strong></big></a>(x) <strong>-></strong> <em>int</em>
    <dl>
     <dd> Length</dd>
     <dd>
      <dl>
       <dt><strong>Returns </strong>
the number of elements in x.
</dt></dl></dd></dl></dd></dl><a name='kindnames.MutNodeSet'>
   <h1>.tgt.kindnames.MutNodeSet</h1></a>
  <dl>
   <dt>
    <h2>Name</h2></dt>
   <dd>
    <h2>MutNodeSet</h2></dd>
   <dt>
    <h2>Synopsis</h2></dt>
   <dd>
    <dl>
     <dt><strong><big><a href='#sets.MutNodeSet.-60-1-62-'>Subkind of</a><code>:</code>&nbsp;<a href='#kindnames.NodeSet'>NodeSet</a></big></strong></dt>
     <dt><big><strong>Constructor</strong></big></dt>
     <dd>
      <dl>
       <dt><a href='#sets.module_sets'>module_sets</a><big><code>.</code><a href='#sets.module_sets.mutnodeset'>mutnodeset</a></big>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.MutNodeSet'>MutNodeSet</a></dt></dl></dd>
     <dt>
      <h3>For any object <var>S</var> of kind <a href='#kindnames.MutNodeSet'>MutNodeSet</a>:</h3></dt>
     <dt><strong><big>Methods</big></strong></dt>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.add'>add</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.append'>append</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.clear'>clear</a></big>()</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.discard'>discard</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.pop'>pop</a></big>()</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.remove'>remove</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)</dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.tas'>tas</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>) <strong>-></strong> <em>boolean</em></dd>
     <dd>S<big><code>.</code><a href='#kindnames.MutNodeSet.tac'>tac</a></big>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>) <strong>-></strong> <em>boolean</em></dd></dl></dd>
   <dt>
    <h2>Description</h2></dt>
   <dd> A mutable nodeset is a nodeset object that can be updated in place. </dd>
   <dt>
    <h2><a name='sets.MutNodeSet.-60-1-62-'>Subkind of</a><code>:</code>&nbsp;<a href='#kindnames.NodeSet'>NodeSet</a></h2></dt>
   <dd> All operations from the NodeSet kind are inherited.</dd>
   <dd>
 The in-place operators (&amp;=, |= etc) update the target set in place
and return the same object.</dd>
   <dd>
 It is unspecified what happens when trying to update a mutable nodeset
for which an iterator object (from the iter() function) is active.
</dd>
   <dt>
    <h2>Methods</h2></dt>
   <dd><a name='kindnames.MutNodeSet.add'>S<code>.</code><strong><big>add</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)
    <dl>
     <dd> Add e to S; no effect if e was already in S.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt>
         <dt>not <a href='#sets.CommonSet.cond:empty'>CommonSet.cond:empty</a>(S)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.append'>S<code>.</code><strong><big>append</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)
    <dl>
     <dd> Add e to S, or raise ValueError if e was already in S.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Precondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt></dl></dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt>
         <dt>not <a href='#sets.CommonSet.cond:empty'>CommonSet.cond:empty</a>(S)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.clear'>S<code>.</code><strong><big>clear</big></strong></a>()
    <dl>
     <dd> Remove all elements from S, and compact its storage.</dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:empty'>CommonSet.cond:empty</a>(S)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.discard'>S<code>.</code><strong><big>discard</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)
    <dl>
     <dd> Remove e from S; no effect if e was not in S.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.pop'>S<code>.</code><strong><big>pop</big></strong></a>()
    <dl>
     <dd> Remove and return some object from S, or raise ValueError if S was empty.</dd>
     <dd>
      <dl>
       <dt><strong>Precondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:empty'>CommonSet.cond:empty</a>(S)</dt></dl></dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, <em>returned value</em>)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.remove'>S<code>.</code><strong><big>remove</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>)
    <dl>
     <dd> Remove e from S, or raise ValueError if e was not in S.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Precondition</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt></dl></dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.tas'>S<code>.</code><strong><big>tas</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>) <strong>-></strong> <em>boolean</em>
    <dl>
     <dd> Test and Set.</dd>
     <dd> If e is in S return True,</dd>
     <dd> else add e to S and return False.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postconditions</strong></dt>
       <dd>
        <dl>
         <dt><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt>
         <dt>not <a href='#sets.CommonSet.cond:empty'>CommonSet.cond:empty</a>(S)</dt></dl></dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Equation</strong></dt>
       <dd>
        <dl>
         <dt><strong><sup>pre:</sup></strong><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)<big> == </big><strong><sup>post:</sup></strong><a href='#sets.CommonSet.cond:istrue'>CommonSet.cond:istrue</a>(<em>returned value</em>)</dt></dl></dd></dl></dd></dl></dd>
   <dd><a name='kindnames.MutNodeSet.tac'>S<code>.</code><strong><big>tac</big></strong></a>(<var>e</var><code>:</code>&nbsp;<em>Any+</em>) <strong>-></strong> <em>boolean</em>
    <dl>
     <dd> Test and Clear.</dd>
     <dd> If e is in S, remove e from S and return True,</dd>
     <dd> else return False.</dd>
     <dd>
      <dl></dl></dd>
     <dd>
      <dl>
       <dt><strong>Postcondition</strong></dt>
       <dd>
        <dl>
         <dt>not <a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)</dt></dl></dd></dl></dd>
     <dd>
      <dl>
       <dt><strong>Equation</strong></dt>
       <dd>
        <dl>
         <dt><strong><sup>pre:</sup></strong><a href='#sets.CommonSet.cond:contains'>CommonSet.cond:contains</a>(S, e)<big> == </big><strong><sup>post:</sup></strong><a href='#sets.CommonSet.cond:istrue'>CommonSet.cond:istrue</a>(<em>returned value</em>)</dt></dl></dd></dl></dd></dl></dd></dl><a name='kindnames.ImmNodeSet'>
   <h1>.tgt.kindnames.ImmNodeSet</h1></a>
  <dl>
   <dt>
    <h2>Name</h2></dt>
   <dd>
    <h2>ImmNodeSet</h2></dd>
   <dt>
    <h2>Synopsis</h2></dt>
   <dd>
    <dl>
     <dt><strong><big><a href='#sets.ImmNodeSet.-60-1-62-'>Subkind of</a><code>:</code>&nbsp;<a href='#kindnames.NodeSet'>NodeSet</a></big></strong></dt>
     <dt><big><strong>Constructor</strong></big></dt>
     <dd>
      <dl>
       <dt><a href='#sets.module_sets'>module_sets</a><big><code>.</code><a href='#sets.module_sets.immnodeset'>immnodeset</a></big>( [<var>elements</var><code>:</code>&nbsp;<em>iterable+</em>]) <strong>-></strong> <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a></dt></dl></dd>
     <dt>
      <h3>For any object <var>x</var> of kind <a href='#kindnames.ImmNodeSet'>ImmNodeSet</a>:</h3></dt>
     <dt><strong><big>Operator</big></strong></dt>
     <dd><a href='#sets.ImmNodeSet.fop:hash'><big><strong>hash</strong></big></a>(x) <strong>-></strong> <em>int</em></dd></dl></dd>
   <dt>
    <h2>Description</h2></dt>
   <dd>
 An immutable nodeset is a nodeset object that is guaranteed to always
contain the same elements after it has been created.
</dd>
   <dt>
    <h2><a name='sets.ImmNodeSet.-60-1-62-'>Subkind of</a><code>:</code>&nbsp;<a href='#kindnames.NodeSet'>NodeSet</a></h2></dt>
   <dd> An immutable nodeset inherits the operations defined for NodeSet.</dd>
   <dd>
 The in-place operations (&amp;=, |= etc) will not really update the
target set in place, but will return an updated copy. It is yet formally
unspecified whether this returned copy is mutable or immutable.
</dd>
   <dt>
    <h2>Operator</h2></dt>
   <dd><a name='sets.ImmNodeSet.fop:hash'><big><strong>hash</strong></big></a>(x) <strong>-></strong> <em>int</em>
    <dl>
     <dd> Hashing</dd>
     <dd>
      <dl>
       <dt><strong>Returns </strong>
 a hash value based on the addresses of the elements.

</dt></dl></dd></dl></dd></dl>
  <hr>Generated by <a href="http://guppy-pe.sourceforge.net/gsl.html">GSL-HTML 0.1.5</a> on Sat Jul  4 13:25:10 2009</div></body></html>