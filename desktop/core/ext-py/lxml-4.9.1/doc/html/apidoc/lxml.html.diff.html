<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lxml.html.diff module &mdash; lxml  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="lxml.html.formfill module" href="lxml.html.formfill.html" />
    <link rel="prev" title="lxml.html.defs module" href="lxml.html.defs.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> lxml
            <img src="_static/python-xml.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                4.9.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="lxml.html">lxml package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lxml.html.html">lxml.html package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lxml.html.ElementSoup.html">lxml.html.ElementSoup module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html._diffcommand.html">lxml.html._diffcommand module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html._setmixin.html">lxml.html._setmixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.builder.html">lxml.html.builder module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.clean.html">lxml.html.clean module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.defs.html">lxml.html.defs module</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">lxml.html.diff module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.formfill.html">lxml.html.formfill module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.html5parser.html">lxml.html.html5parser module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lxml.html.soupparser.html">lxml.html.soupparser module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lxml.isoschematron.html">lxml.isoschematron package</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.ElementInclude.html">lxml.ElementInclude module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml._elementpath.html">lxml._elementpath module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.builder.html">lxml.builder module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.cssselect.html">lxml.cssselect module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.doctestcompare.html">lxml.doctestcompare module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.etree.html">lxml.etree module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.objectify.html">lxml.objectify module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lxml.sax.html">lxml.sax module</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">lxml</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="lxml.html">lxml package</a> &raquo;</li>
          <li><a href="lxml.html.html">lxml.html package</a> &raquo;</li>
      <li>lxml.html.diff module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lxml.html.diff.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-lxml.html.diff">
<span id="lxml-html-diff-module"></span><h1>lxml.html.diff module<a class="headerlink" href="#module-lxml.html.diff" title="Permalink to this heading"></a></h1>
<dl class="py exception">
<dt class="sig sig-object py" id="lxml.html.diff.NoDeletes">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">NoDeletes</span></span><a class="headerlink" href="#lxml.html.diff.NoDeletes" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when the document no longer contains any pending deletes
(DEL_START/DEL_END)</p>
<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.NoDeletes.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.NoDeletes.with_traceback" title="Permalink to this definition"></a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lxml.html.diff.NoDeletes.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#lxml.html.diff.NoDeletes.args" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.DEL_END">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">DEL_END</span></span><a class="headerlink" href="#lxml.html.diff.DEL_END" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.DEL_START">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">DEL_START</span></span><a class="headerlink" href="#lxml.html.diff.DEL_START" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">InsensitiveSequenceMatcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isjunk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autojunk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></p>
<p>Acts like SequenceMatcher, but tries not to find very small equal
blocks amidst large spans of changes</p>
<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.find_longest_match">
<span class="sig-name descname"><span class="pre">find_longest_match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ahi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bhi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.find_longest_match" title="Permalink to this definition"></a></dt>
<dd><p>Find longest matching block in a[alo:ahi] and b[blo:bhi].</p>
<p>By default it will find the longest match in the entirety of a and b.</p>
<p>If isjunk is not defined:</p>
<dl class="simple">
<dt>Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</dt><dd><p>alo &lt;= i &lt;= i+k &lt;= ahi
blo &lt;= j &lt;= j+k &lt;= bhi</p>
</dd>
<dt>and for all (i’,j’,k’) meeting those conditions,</dt><dd><p>k &gt;= k’
i &lt;= i’
and if i == i’, j &lt;= j’</p>
</dd>
</dl>
<p>In other words, of all maximal matching blocks, return one that
starts earliest in a, and of all those maximal matching blocks that
start earliest in a, return the one that starts earliest in b.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot; abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=0, b=4, size=5)</span>
</pre></div>
</div>
<p>If isjunk is defined, first the longest matching block is
determined as above, but with the additional restriction that no
junk element appears in the block.  Then that block is extended as
far as possible by matching (only) junk elements on both sides.  So
the resulting block never matches on junk except as identical junk
happens to be adjacent to an “interesting” match.</p>
<p>Here’s the same example as before, but considering blanks to be
junk.  That prevents ” abcd” from matching the ” abcd” at the tail
end of the second sequence directly.  Instead only the “abcd” can
match, and matches the leftmost “abcd” in the second sequence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">==</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=1, b=0, size=4)</span>
</pre></div>
</div>
<p>If no blocks match, return (alo, blo, 0).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Match(a=0, b=0, size=0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.get_grouped_opcodes">
<span class="sig-name descname"><span class="pre">get_grouped_opcodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.get_grouped_opcodes" title="Permalink to this definition"></a></dt>
<dd><p>Isolate change clusters by eliminating ranges with no changes.</p>
<p>Return a generator of groups with up to n lines of context.
Each group is in the same format as returned by get_opcodes().</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span>     <span class="c1"># Make an insertion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;x&#39;</span>       <span class="c1"># Make a replacement</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">23</span><span class="p">:</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># Make a deletion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;y&#39;</span>       <span class="c1"># Make another replacement</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">get_grouped_opcodes</span><span class="p">()))</span>
<span class="go">[[(&#39;equal&#39;, 5, 8, 5, 8), (&#39;insert&#39;, 8, 8, 8, 9), (&#39;equal&#39;, 8, 11, 9, 12)],</span>
<span class="go"> [(&#39;equal&#39;, 16, 19, 17, 20),</span>
<span class="go">  (&#39;replace&#39;, 19, 20, 20, 21),</span>
<span class="go">  (&#39;equal&#39;, 20, 22, 21, 23),</span>
<span class="go">  (&#39;delete&#39;, 22, 27, 23, 23),</span>
<span class="go">  (&#39;equal&#39;, 27, 30, 23, 26)],</span>
<span class="go"> [(&#39;equal&#39;, 31, 34, 27, 30),</span>
<span class="go">  (&#39;replace&#39;, 34, 35, 30, 31),</span>
<span class="go">  (&#39;equal&#39;, 35, 38, 31, 34)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.get_matching_blocks">
<span class="sig-name descname"><span class="pre">get_matching_blocks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.get_matching_blocks" title="Permalink to this definition"></a></dt>
<dd><p>Return list of triples describing matching subsequences.</p>
<p>Each triple is of the form (i, j, n), and means that
a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
i and in j.  New in Python 2.5, it’s also guaranteed that if
(i, j, n) and (i’, j’, n’) are adjacent triples in the list, and
the second is not the last triple in the list, then i+n != i’ or
j+n != j’.  IOW, adjacent triples never describe adjacent equal
blocks.</p>
<p>The last triple is a dummy, (len(a), len(b), 0), and is the only
triple with n==0.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abxcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">())</span>
<span class="go">[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.get_opcodes">
<span class="sig-name descname"><span class="pre">get_opcodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.get_opcodes" title="Permalink to this definition"></a></dt>
<dd><p>Return list of 5-tuples describing how to turn a into b.</p>
<p>Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
tuple preceding it, and likewise for j1 == the previous j2.</p>
<p>The tags are strings, with these meanings:</p>
<p>‘replace’:  a[i1:i2] should be replaced by b[j1:j2]
‘delete’:   a[i1:i2] should be deleted.</p>
<blockquote>
<div><p>Note that j1==j2 in this case.</p>
</div></blockquote>
<dl class="simple">
<dt>‘insert’:   b[j1:j2] should be inserted at a[i1:i1].</dt><dd><p>Note that i1==i2 in this case.</p>
</dd>
</dl>
<p>‘equal’:    a[i1:i2] == b[j1:j2]</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;qabxcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;abycdf&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_opcodes</span><span class="p">():</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%7s</span><span class="s2"> a[</span><span class="si">%d</span><span class="s2">:</span><span class="si">%d</span><span class="s2">] (</span><span class="si">%s</span><span class="s2">) b[</span><span class="si">%d</span><span class="s2">:</span><span class="si">%d</span><span class="s2">] (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
<span class="gp">... </span>          <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">j1</span><span class="p">:</span><span class="n">j2</span><span class="p">])))</span>
<span class="go"> delete a[0:1] (q) b[0:0] ()</span>
<span class="go">  equal a[1:3] (ab) b[0:2] (ab)</span>
<span class="go">replace a[3:4] (x) b[2:3] (y)</span>
<span class="go">  equal a[4:6] (cd) b[3:5] (cd)</span>
<span class="go"> insert a[6:6] () b[5:6] (f)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.quick_ratio">
<span class="sig-name descname"><span class="pre">quick_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.quick_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Return an upper bound on ratio() relatively quickly.</p>
<p>This isn’t defined beyond that it is an upper bound on .ratio(), and
is faster to compute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.ratio">
<span class="sig-name descname"><span class="pre">ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.ratio" title="Permalink to this definition"></a></dt>
<dd><p>Return a measure of the sequences’ similarity (float in [0,1]).</p>
<p>Where T is the total number of elements in both sequences, and
M is the number of matches, this is 2.0*M / T.
Note that this is 1 if the sequences are identical, and 0 if
they have nothing in common.</p>
<p>.ratio() is expensive to compute if you haven’t already computed
.get_matching_blocks() or .get_opcodes(), in which case you may
want to try .quick_ratio() or .real_quick_ratio() first to get an
upper bound.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">quick_ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">real_quick_ratio</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.real_quick_ratio">
<span class="sig-name descname"><span class="pre">real_quick_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.real_quick_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Return an upper bound on ratio() very quickly.</p>
<p>This isn’t defined beyond that it is an upper bound on .ratio(), and
is faster to compute than either .ratio() or .quick_ratio().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.set_seq1">
<span class="sig-name descname"><span class="pre">set_seq1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.set_seq1" title="Permalink to this definition"></a></dt>
<dd><p>Set the first sequence to be compared.</p>
<p>The second sequence to be compared is not changed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_seq1</span><span class="p">(</span><span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">1.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>SequenceMatcher computes and caches detailed information about the
second sequence, so if you want to compare one sequence S against
many sequences, use .set_seq2(S) once and call .set_seq1(x)
repeatedly for each of the other sequences.</p>
<p>See also set_seqs() and set_seq2().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.set_seq2">
<span class="sig-name descname"><span class="pre">set_seq2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.set_seq2" title="Permalink to this definition"></a></dt>
<dd><p>Set the second sequence to be compared.</p>
<p>The first sequence to be compared is not changed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_seq2</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">1.0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>SequenceMatcher computes and caches detailed information about the
second sequence, so if you want to compare one sequence S against
many sequences, use .set_seq2(S) once and call .set_seq1(x)
repeatedly for each of the other sequences.</p>
<p>See also set_seqs() and set_seq1().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.set_seqs">
<span class="sig-name descname"><span class="pre">set_seqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.set_seqs" title="Permalink to this definition"></a></dt>
<dd><p>Set the two sequences to be compared.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_seqs</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lxml.html.diff.InsensitiveSequenceMatcher.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#lxml.html.diff.InsensitiveSequenceMatcher.threshold" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.href_token">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">href_token</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trailing_whitespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lxml.html.diff.token" title="lxml.html.diff.token"><code class="xref py py-class docutils literal notranslate"><span class="pre">token</span></code></a></p>
<p>Represents the href in an anchor tag.  Unlike other words, we only
show the href when it changes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.capitalize">
<span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.capitalize" title="Permalink to this definition"></a></dt>
<dd><p>Return a capitalized version of the string.</p>
<p>More specifically, make the first character have upper case and the rest lower
case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.casefold">
<span class="sig-name descname"><span class="pre">casefold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.casefold" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string suitable for caseless comparisons.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.center" title="Permalink to this definition"></a></dt>
<dd><p>Return a centered string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.count" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode the string using the codec registered for encoding.</p>
<dl class="simple">
<dt>encoding</dt><dd><p>The encoding in which to encode the string.</p>
</dd>
<dt>errors</dt><dd><p>The error handling scheme to use for encoding errors.
The default is ‘strict’ meaning that encoding errors raise a
UnicodeEncodeError.  Other possible values are ‘ignore’, ‘replace’ and
‘xmlcharrefreplace’ as well as any other name registered with
codecs.register_error that can handle UnicodeEncodeErrors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.endswith">
<span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.endswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.expandtabs">
<span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.expandtabs" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy where all tab characters are expanded using spaces.</p>
<p>If tabsize is not given, a tab size of 8 characters is assumed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.find" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.format" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.format_map">
<span class="sig-name descname"><span class="pre">format_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.format_map" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.html">
<span class="sig-name descname"><span class="pre">html</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.html" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.index">
<span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.index" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isalnum">
<span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isalnum" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alpha-numeric string, False otherwise.</p>
<p>A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isalpha">
<span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isalpha" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alphabetic string, False otherwise.</p>
<p>A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isascii">
<span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isascii" title="Permalink to this definition"></a></dt>
<dd><p>Return True if all characters in the string are ASCII, False otherwise.</p>
<p>ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isdecimal">
<span class="sig-name descname"><span class="pre">isdecimal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isdecimal" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a decimal string, False otherwise.</p>
<p>A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isdigit">
<span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isdigit" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a digit string, False otherwise.</p>
<p>A string is a digit string if all characters in the string are digits and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isidentifier">
<span class="sig-name descname"><span class="pre">isidentifier</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isidentifier" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a valid Python identifier, False otherwise.</p>
<p>Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as “def” or “class”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.islower">
<span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.islower" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a lowercase string, False otherwise.</p>
<p>A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isnumeric">
<span class="sig-name descname"><span class="pre">isnumeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isnumeric" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a numeric string, False otherwise.</p>
<p>A string is numeric if all characters in the string are numeric and there is at
least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isprintable">
<span class="sig-name descname"><span class="pre">isprintable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isprintable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is printable, False otherwise.</p>
<p>A string is printable if all of its characters are considered printable in
repr() or if it is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isspace">
<span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isspace" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a whitespace string, False otherwise.</p>
<p>A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.istitle">
<span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.istitle" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a title-cased string, False otherwise.</p>
<p>In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.isupper">
<span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.isupper" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an uppercase string, False otherwise.</p>
<p>A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.join" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate any number of strings.</p>
<p>The string whose method is called is inserted in between each given string.
The result is returned as a new string.</p>
<p>Example: ‘.’.join([‘ab’, ‘pq’, ‘rs’]) -&gt; ‘ab.pq.rs’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.ljust">
<span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.ljust" title="Permalink to this definition"></a></dt>
<dd><p>Return a left-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.lower">
<span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.lower" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to lowercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.lstrip">
<span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.lstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.maketrans" title="Permalink to this definition"></a></dt>
<dd><p>Return a translation table usable for str.translate().</p>
<p>If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y. If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.partition">
<span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.partition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.removeprefix">
<span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.removeprefix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given prefix string removed if present.</p>
<p>If the string starts with the prefix string, return string[len(prefix):].
Otherwise, return a copy of the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.removesuffix">
<span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.removesuffix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given suffix string removed if present.</p>
<p>If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.replace" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy with all occurrences of substring old replaced by new.</p>
<blockquote>
<div><dl class="simple">
<dt>count</dt><dd><p>Maximum number of occurrences to replace.
-1 (the default value) means replace all occurrences.</p>
</dd>
</dl>
</div></blockquote>
<p>If the optional argument count is given, only the first count occurrences are
replaced.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rfind">
<span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.rfind" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rindex">
<span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.rindex" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rjust">
<span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.rjust" title="Permalink to this definition"></a></dt>
<dd><p>Return a right-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rpartition">
<span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.rpartition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rsplit">
<span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.rsplit" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<blockquote>
<div><dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</div></blockquote>
<p>Splits are done starting at the end of the string and working to the front.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.rstrip">
<span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.rstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.split" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.splitlines">
<span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.splitlines" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the lines in the string, breaking at line boundaries.</p>
<p>Line breaks are not included in the resulting list unless keepends is given and
true.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.startswith">
<span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.href_token.startswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.strip">
<span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.strip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading and trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.swapcase">
<span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.swapcase" title="Permalink to this definition"></a></dt>
<dd><p>Convert uppercase characters to lowercase and lowercase characters to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.title">
<span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.title" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string where each word is titlecased.</p>
<p>More specifically, words start with uppercased characters and all remaining
cased characters have lower case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.translate" title="Permalink to this definition"></a></dt>
<dd><p>Replace each character in the string using the given translation table.</p>
<blockquote>
<div><dl class="simple">
<dt>table</dt><dd><p>Translation table, which must be a mapping of Unicode ordinals to
Unicode ordinals, strings, or None.</p>
</dd>
</dl>
</div></blockquote>
<p>The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.upper">
<span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.upper" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.zfill">
<span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.href_token.zfill" title="Permalink to this definition"></a></dt>
<dd><p>Pad a numeric string with zeros on the left, to fill a field of the given width.</p>
<p>The string is never truncated.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lxml.html.diff.href_token.hide_when_equal">
<span class="sig-name descname"><span class="pre">hide_when_equal</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#lxml.html.diff.href_token.hide_when_equal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">tag_token</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">html_repr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trailing_whitespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lxml.html.diff.token" title="lxml.html.diff.token"><code class="xref py py-class docutils literal notranslate"><span class="pre">token</span></code></a></p>
<p>Represents a token that is actually a tag.  Currently this is just
the &lt;img&gt; tag, which takes up visible space just like a word but
is only represented in a document by a tag.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.capitalize">
<span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.capitalize" title="Permalink to this definition"></a></dt>
<dd><p>Return a capitalized version of the string.</p>
<p>More specifically, make the first character have upper case and the rest lower
case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.casefold">
<span class="sig-name descname"><span class="pre">casefold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.casefold" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string suitable for caseless comparisons.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.center" title="Permalink to this definition"></a></dt>
<dd><p>Return a centered string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.count" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode the string using the codec registered for encoding.</p>
<dl class="simple">
<dt>encoding</dt><dd><p>The encoding in which to encode the string.</p>
</dd>
<dt>errors</dt><dd><p>The error handling scheme to use for encoding errors.
The default is ‘strict’ meaning that encoding errors raise a
UnicodeEncodeError.  Other possible values are ‘ignore’, ‘replace’ and
‘xmlcharrefreplace’ as well as any other name registered with
codecs.register_error that can handle UnicodeEncodeErrors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.endswith">
<span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.endswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.expandtabs">
<span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.expandtabs" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy where all tab characters are expanded using spaces.</p>
<p>If tabsize is not given, a tab size of 8 characters is assumed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.find" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.format" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.format_map">
<span class="sig-name descname"><span class="pre">format_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.format_map" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.html">
<span class="sig-name descname"><span class="pre">html</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.html" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.index">
<span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.index" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isalnum">
<span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isalnum" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alpha-numeric string, False otherwise.</p>
<p>A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isalpha">
<span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isalpha" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alphabetic string, False otherwise.</p>
<p>A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isascii">
<span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isascii" title="Permalink to this definition"></a></dt>
<dd><p>Return True if all characters in the string are ASCII, False otherwise.</p>
<p>ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isdecimal">
<span class="sig-name descname"><span class="pre">isdecimal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isdecimal" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a decimal string, False otherwise.</p>
<p>A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isdigit">
<span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isdigit" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a digit string, False otherwise.</p>
<p>A string is a digit string if all characters in the string are digits and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isidentifier">
<span class="sig-name descname"><span class="pre">isidentifier</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isidentifier" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a valid Python identifier, False otherwise.</p>
<p>Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as “def” or “class”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.islower">
<span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.islower" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a lowercase string, False otherwise.</p>
<p>A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isnumeric">
<span class="sig-name descname"><span class="pre">isnumeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isnumeric" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a numeric string, False otherwise.</p>
<p>A string is numeric if all characters in the string are numeric and there is at
least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isprintable">
<span class="sig-name descname"><span class="pre">isprintable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isprintable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is printable, False otherwise.</p>
<p>A string is printable if all of its characters are considered printable in
repr() or if it is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isspace">
<span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isspace" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a whitespace string, False otherwise.</p>
<p>A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.istitle">
<span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.istitle" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a title-cased string, False otherwise.</p>
<p>In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.isupper">
<span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.isupper" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an uppercase string, False otherwise.</p>
<p>A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.join" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate any number of strings.</p>
<p>The string whose method is called is inserted in between each given string.
The result is returned as a new string.</p>
<p>Example: ‘.’.join([‘ab’, ‘pq’, ‘rs’]) -&gt; ‘ab.pq.rs’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.ljust">
<span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.ljust" title="Permalink to this definition"></a></dt>
<dd><p>Return a left-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.lower">
<span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.lower" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to lowercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.lstrip">
<span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.lstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.maketrans" title="Permalink to this definition"></a></dt>
<dd><p>Return a translation table usable for str.translate().</p>
<p>If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y. If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.partition">
<span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.partition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.removeprefix">
<span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.removeprefix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given prefix string removed if present.</p>
<p>If the string starts with the prefix string, return string[len(prefix):].
Otherwise, return a copy of the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.removesuffix">
<span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.removesuffix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given suffix string removed if present.</p>
<p>If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.replace" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy with all occurrences of substring old replaced by new.</p>
<blockquote>
<div><dl class="simple">
<dt>count</dt><dd><p>Maximum number of occurrences to replace.
-1 (the default value) means replace all occurrences.</p>
</dd>
</dl>
</div></blockquote>
<p>If the optional argument count is given, only the first count occurrences are
replaced.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rfind">
<span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.rfind" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rindex">
<span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.rindex" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rjust">
<span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.rjust" title="Permalink to this definition"></a></dt>
<dd><p>Return a right-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rpartition">
<span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.rpartition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rsplit">
<span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.rsplit" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<blockquote>
<div><dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</div></blockquote>
<p>Splits are done starting at the end of the string and working to the front.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.rstrip">
<span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.rstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.split" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.splitlines">
<span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.splitlines" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the lines in the string, breaking at line boundaries.</p>
<p>Line breaks are not included in the resulting list unless keepends is given and
true.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.startswith">
<span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.tag_token.startswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.strip">
<span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.strip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading and trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.swapcase">
<span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.swapcase" title="Permalink to this definition"></a></dt>
<dd><p>Convert uppercase characters to lowercase and lowercase characters to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.title">
<span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.title" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string where each word is titlecased.</p>
<p>More specifically, words start with uppercased characters and all remaining
cased characters have lower case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.translate" title="Permalink to this definition"></a></dt>
<dd><p>Replace each character in the string using the given translation table.</p>
<blockquote>
<div><dl class="simple">
<dt>table</dt><dd><p>Translation table, which must be a mapping of Unicode ordinals to
Unicode ordinals, strings, or None.</p>
</dd>
</dl>
</div></blockquote>
<p>The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.upper">
<span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.upper" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.zfill">
<span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tag_token.zfill" title="Permalink to this definition"></a></dt>
<dd><p>Pad a numeric string with zeros on the left, to fill a field of the given width.</p>
<p>The string is never truncated.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lxml.html.diff.tag_token.hide_when_equal">
<span class="sig-name descname"><span class="pre">hide_when_equal</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#lxml.html.diff.tag_token.hide_when_equal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lxml.html.diff.token">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">token</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trailing_whitespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
<p>Represents a diffable token, generally a word that is displayed to
the user.  Opening tags are attached to this token when they are
adjacent (pre_tags) and closing tags that follow the word
(post_tags).  Some exceptions occur when there are empty tags
adjacent to a word, so there may be close tags in pre_tags, or
open tags in post_tags.</p>
<p>We also keep track of whether the word was originally followed by
whitespace, even though we do not want to treat the word as
equivalent to a similar word that does not have a trailing
space.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.capitalize">
<span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.capitalize" title="Permalink to this definition"></a></dt>
<dd><p>Return a capitalized version of the string.</p>
<p>More specifically, make the first character have upper case and the rest lower
case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.casefold">
<span class="sig-name descname"><span class="pre">casefold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.casefold" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string suitable for caseless comparisons.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.center" title="Permalink to this definition"></a></dt>
<dd><p>Return a centered string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.token.count" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode the string using the codec registered for encoding.</p>
<dl class="simple">
<dt>encoding</dt><dd><p>The encoding in which to encode the string.</p>
</dd>
<dt>errors</dt><dd><p>The error handling scheme to use for encoding errors.
The default is ‘strict’ meaning that encoding errors raise a
UnicodeEncodeError.  Other possible values are ‘ignore’, ‘replace’ and
‘xmlcharrefreplace’ as well as any other name registered with
codecs.register_error that can handle UnicodeEncodeErrors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.endswith">
<span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.token.endswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.expandtabs">
<span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.expandtabs" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy where all tab characters are expanded using spaces.</p>
<p>If tabsize is not given, a tab size of 8 characters is assumed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.token.find" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.token.format" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.format_map">
<span class="sig-name descname"><span class="pre">format_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#lxml.html.diff.token.format_map" title="Permalink to this definition"></a></dt>
<dd><p>Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces (‘{’ and ‘}’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.html">
<span class="sig-name descname"><span class="pre">html</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.html" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.index">
<span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.token.index" title="Permalink to this definition"></a></dt>
<dd><p>Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isalnum">
<span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isalnum" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alpha-numeric string, False otherwise.</p>
<p>A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isalpha">
<span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isalpha" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an alphabetic string, False otherwise.</p>
<p>A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isascii">
<span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isascii" title="Permalink to this definition"></a></dt>
<dd><p>Return True if all characters in the string are ASCII, False otherwise.</p>
<p>ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isdecimal">
<span class="sig-name descname"><span class="pre">isdecimal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isdecimal" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a decimal string, False otherwise.</p>
<p>A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isdigit">
<span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isdigit" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a digit string, False otherwise.</p>
<p>A string is a digit string if all characters in the string are digits and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isidentifier">
<span class="sig-name descname"><span class="pre">isidentifier</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isidentifier" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a valid Python identifier, False otherwise.</p>
<p>Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as “def” or “class”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.islower">
<span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.islower" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a lowercase string, False otherwise.</p>
<p>A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isnumeric">
<span class="sig-name descname"><span class="pre">isnumeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isnumeric" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a numeric string, False otherwise.</p>
<p>A string is numeric if all characters in the string are numeric and there is at
least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isprintable">
<span class="sig-name descname"><span class="pre">isprintable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isprintable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is printable, False otherwise.</p>
<p>A string is printable if all of its characters are considered printable in
repr() or if it is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isspace">
<span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isspace" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a whitespace string, False otherwise.</p>
<p>A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.istitle">
<span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.istitle" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is a title-cased string, False otherwise.</p>
<p>In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.isupper">
<span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.isupper" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the string is an uppercase string, False otherwise.</p>
<p>A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.join" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate any number of strings.</p>
<p>The string whose method is called is inserted in between each given string.
The result is returned as a new string.</p>
<p>Example: ‘.’.join([‘ab’, ‘pq’, ‘rs’]) -&gt; ‘ab.pq.rs’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.ljust">
<span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.ljust" title="Permalink to this definition"></a></dt>
<dd><p>Return a left-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.lower">
<span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.lower" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to lowercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.lstrip">
<span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.lstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.maketrans" title="Permalink to this definition"></a></dt>
<dd><p>Return a translation table usable for str.translate().</p>
<p>If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y. If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.partition">
<span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.partition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.removeprefix">
<span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.removeprefix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given prefix string removed if present.</p>
<p>If the string starts with the prefix string, return string[len(prefix):].
Otherwise, return a copy of the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.removesuffix">
<span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.removesuffix" title="Permalink to this definition"></a></dt>
<dd><p>Return a str with the given suffix string removed if present.</p>
<p>If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.replace" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy with all occurrences of substring old replaced by new.</p>
<blockquote>
<div><dl class="simple">
<dt>count</dt><dd><p>Maximum number of occurrences to replace.
-1 (the default value) means replace all occurrences.</p>
</dd>
</dl>
</div></blockquote>
<p>If the optional argument count is given, only the first count occurrences are
replaced.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rfind">
<span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.token.rfind" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rindex">
<span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lxml.html.diff.token.rindex" title="Permalink to this definition"></a></dt>
<dd><p>Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Raises ValueError when the substring is not found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rjust">
<span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.rjust" title="Permalink to this definition"></a></dt>
<dd><p>Return a right-justified string of length width.</p>
<p>Padding is done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rpartition">
<span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.rpartition" title="Permalink to this definition"></a></dt>
<dd><p>Partition the string into three parts using the given separator.</p>
<p>This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.</p>
<p>If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rsplit">
<span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.rsplit" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<blockquote>
<div><dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</div></blockquote>
<p>Splits are done starting at the end of the string and working to the front.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.rstrip">
<span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.rstrip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.split" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the words in the string, using sep as the delimiter string.</p>
<dl class="simple">
<dt>sep</dt><dd><p>The delimiter according which to split the string.
None (the default value) means split according to any whitespace,
and discard empty strings from the result.</p>
</dd>
<dt>maxsplit</dt><dd><p>Maximum number of splits to do.
-1 (the default value) means no limit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.splitlines">
<span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.splitlines" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the lines in the string, breaking at line boundaries.</p>
<p>Line breaks are not included in the resulting list unless keepends is given and
true.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.startswith">
<span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#lxml.html.diff.token.startswith" title="Permalink to this definition"></a></dt>
<dd><p>Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.strip">
<span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.strip" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string with leading and trailing whitespace removed.</p>
<p>If chars is given and not None, remove characters in chars instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.swapcase">
<span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.swapcase" title="Permalink to this definition"></a></dt>
<dd><p>Convert uppercase characters to lowercase and lowercase characters to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.title">
<span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.title" title="Permalink to this definition"></a></dt>
<dd><p>Return a version of the string where each word is titlecased.</p>
<p>More specifically, words start with uppercased characters and all remaining
cased characters have lower case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.translate" title="Permalink to this definition"></a></dt>
<dd><p>Replace each character in the string using the given translation table.</p>
<blockquote>
<div><dl class="simple">
<dt>table</dt><dd><p>Translation table, which must be a mapping of Unicode ordinals to
Unicode ordinals, strings, or None.</p>
</dd>
</dl>
</div></blockquote>
<p>The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.upper">
<span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.upper" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the string converted to uppercase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lxml.html.diff.token.zfill">
<span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.token.zfill" title="Permalink to this definition"></a></dt>
<dd><p>Pad a numeric string with zeros on the left, to fill a field of the given width.</p>
<p>The string is never truncated.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lxml.html.diff.token.hide_when_equal">
<span class="sig-name descname"><span class="pre">hide_when_equal</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#lxml.html.diff.token.hide_when_equal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff._contains_block_level_tag">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">_contains_block_level_tag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff._contains_block_level_tag" title="Permalink to this definition"></a></dt>
<dd><p>True if the element contains any block-level elements, like &lt;p&gt;, &lt;td&gt;, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff._fixup_ins_del_tags">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">_fixup_ins_del_tags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff._fixup_ins_del_tags" title="Permalink to this definition"></a></dt>
<dd><p>fixup_ins_del_tags that works on an lxml document in-place</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff._merge_element_contents">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">_merge_element_contents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff._merge_element_contents" title="Permalink to this definition"></a></dt>
<dd><p>Removes an element, but merges its contents into its place, e.g.,
given &lt;p&gt;Hi &lt;i&gt;there!&lt;/i&gt;&lt;/p&gt;, if you remove the &lt;i&gt; element you get
&lt;p&gt;Hi there!&lt;/p&gt;</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff._move_el_inside_block">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">_move_el_inside_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff._move_el_inside_block" title="Permalink to this definition"></a></dt>
<dd><p>helper for _fixup_ins_del_tags; actually takes the &lt;ins&gt; etc tags
and moves them inside any block-level tags.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.cleanup_delete">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">cleanup_delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.cleanup_delete" title="Permalink to this definition"></a></dt>
<dd><p>Cleans up any DEL_START/DEL_END markers in the document, replacing
them with &lt;del&gt;&lt;/del&gt;.  To do this while keeping the document
valid, it may need to drop some tags (either start or end tags).</p>
<p>It may also move the del into adjacent tags to try to move it to a
similar location where it was originally located (e.g., moving a
delete into preceding &lt;div&gt; tag, if the del looks like (DEL_START,
‘Text&lt;/div&gt;’, DEL_END)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.cleanup_html">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">cleanup_html</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">html</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.cleanup_html" title="Permalink to this definition"></a></dt>
<dd><p>This ‘cleans’ the HTML, meaning that any page structure is removed
(only the contents of &lt;body&gt; are used, if there is any &lt;body).
Also &lt;ins&gt; and &lt;del&gt; tags are removed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.compress_merge_back">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">compress_merge_back</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tok</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.compress_merge_back" title="Permalink to this definition"></a></dt>
<dd><p>Merge tok into the last element of tokens (modifying the list of
tokens in-place).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.compress_tokens">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">compress_tokens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.compress_tokens" title="Permalink to this definition"></a></dt>
<dd><p>Combine adjacent tokens when there is no HTML between the tokens, 
and they share an annotation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.copy_annotations">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">copy_annotations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.copy_annotations" title="Permalink to this definition"></a></dt>
<dd><p>Copy annotations from the tokens listed in src to the tokens in dest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.default_markup">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">default_markup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.default_markup" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.end_tag">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">end_tag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.end_tag" title="Permalink to this definition"></a></dt>
<dd><p>The text representation of an end tag for a tag.  Includes
trailing whitespace when appropriate.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.expand_tokens">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">expand_tokens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.expand_tokens" title="Permalink to this definition"></a></dt>
<dd><p>Given a list of tokens, return a generator of the chunks of
text for the data in the tokens.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.fixup_chunks">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">fixup_chunks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.fixup_chunks" title="Permalink to this definition"></a></dt>
<dd><p>This function takes a list of chunks and produces a list of tokens.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.fixup_ins_del_tags">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">fixup_ins_del_tags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">html</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.fixup_ins_del_tags" title="Permalink to this definition"></a></dt>
<dd><p>Given an html string, move any &lt;ins&gt; or &lt;del&gt; tags inside of any
block-level elements, e.g. transform &lt;ins&gt;&lt;p&gt;word&lt;/p&gt;&lt;/ins&gt; to
&lt;p&gt;&lt;ins&gt;word&lt;/ins&gt;&lt;/p&gt;</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.flatten_el">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">flatten_el</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_hrefs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.flatten_el" title="Permalink to this definition"></a></dt>
<dd><p>Takes an lxml element el, and generates all the text chunks for
that tag.  Each start tag is a chunk, each word is a chunk, and each
end tag is a chunk.</p>
<p>If skip_tag is true, then the outermost container tag is
not returned (just its contents).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.html_annotate">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">html_annotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doclist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markup=&lt;cyfunction</span> <span class="pre">default_markup&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.html_annotate" title="Permalink to this definition"></a></dt>
<dd><p>doclist should be ordered from oldest to newest, like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">version1</span> <span class="o">=</span> <span class="s1">&#39;Hello World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">version2</span> <span class="o">=</span> <span class="s1">&#39;Goodbye World&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">html_annotate</span><span class="p">([(</span><span class="n">version1</span><span class="p">,</span> <span class="s1">&#39;version 1&#39;</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="p">(</span><span class="n">version2</span><span class="p">,</span> <span class="s1">&#39;version 2&#39;</span><span class="p">)]))</span>
<span class="go">&lt;span title=&quot;version 2&quot;&gt;Goodbye&lt;/span&gt; &lt;span title=&quot;version 1&quot;&gt;World&lt;/span&gt;</span>
</pre></div>
</div>
<p>The documents must be <em>fragments</em> (str/UTF8 or unicode), not
complete documents</p>
<p>The markup argument is a function to markup the spans of words.
This function is called like markup(‘Hello’, ‘version 2’), and
returns HTML.  The first argument is text and never includes any
markup.  The default uses a span with a title:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">default_markup</span><span class="p">(</span><span class="s1">&#39;Some Text&#39;</span><span class="p">,</span> <span class="s1">&#39;by Joe&#39;</span><span class="p">))</span>
<span class="go">&lt;span title=&quot;by Joe&quot;&gt;Some Text&lt;/span&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.html_annotate_merge_annotations">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">html_annotate_merge_annotations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens_old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tokens_new</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.html_annotate_merge_annotations" title="Permalink to this definition"></a></dt>
<dd><p>Merge the annotations from tokens_old into tokens_new, when the
tokens in the new document already existed in the old document.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.htmldiff">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">htmldiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_html</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_html</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.htmldiff" title="Permalink to this definition"></a></dt>
<dd><p>Do a diff of the old and new document.  The documents are HTML
<em>fragments</em> (str/UTF8 or unicode), they are not complete documents
(i.e., no &lt;html&gt; tag).</p>
<p>Returns HTML with &lt;ins&gt; and &lt;del&gt; tags added around the
appropriate text.</p>
<p>Markup is generally ignored, with the markup from new_html
preserved, and possibly some markup from old_html (though it is
considered acceptable to lose some of the old markup).  Only the
words in the HTML are diffed.  The exception is &lt;img&gt; tags, which
are treated like words, and the href attribute of &lt;a&gt; tags, which
are noted inside the tag itself when there are changes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.htmldiff_tokens">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">htmldiff_tokens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">html1_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">html2_tokens</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.htmldiff_tokens" title="Permalink to this definition"></a></dt>
<dd><p>Does a diff on the tokens themselves, returning a list of text
chunks (not tokens).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.is_end_tag">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">is_end_tag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tok</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.is_end_tag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.is_start_tag">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">is_start_tag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tok</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.is_start_tag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.is_word">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">is_word</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tok</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.is_word" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.locate_unbalanced_end">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">locate_unbalanced_end</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unbalanced_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_delete</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_delete</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.locate_unbalanced_end" title="Permalink to this definition"></a></dt>
<dd><p>like locate_unbalanced_start, except handling end tags and
possibly moving the point earlier in the document.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.locate_unbalanced_start">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">locate_unbalanced_start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unbalanced_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_delete</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_delete</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.locate_unbalanced_start" title="Permalink to this definition"></a></dt>
<dd><p>pre_delete and post_delete implicitly point to a place in the
document (where the two were split).  This moves that point (by
popping items from one and pushing them onto the other).  It moves
the point to try to find a place where unbalanced_start applies.</p>
<p>As an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unbalanced_start</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doc</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;More Text&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;/div&gt;&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">doc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span>
<span class="go">([&#39;&lt;p&gt;&#39;, &#39;Text&#39;, &#39;&lt;/p&gt;&#39;], [&#39;&lt;div&gt;&#39;, &#39;More Text&#39;, &#39;&lt;/div&gt;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locate_unbalanced_start</span><span class="p">(</span><span class="n">unbalanced_start</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span>
<span class="go">([&#39;&lt;p&gt;&#39;, &#39;Text&#39;, &#39;&lt;/p&gt;&#39;, &#39;&lt;div&gt;&#39;], [&#39;More Text&#39;, &#39;&lt;/div&gt;&#39;])</span>
</pre></div>
</div>
<p>As you can see, we moved the point so that the dangling &lt;div&gt; that
we found will be effectively replaced by the div in the original
document.  If this doesn’t work out, we just throw away
unbalanced_start without doing anything.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.markup_serialize_tokens">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">markup_serialize_tokens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markup_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.markup_serialize_tokens" title="Permalink to this definition"></a></dt>
<dd><p>Serialize the list of tokens into a list of text chunks, calling
markup_func around text to add annotations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.merge_delete">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">merge_delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">del_chunks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.merge_delete" title="Permalink to this definition"></a></dt>
<dd><p>Adds the text chunks in del_chunks to the document doc (another
list of text chunks) with marker to show it is a delete.
cleanup_delete later resolves these markers into &lt;del&gt; tags.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.merge_insert">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">merge_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ins_chunks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.merge_insert" title="Permalink to this definition"></a></dt>
<dd><p>doc is the already-handled document (as a list of text chunks);
here we add &lt;ins&gt;ins_chunks&lt;/ins&gt; to the end of that.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.parse_html">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">parse_html</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">html</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cleanup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.parse_html" title="Permalink to this definition"></a></dt>
<dd><p>Parses an HTML fragment, returning an lxml element.  Note that the HTML will be
wrapped in a &lt;div&gt; tag that was not in the original document.</p>
<p>If cleanup is true, make sure there’s no &lt;head&gt; or &lt;body&gt;, and get
rid of any &lt;ins&gt; and &lt;del&gt; tags.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.serialize_html_fragment">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">serialize_html_fragment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_outer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.serialize_html_fragment" title="Permalink to this definition"></a></dt>
<dd><p>Serialize a single lxml element as HTML.  The serialized form
includes the elements tail.</p>
<p>If skip_outer is true, then don’t serialize the outermost tag</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.split_delete">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">split_delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.split_delete" title="Permalink to this definition"></a></dt>
<dd><p>Returns (stuff_before_DEL_START, stuff_inside_DEL_START_END,
stuff_after_DEL_END).  Returns the first case found (there may be
more DEL_STARTs in stuff_after_DEL_END).  Raises NoDeletes if
there’s no DEL_START found.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.split_trailing_whitespace">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">split_trailing_whitespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.split_trailing_whitespace" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>This function takes a word, such as ‘test</p>
</div></blockquote>
<p>‘ and returns (‘test’,’</p>
<p>‘)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.split_unbalanced">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">split_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.split_unbalanced" title="Permalink to this definition"></a></dt>
<dd><p>Return (unbalanced_start, balanced, unbalanced_end), where each is
a list of text and tag chunks.</p>
<p>unbalanced_start is a list of all the tags that are opened, but
not closed in this span.  Similarly, unbalanced_end is a list of
tags that are closed but were not opened.  Extracting these might
mean some reordering of the chunks.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.split_words">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">split_words</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.split_words" title="Permalink to this definition"></a></dt>
<dd><p>Splits some text into words. Includes trailing whitespace
on each word when appropriate.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.start_tag">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">start_tag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.start_tag" title="Permalink to this definition"></a></dt>
<dd><p>The text representation of the start tag for a tag.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.tokenize">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">tokenize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">html</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_hrefs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tokenize" title="Permalink to this definition"></a></dt>
<dd><p>Parse the given HTML and returns token objects (words with attached tags).</p>
<p>This parses only the content of a page; anything in the head is
ignored, and the &lt;head&gt; and &lt;body&gt; elements are themselves
optional.  The content is then parsed by lxml, which ensures the
validity of the resulting parsed document (though lxml may make
incorrect guesses when the markup is particular bad).</p>
<p>&lt;ins&gt; and &lt;del&gt; tags are also eliminated from the document, as
that gets confusing.</p>
<p>If include_hrefs is true, then the href attribute of &lt;a&gt; tags is
included as a special kind of diffable token.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lxml.html.diff.tokenize_annotated">
<span class="sig-prename descclassname"><span class="pre">lxml.html.diff.</span></span><span class="sig-name descname"><span class="pre">tokenize_annotated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lxml.html.diff.tokenize_annotated" title="Permalink to this definition"></a></dt>
<dd><p>Tokenize a document and add an annotation attribute to each token</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lxml.html.defs.html" class="btn btn-neutral float-left" title="lxml.html.defs module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lxml.html.formfill.html" class="btn btn-neutral float-right" title="lxml.html.formfill module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, lxml dev team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>