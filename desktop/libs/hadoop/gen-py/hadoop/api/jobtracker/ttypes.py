#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import hadoop.api.common.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ThriftTaskType(object):
  MAP = 0
  REDUCE = 1
  JOB_SETUP = 2
  JOB_CLEANUP = 3
  TASK_CLEANUP = 4

  _VALUES_TO_NAMES = {
    0: "MAP",
    1: "REDUCE",
    2: "JOB_SETUP",
    3: "JOB_CLEANUP",
    4: "TASK_CLEANUP",
  }

  _NAMES_TO_VALUES = {
    "MAP": 0,
    "REDUCE": 1,
    "JOB_SETUP": 2,
    "JOB_CLEANUP": 3,
    "TASK_CLEANUP": 4,
  }

class ThriftTaskState(object):
  RUNNING = 0
  SUCCEEDED = 1
  FAILED = 2
  UNASSIGNED = 3
  KILLED = 4
  COMMIT_PENDING = 5
  FAILED_UNCLEAN = 6
  KILLED_UNCLEAN = 7

  _VALUES_TO_NAMES = {
    0: "RUNNING",
    1: "SUCCEEDED",
    2: "FAILED",
    3: "UNASSIGNED",
    4: "KILLED",
    5: "COMMIT_PENDING",
    6: "FAILED_UNCLEAN",
    7: "KILLED_UNCLEAN",
  }

  _NAMES_TO_VALUES = {
    "RUNNING": 0,
    "SUCCEEDED": 1,
    "FAILED": 2,
    "UNASSIGNED": 3,
    "KILLED": 4,
    "COMMIT_PENDING": 5,
    "FAILED_UNCLEAN": 6,
    "KILLED_UNCLEAN": 7,
  }

class ThriftTaskPhase(object):
  STARTING = 0
  MAP = 1
  SHUFFLE = 2
  SORT = 3
  REDUCE = 4
  CLEANUP = 5

  _VALUES_TO_NAMES = {
    0: "STARTING",
    1: "MAP",
    2: "SHUFFLE",
    3: "SORT",
    4: "REDUCE",
    5: "CLEANUP",
  }

  _NAMES_TO_VALUES = {
    "STARTING": 0,
    "MAP": 1,
    "SHUFFLE": 2,
    "SORT": 3,
    "REDUCE": 4,
    "CLEANUP": 5,
  }

class ThriftTaskQueryState(object):
  """
  It corresponds to the (inferred) internal state of a TaskInProgress,
  and not that of a TaskStatus.
  """
  SUCCEEDED = 0
  FAILED = 1
  RUNNING = 2
  PENDING = 3
  KILLED = 4

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    1: "FAILED",
    2: "RUNNING",
    3: "PENDING",
    4: "KILLED",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "FAILED": 1,
    "RUNNING": 2,
    "PENDING": 3,
    "KILLED": 4,
  }

class ThriftJobPriority(object):
  """
  Possible job priorities (see ThriftJobStatus)
  """
  VERY_HIGH = 0
  HIGH = 1
  NORMAL = 2
  LOW = 3
  VERY_LOW = 4

  _VALUES_TO_NAMES = {
    0: "VERY_HIGH",
    1: "HIGH",
    2: "NORMAL",
    3: "LOW",
    4: "VERY_LOW",
  }

  _NAMES_TO_VALUES = {
    "VERY_HIGH": 0,
    "HIGH": 1,
    "NORMAL": 2,
    "LOW": 3,
    "VERY_LOW": 4,
  }

class JobTrackerState(object):
  """
  States that the jobtracker may be in
  """
  INITIALIZING = 0
  RUNNING = 1

  _VALUES_TO_NAMES = {
    0: "INITIALIZING",
    1: "RUNNING",
  }

  _NAMES_TO_VALUES = {
    "INITIALIZING": 0,
    "RUNNING": 1,
  }

class ThriftJobState(object):
  """
  Enum version of the ints in JobStatus
  """
  RUNNING = 1
  SUCCEEDED = 2
  FAILED = 3
  PREP = 4
  KILLED = 5

  _VALUES_TO_NAMES = {
    1: "RUNNING",
    2: "SUCCEEDED",
    3: "FAILED",
    4: "PREP",
    5: "KILLED",
  }

  _NAMES_TO_VALUES = {
    "RUNNING": 1,
    "SUCCEEDED": 2,
    "FAILED": 3,
    "PREP": 4,
    "KILLED": 5,
  }


class ThriftJobID(object):
  """
  Unique identifier for each job

  Attributes:
   - jobTrackerID: Unique id of jobtracker
   - jobID: Unique (to JT) job id
   - asString: Flattened as a string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobTrackerID', None, None, ), # 1
    (2, TType.I32, 'jobID', None, None, ), # 2
    (3, TType.STRING, 'asString', None, None, ), # 3
  )

  def __init__(self, jobTrackerID=None, jobID=None, asString=None,):
    self.jobTrackerID = jobTrackerID
    self.jobID = jobID
    self.asString = asString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobTrackerID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.jobID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.asString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobID')
    if self.jobTrackerID is not None:
      oprot.writeFieldBegin('jobTrackerID', TType.STRING, 1)
      oprot.writeString(self.jobTrackerID)
      oprot.writeFieldEnd()
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.I32, 2)
      oprot.writeI32(self.jobID)
      oprot.writeFieldEnd()
    if self.asString is not None:
      oprot.writeFieldBegin('asString', TType.STRING, 3)
      oprot.writeString(self.asString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobQueueInfo(object):
  """
  Description of a job queue

  Attributes:
   - queueName
   - schedulingInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'schedulingInfo', None, None, ), # 2
  )

  def __init__(self, queueName=None, schedulingInfo=None,):
    self.queueName = queueName
    self.schedulingInfo = schedulingInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.schedulingInfo = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobQueueInfo')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.schedulingInfo is not None:
      oprot.writeFieldBegin('schedulingInfo', TType.STRING, 2)
      oprot.writeString(self.schedulingInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobQueueList(object):
  """
  Attributes:
   - queues
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'queues', (TType.STRUCT,(ThriftJobQueueInfo, ThriftJobQueueInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, queues=None,):
    self.queues = queues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.queues = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ThriftJobQueueInfo()
            _elem5.read(iprot)
            self.queues.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobQueueList')
    if self.queues is not None:
      oprot.writeFieldBegin('queues', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.queues))
      for iter6 in self.queues:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftCounter(object):
  """
  Counter which represents some custom job metric

  Attributes:
   - name
   - displayName
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'displayName', None, None, ), # 2
    (3, TType.I64, 'value', None, None, ), # 3
  )

  def __init__(self, name=None, displayName=None, value=None,):
    self.name = name
    self.displayName = displayName
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftCounter')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 2)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 3)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftCounterGroup(object):
  """
  Counters are organized by group

  Attributes:
   - name
   - displayName
   - counters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'displayName', None, None, ), # 2
    (3, TType.MAP, 'counters', (TType.STRING,None,TType.STRUCT,(ThriftCounter, ThriftCounter.thrift_spec)), None, ), # 3
  )

  def __init__(self, name=None, displayName=None, counters=None,):
    self.name = name
    self.displayName = displayName
    self.counters = counters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.counters = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = ThriftCounter()
            _val13.read(iprot)
            self.counters[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftCounterGroup')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 2)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.counters is not None:
      oprot.writeFieldBegin('counters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.counters))
      for kiter14,viter15 in self.counters.items():
        oprot.writeString(kiter14)
        viter15.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftGroupList(object):
  """
  Container structure for counter groups

  Attributes:
   - groups
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'groups', (TType.STRUCT,(ThriftCounterGroup, ThriftCounterGroup.thrift_spec)), None, ), # 1
  )

  def __init__(self, groups=None,):
    self.groups = groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.groups = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = ThriftCounterGroup()
            _elem21.read(iprot)
            self.groups.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftGroupList')
    if self.groups is not None:
      oprot.writeFieldBegin('groups', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.groups))
      for iter22 in self.groups:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobCounterRollups(object):
  """
  Counters for map tasks only, reduce tasks only, and job-scoped counters

  Attributes:
   - mapCounters
   - reduceCounters
   - jobCounters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mapCounters', (ThriftGroupList, ThriftGroupList.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'reduceCounters', (ThriftGroupList, ThriftGroupList.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'jobCounters', (ThriftGroupList, ThriftGroupList.thrift_spec), None, ), # 3
  )

  def __init__(self, mapCounters=None, reduceCounters=None, jobCounters=None,):
    self.mapCounters = mapCounters
    self.reduceCounters = reduceCounters
    self.jobCounters = jobCounters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mapCounters = ThriftGroupList()
          self.mapCounters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reduceCounters = ThriftGroupList()
          self.reduceCounters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jobCounters = ThriftGroupList()
          self.jobCounters.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobCounterRollups')
    if self.mapCounters is not None:
      oprot.writeFieldBegin('mapCounters', TType.STRUCT, 1)
      self.mapCounters.write(oprot)
      oprot.writeFieldEnd()
    if self.reduceCounters is not None:
      oprot.writeFieldBegin('reduceCounters', TType.STRUCT, 2)
      self.reduceCounters.write(oprot)
      oprot.writeFieldEnd()
    if self.jobCounters is not None:
      oprot.writeFieldBegin('jobCounters', TType.STRUCT, 3)
      self.jobCounters.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskID(object):
  """
  Unique task id

  Attributes:
   - jobID: ID of the job to which the task belongs
   - taskType: What kind of task is this?
   - taskID: Unique (to job) task id
   - asString: Flattened to a unique string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobID', (ThriftJobID, ThriftJobID.thrift_spec), None, ), # 1
    (2, TType.I32, 'taskType', None, None, ), # 2
    (3, TType.I32, 'taskID', None, None, ), # 3
    (4, TType.STRING, 'asString', None, None, ), # 4
  )

  def __init__(self, jobID=None, taskType=None, taskID=None, asString=None,):
    self.jobID = jobID
    self.taskType = taskType
    self.taskID = taskID
    self.asString = asString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobID = ThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.taskType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.taskID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.asString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskID')
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 1)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.taskType is not None:
      oprot.writeFieldBegin('taskType', TType.I32, 2)
      oprot.writeI32(self.taskType)
      oprot.writeFieldEnd()
    if self.taskID is not None:
      oprot.writeFieldBegin('taskID', TType.I32, 3)
      oprot.writeI32(self.taskID)
      oprot.writeFieldEnd()
    if self.asString is not None:
      oprot.writeFieldBegin('asString', TType.STRING, 4)
      oprot.writeString(self.asString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskAttemptID(object):
  """
  Unique task attempt id

  Attributes:
   - taskID
   - attemptID
   - asString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'taskID', (ThriftTaskID, ThriftTaskID.thrift_spec), None, ), # 1
    (2, TType.I32, 'attemptID', None, None, ), # 2
    (3, TType.STRING, 'asString', None, None, ), # 3
  )

  def __init__(self, taskID=None, attemptID=None, asString=None,):
    self.taskID = taskID
    self.attemptID = attemptID
    self.asString = asString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.taskID = ThriftTaskID()
          self.taskID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.attemptID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.asString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskAttemptID')
    if self.taskID is not None:
      oprot.writeFieldBegin('taskID', TType.STRUCT, 1)
      self.taskID.write(oprot)
      oprot.writeFieldEnd()
    if self.attemptID is not None:
      oprot.writeFieldBegin('attemptID', TType.I32, 2)
      oprot.writeI32(self.attemptID)
      oprot.writeFieldEnd()
    if self.asString is not None:
      oprot.writeFieldBegin('asString', TType.STRING, 3)
      oprot.writeString(self.asString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskStatus(object):
  """
  Describes the current state of a single attempt

  Attributes:
   - taskID
   - progress
   - state
   - diagnosticInfo
   - stateString
   - taskTracker
   - startTime
   - finishTime
   - outputSize
   - phase
   - counters
   - shuffleFinishTime
   - sortFinishTime
   - mapFinishTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'taskID', (ThriftTaskAttemptID, ThriftTaskAttemptID.thrift_spec), None, ), # 1
    (2, TType.DOUBLE, 'progress', None, None, ), # 2
    (3, TType.I32, 'state', None, None, ), # 3
    (4, TType.STRING, 'diagnosticInfo', None, None, ), # 4
    (5, TType.STRING, 'stateString', None, None, ), # 5
    (6, TType.STRING, 'taskTracker', None, None, ), # 6
    (7, TType.I64, 'startTime', None, None, ), # 7
    (8, TType.I64, 'finishTime', None, None, ), # 8
    (9, TType.I64, 'outputSize', None, None, ), # 9
    (10, TType.I32, 'phase', None, None, ), # 10
    (11, TType.STRUCT, 'counters', (ThriftGroupList, ThriftGroupList.thrift_spec), None, ), # 11
    (12, TType.I64, 'shuffleFinishTime', None, None, ), # 12
    (13, TType.I64, 'sortFinishTime', None, None, ), # 13
    (14, TType.I64, 'mapFinishTime', None, None, ), # 14
  )

  def __init__(self, taskID=None, progress=None, state=None, diagnosticInfo=None, stateString=None, taskTracker=None, startTime=None, finishTime=None, outputSize=None, phase=None, counters=None, shuffleFinishTime=None, sortFinishTime=None, mapFinishTime=None,):
    self.taskID = taskID
    self.progress = progress
    self.state = state
    self.diagnosticInfo = diagnosticInfo
    self.stateString = stateString
    self.taskTracker = taskTracker
    self.startTime = startTime
    self.finishTime = finishTime
    self.outputSize = outputSize
    self.phase = phase
    self.counters = counters
    self.shuffleFinishTime = shuffleFinishTime
    self.sortFinishTime = sortFinishTime
    self.mapFinishTime = mapFinishTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.taskID = ThriftTaskAttemptID()
          self.taskID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.progress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.diagnosticInfo = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.stateString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.taskTracker = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.finishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.outputSize = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.phase = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.counters = ThriftGroupList()
          self.counters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.shuffleFinishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.sortFinishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.mapFinishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskStatus')
    if self.taskID is not None:
      oprot.writeFieldBegin('taskID', TType.STRUCT, 1)
      self.taskID.write(oprot)
      oprot.writeFieldEnd()
    if self.progress is not None:
      oprot.writeFieldBegin('progress', TType.DOUBLE, 2)
      oprot.writeDouble(self.progress)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 3)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.diagnosticInfo is not None:
      oprot.writeFieldBegin('diagnosticInfo', TType.STRING, 4)
      oprot.writeString(self.diagnosticInfo)
      oprot.writeFieldEnd()
    if self.stateString is not None:
      oprot.writeFieldBegin('stateString', TType.STRING, 5)
      oprot.writeString(self.stateString)
      oprot.writeFieldEnd()
    if self.taskTracker is not None:
      oprot.writeFieldBegin('taskTracker', TType.STRING, 6)
      oprot.writeString(self.taskTracker)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 7)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.finishTime is not None:
      oprot.writeFieldBegin('finishTime', TType.I64, 8)
      oprot.writeI64(self.finishTime)
      oprot.writeFieldEnd()
    if self.outputSize is not None:
      oprot.writeFieldBegin('outputSize', TType.I64, 9)
      oprot.writeI64(self.outputSize)
      oprot.writeFieldEnd()
    if self.phase is not None:
      oprot.writeFieldBegin('phase', TType.I32, 10)
      oprot.writeI32(self.phase)
      oprot.writeFieldEnd()
    if self.counters is not None:
      oprot.writeFieldBegin('counters', TType.STRUCT, 11)
      self.counters.write(oprot)
      oprot.writeFieldEnd()
    if self.shuffleFinishTime is not None:
      oprot.writeFieldBegin('shuffleFinishTime', TType.I64, 12)
      oprot.writeI64(self.shuffleFinishTime)
      oprot.writeFieldEnd()
    if self.sortFinishTime is not None:
      oprot.writeFieldBegin('sortFinishTime', TType.I64, 13)
      oprot.writeI64(self.sortFinishTime)
      oprot.writeFieldEnd()
    if self.mapFinishTime is not None:
      oprot.writeFieldBegin('mapFinishTime', TType.I64, 14)
      oprot.writeI64(self.mapFinishTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskInProgress(object):
  """
  A ThriftTaskInProgress contains a list of
  task attempts (speculatively executed instances of the same task).
  These are indexed by TaskAttemptID.
  For simplicity, we convert maps keyed on TaskAttemptIDs to maps keyed
  on their string representation.

  Assumption: there won't be so many task attempts that retrieving a single task
  will be too expensive.

  Attributes:
   - execStartTime
   - execFinishTime
   - progress
   - startTime
   - failed
   - complete
   - taskID
   - tasks
   - taskStatuses: TaskAttemptID (string) to ThriftTaskStatus map
   - taskDiagnosticData
   - counters
   - mostRecentState
   - runningAttempts
   - successfulAttempt
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I64, 'execStartTime', None, None, ), # 2
    (3, TType.I64, 'execFinishTime', None, None, ), # 3
    (4, TType.DOUBLE, 'progress', None, None, ), # 4
    (5, TType.I64, 'startTime', None, None, ), # 5
    (6, TType.BOOL, 'failed', None, None, ), # 6
    (7, TType.BOOL, 'complete', None, None, ), # 7
    (8, TType.STRUCT, 'taskID', (ThriftTaskID, ThriftTaskID.thrift_spec), None, ), # 8
    (9, TType.LIST, 'tasks', (TType.STRUCT,(ThriftTaskAttemptID, ThriftTaskAttemptID.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'taskStatuses', (TType.STRING,None,TType.STRUCT,(ThriftTaskStatus, ThriftTaskStatus.thrift_spec)), None, ), # 10
    (11, TType.MAP, 'taskDiagnosticData', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 11
    (12, TType.STRUCT, 'counters', (ThriftGroupList, ThriftGroupList.thrift_spec), None, ), # 12
    (13, TType.STRING, 'mostRecentState', None, None, ), # 13
    (14, TType.LIST, 'runningAttempts', (TType.STRING,None), None, ), # 14
    (15, TType.STRING, 'successfulAttempt', None, None, ), # 15
  )

  def __init__(self, execStartTime=None, execFinishTime=None, progress=None, startTime=None, failed=None, complete=None, taskID=None, tasks=None, taskStatuses=None, taskDiagnosticData=None, counters=None, mostRecentState=None, runningAttempts=None, successfulAttempt=None,):
    self.execStartTime = execStartTime
    self.execFinishTime = execFinishTime
    self.progress = progress
    self.startTime = startTime
    self.failed = failed
    self.complete = complete
    self.taskID = taskID
    self.tasks = tasks
    self.taskStatuses = taskStatuses
    self.taskDiagnosticData = taskDiagnosticData
    self.counters = counters
    self.mostRecentState = mostRecentState
    self.runningAttempts = runningAttempts
    self.successfulAttempt = successfulAttempt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I64:
          self.execStartTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.execFinishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.progress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.failed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.complete = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.taskID = ThriftTaskID()
          self.taskID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = ThriftTaskAttemptID()
            _elem28.read(iprot)
            self.tasks.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.taskStatuses = {}
          (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
          for _i33 in xrange(_size29):
            _key34 = iprot.readString();
            _val35 = ThriftTaskStatus()
            _val35.read(iprot)
            self.taskStatuses[_key34] = _val35
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.taskDiagnosticData = {}
          (_ktype37, _vtype38, _size36 ) = iprot.readMapBegin() 
          for _i40 in xrange(_size36):
            _key41 = iprot.readString();
            _val42 = []
            (_etype46, _size43) = iprot.readListBegin()
            for _i47 in xrange(_size43):
              _elem48 = iprot.readString();
              _val42.append(_elem48)
            iprot.readListEnd()
            self.taskDiagnosticData[_key41] = _val42
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.counters = ThriftGroupList()
          self.counters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.mostRecentState = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.runningAttempts = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readString();
            self.runningAttempts.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.successfulAttempt = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskInProgress')
    if self.execStartTime is not None:
      oprot.writeFieldBegin('execStartTime', TType.I64, 2)
      oprot.writeI64(self.execStartTime)
      oprot.writeFieldEnd()
    if self.execFinishTime is not None:
      oprot.writeFieldBegin('execFinishTime', TType.I64, 3)
      oprot.writeI64(self.execFinishTime)
      oprot.writeFieldEnd()
    if self.progress is not None:
      oprot.writeFieldBegin('progress', TType.DOUBLE, 4)
      oprot.writeDouble(self.progress)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 5)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.BOOL, 6)
      oprot.writeBool(self.failed)
      oprot.writeFieldEnd()
    if self.complete is not None:
      oprot.writeFieldBegin('complete', TType.BOOL, 7)
      oprot.writeBool(self.complete)
      oprot.writeFieldEnd()
    if self.taskID is not None:
      oprot.writeFieldBegin('taskID', TType.STRUCT, 8)
      self.taskID.write(oprot)
      oprot.writeFieldEnd()
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter55 in self.tasks:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taskStatuses is not None:
      oprot.writeFieldBegin('taskStatuses', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.taskStatuses))
      for kiter56,viter57 in self.taskStatuses.items():
        oprot.writeString(kiter56)
        viter57.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.taskDiagnosticData is not None:
      oprot.writeFieldBegin('taskDiagnosticData', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.taskDiagnosticData))
      for kiter58,viter59 in self.taskDiagnosticData.items():
        oprot.writeString(kiter58)
        oprot.writeListBegin(TType.STRING, len(viter59))
        for iter60 in viter59:
          oprot.writeString(iter60)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.counters is not None:
      oprot.writeFieldBegin('counters', TType.STRUCT, 12)
      self.counters.write(oprot)
      oprot.writeFieldEnd()
    if self.mostRecentState is not None:
      oprot.writeFieldBegin('mostRecentState', TType.STRING, 13)
      oprot.writeString(self.mostRecentState)
      oprot.writeFieldEnd()
    if self.runningAttempts is not None:
      oprot.writeFieldBegin('runningAttempts', TType.LIST, 14)
      oprot.writeListBegin(TType.STRING, len(self.runningAttempts))
      for iter61 in self.runningAttempts:
        oprot.writeString(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.successfulAttempt is not None:
      oprot.writeFieldBegin('successfulAttempt', TType.STRING, 15)
      oprot.writeString(self.successfulAttempt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskTrackerStatus(object):
  """
  TaskTracker status; contains details of individual tasks

  Attributes:
   - trackerName
   - host
   - httpPort
   - failureCount
   - taskReports: List of the state of all tasks on this tracker
   - lastSeen: When did the JobTracker last hear from this TaskTracker?
   - maxMapTasks: Maximum possible number of both task types
   - maxReduceTasks
   - totalVirtualMemory: Main memory metrics, all in bytes
   - totalPhysicalMemory
   - availableSpace
   - mapCount: Currently running and unassigned map and reduce tasks
   - reduceCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'trackerName', None, None, ), # 1
    (2, TType.STRING, 'host', None, None, ), # 2
    (3, TType.I32, 'httpPort', None, None, ), # 3
    (4, TType.I32, 'failureCount', None, None, ), # 4
    (5, TType.LIST, 'taskReports', (TType.STRUCT,(ThriftTaskStatus, ThriftTaskStatus.thrift_spec)), None, ), # 5
    (6, TType.I64, 'lastSeen', None, None, ), # 6
    (7, TType.I32, 'maxMapTasks', None, None, ), # 7
    (8, TType.I32, 'maxReduceTasks', None, None, ), # 8
    (9, TType.I64, 'totalVirtualMemory', None, None, ), # 9
    None, # 10
    (11, TType.I64, 'totalPhysicalMemory', None, None, ), # 11
    None, # 12
    (13, TType.I64, 'availableSpace', None, None, ), # 13
    (14, TType.I32, 'mapCount', None, None, ), # 14
    (15, TType.I32, 'reduceCount', None, None, ), # 15
  )

  def __init__(self, trackerName=None, host=None, httpPort=None, failureCount=None, taskReports=None, lastSeen=None, maxMapTasks=None, maxReduceTasks=None, totalVirtualMemory=None, totalPhysicalMemory=None, availableSpace=None, mapCount=None, reduceCount=None,):
    self.trackerName = trackerName
    self.host = host
    self.httpPort = httpPort
    self.failureCount = failureCount
    self.taskReports = taskReports
    self.lastSeen = lastSeen
    self.maxMapTasks = maxMapTasks
    self.maxReduceTasks = maxReduceTasks
    self.totalVirtualMemory = totalVirtualMemory
    self.totalPhysicalMemory = totalPhysicalMemory
    self.availableSpace = availableSpace
    self.mapCount = mapCount
    self.reduceCount = reduceCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.trackerName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.host = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.httpPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.failureCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.taskReports = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = ThriftTaskStatus()
            _elem67.read(iprot)
            self.taskReports.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.lastSeen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.maxMapTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.maxReduceTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.totalVirtualMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.totalPhysicalMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.availableSpace = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.mapCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          self.reduceCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskTrackerStatus')
    if self.trackerName is not None:
      oprot.writeFieldBegin('trackerName', TType.STRING, 1)
      oprot.writeString(self.trackerName)
      oprot.writeFieldEnd()
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 2)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.httpPort is not None:
      oprot.writeFieldBegin('httpPort', TType.I32, 3)
      oprot.writeI32(self.httpPort)
      oprot.writeFieldEnd()
    if self.failureCount is not None:
      oprot.writeFieldBegin('failureCount', TType.I32, 4)
      oprot.writeI32(self.failureCount)
      oprot.writeFieldEnd()
    if self.taskReports is not None:
      oprot.writeFieldBegin('taskReports', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.taskReports))
      for iter68 in self.taskReports:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lastSeen is not None:
      oprot.writeFieldBegin('lastSeen', TType.I64, 6)
      oprot.writeI64(self.lastSeen)
      oprot.writeFieldEnd()
    if self.maxMapTasks is not None:
      oprot.writeFieldBegin('maxMapTasks', TType.I32, 7)
      oprot.writeI32(self.maxMapTasks)
      oprot.writeFieldEnd()
    if self.maxReduceTasks is not None:
      oprot.writeFieldBegin('maxReduceTasks', TType.I32, 8)
      oprot.writeI32(self.maxReduceTasks)
      oprot.writeFieldEnd()
    if self.totalVirtualMemory is not None:
      oprot.writeFieldBegin('totalVirtualMemory', TType.I64, 9)
      oprot.writeI64(self.totalVirtualMemory)
      oprot.writeFieldEnd()
    if self.totalPhysicalMemory is not None:
      oprot.writeFieldBegin('totalPhysicalMemory', TType.I64, 11)
      oprot.writeI64(self.totalPhysicalMemory)
      oprot.writeFieldEnd()
    if self.availableSpace is not None:
      oprot.writeFieldBegin('availableSpace', TType.I64, 13)
      oprot.writeI64(self.availableSpace)
      oprot.writeFieldEnd()
    if self.mapCount is not None:
      oprot.writeFieldBegin('mapCount', TType.I32, 14)
      oprot.writeI32(self.mapCount)
      oprot.writeFieldEnd()
    if self.reduceCount is not None:
      oprot.writeFieldBegin('reduceCount', TType.I32, 15)
      oprot.writeI32(self.reduceCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskTrackerStatusList(object):
  """
  Container structure for TaskTrackerStatus objects

  Attributes:
   - trackers
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'trackers', (TType.STRUCT,(ThriftTaskTrackerStatus, ThriftTaskTrackerStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, trackers=None,):
    self.trackers = trackers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trackers = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = ThriftTaskTrackerStatus()
            _elem74.read(iprot)
            self.trackers.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskTrackerStatusList')
    if self.trackers is not None:
      oprot.writeFieldBegin('trackers', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.trackers))
      for iter75 in self.trackers:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobStatus(object):
  """
  Status of a job

  Attributes:
   - jobID
   - mapProgress
   - reduceProgress
   - cleanupProgress
   - setupProgress
   - runState
   - startTime
   - user
   - priority
   - schedulingInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobID', (ThriftJobID, ThriftJobID.thrift_spec), None, ), # 1
    (2, TType.DOUBLE, 'mapProgress', None, None, ), # 2
    (3, TType.DOUBLE, 'reduceProgress', None, None, ), # 3
    (4, TType.DOUBLE, 'cleanupProgress', None, None, ), # 4
    (5, TType.DOUBLE, 'setupProgress', None, None, ), # 5
    (6, TType.I32, 'runState', None, None, ), # 6
    (7, TType.I64, 'startTime', None, None, ), # 7
    (8, TType.STRING, 'user', None, None, ), # 8
    (9, TType.I32, 'priority', None, None, ), # 9
    (10, TType.STRING, 'schedulingInfo', None, None, ), # 10
  )

  def __init__(self, jobID=None, mapProgress=None, reduceProgress=None, cleanupProgress=None, setupProgress=None, runState=None, startTime=None, user=None, priority=None, schedulingInfo=None,):
    self.jobID = jobID
    self.mapProgress = mapProgress
    self.reduceProgress = reduceProgress
    self.cleanupProgress = cleanupProgress
    self.setupProgress = setupProgress
    self.runState = runState
    self.startTime = startTime
    self.user = user
    self.priority = priority
    self.schedulingInfo = schedulingInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobID = ThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.mapProgress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.reduceProgress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.cleanupProgress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.setupProgress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.runState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.schedulingInfo = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobStatus')
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 1)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.mapProgress is not None:
      oprot.writeFieldBegin('mapProgress', TType.DOUBLE, 2)
      oprot.writeDouble(self.mapProgress)
      oprot.writeFieldEnd()
    if self.reduceProgress is not None:
      oprot.writeFieldBegin('reduceProgress', TType.DOUBLE, 3)
      oprot.writeDouble(self.reduceProgress)
      oprot.writeFieldEnd()
    if self.cleanupProgress is not None:
      oprot.writeFieldBegin('cleanupProgress', TType.DOUBLE, 4)
      oprot.writeDouble(self.cleanupProgress)
      oprot.writeFieldEnd()
    if self.setupProgress is not None:
      oprot.writeFieldBegin('setupProgress', TType.DOUBLE, 5)
      oprot.writeDouble(self.setupProgress)
      oprot.writeFieldEnd()
    if self.runState is not None:
      oprot.writeFieldBegin('runState', TType.I32, 6)
      oprot.writeI32(self.runState)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 7)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 8)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 9)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.schedulingInfo is not None:
      oprot.writeFieldBegin('schedulingInfo', TType.STRING, 10)
      oprot.writeString(self.schedulingInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobProfile(object):
  """
  Job metadata

  Attributes:
   - user
   - jobID
   - jobFile
   - name
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
    (2, TType.STRUCT, 'jobID', (ThriftJobID, ThriftJobID.thrift_spec), None, ), # 2
    (3, TType.STRING, 'jobFile', None, None, ), # 3
    (4, TType.STRING, 'name', None, None, ), # 4
    (5, TType.STRING, 'queueName', None, None, ), # 5
  )

  def __init__(self, user=None, jobID=None, jobFile=None, name=None, queueName=None,):
    self.user = user
    self.jobID = jobID
    self.jobFile = jobFile
    self.name = name
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.jobID = ThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.jobFile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobProfile')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 2)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.jobFile is not None:
      oprot.writeFieldBegin('jobFile', TType.STRING, 3)
      oprot.writeString(self.jobFile)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 5)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftTaskInProgressList(object):
  """
  Container structure of a list of tasks. This list may have been put together
  according to some selection criteria. That is, it may not correspond to the
  mapTasks, or reduceTasks, etc. It may even contain tasks of different types.

  Attributes:
   - tasks: A (possibly incomplete) list of tasks
   - numTotalTasks: The total number of tasks in this full list.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tasks', (TType.STRUCT,(ThriftTaskInProgress, ThriftTaskInProgress.thrift_spec)), None, ), # 1
    (2, TType.I32, 'numTotalTasks', None, None, ), # 2
  )

  def __init__(self, tasks=None, numTotalTasks=None,):
    self.tasks = tasks
    self.numTotalTasks = numTotalTasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = ThriftTaskInProgress()
            _elem81.read(iprot)
            self.tasks.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.numTotalTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftTaskInProgressList')
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter82 in self.tasks:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.numTotalTasks is not None:
      oprot.writeFieldBegin('numTotalTasks', TType.I32, 2)
      oprot.writeI32(self.numTotalTasks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobInProgress(object):
  """
  Status of *all* jobs, not just currently running ones

  Attributes:
   - profile
   - status
   - jobID
   - desiredMaps
   - desiredReduces
   - finishedMaps
   - finishedReduces
   - priority
   - startTime
   - finishTime
   - launchTime
   - tasks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'profile', (ThriftJobProfile, ThriftJobProfile.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'status', (ThriftJobStatus, ThriftJobStatus.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'jobID', (ThriftJobID, ThriftJobID.thrift_spec), None, ), # 3
    (4, TType.I32, 'desiredMaps', None, None, ), # 4
    (5, TType.I32, 'desiredReduces', None, None, ), # 5
    (6, TType.I32, 'finishedMaps', None, None, ), # 6
    (7, TType.I32, 'finishedReduces', None, None, ), # 7
    (8, TType.I32, 'priority', None, None, ), # 8
    None, # 9
    None, # 10
    (11, TType.I64, 'startTime', None, None, ), # 11
    (12, TType.I64, 'finishTime', None, None, ), # 12
    (13, TType.I64, 'launchTime', None, None, ), # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    (23, TType.STRUCT, 'tasks', (ThriftTaskInProgressList, ThriftTaskInProgressList.thrift_spec), None, ), # 23
  )

  def __init__(self, profile=None, status=None, jobID=None, desiredMaps=None, desiredReduces=None, finishedMaps=None, finishedReduces=None, priority=None, startTime=None, finishTime=None, launchTime=None, tasks=None,):
    self.profile = profile
    self.status = status
    self.jobID = jobID
    self.desiredMaps = desiredMaps
    self.desiredReduces = desiredReduces
    self.finishedMaps = finishedMaps
    self.finishedReduces = finishedReduces
    self.priority = priority
    self.startTime = startTime
    self.finishTime = finishTime
    self.launchTime = launchTime
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.profile = ThriftJobProfile()
          self.profile.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.status = ThriftJobStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jobID = ThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.desiredMaps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.desiredReduces = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.finishedMaps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.finishedReduces = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.finishTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.launchTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.tasks = ThriftTaskInProgressList()
          self.tasks.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobInProgress')
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRUCT, 1)
      self.profile.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 2)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 3)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.desiredMaps is not None:
      oprot.writeFieldBegin('desiredMaps', TType.I32, 4)
      oprot.writeI32(self.desiredMaps)
      oprot.writeFieldEnd()
    if self.desiredReduces is not None:
      oprot.writeFieldBegin('desiredReduces', TType.I32, 5)
      oprot.writeI32(self.desiredReduces)
      oprot.writeFieldEnd()
    if self.finishedMaps is not None:
      oprot.writeFieldBegin('finishedMaps', TType.I32, 6)
      oprot.writeI32(self.finishedMaps)
      oprot.writeFieldEnd()
    if self.finishedReduces is not None:
      oprot.writeFieldBegin('finishedReduces', TType.I32, 7)
      oprot.writeI32(self.finishedReduces)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 8)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 11)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.finishTime is not None:
      oprot.writeFieldBegin('finishTime', TType.I64, 12)
      oprot.writeI64(self.finishTime)
      oprot.writeFieldEnd()
    if self.launchTime is not None:
      oprot.writeFieldBegin('launchTime', TType.I64, 13)
      oprot.writeI64(self.launchTime)
      oprot.writeFieldEnd()
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.STRUCT, 23)
      self.tasks.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftJobList(object):
  """
  Container structure of a list of jobs, in case we ever want to add metadata

  Attributes:
   - jobs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'jobs', (TType.STRUCT,(ThriftJobInProgress, ThriftJobInProgress.thrift_spec)), None, ), # 1
  )

  def __init__(self, jobs=None,):
    self.jobs = jobs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.jobs = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = ThriftJobInProgress()
            _elem88.read(iprot)
            self.jobs.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftJobList')
    if self.jobs is not None:
      oprot.writeFieldBegin('jobs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.jobs))
      for iter89 in self.jobs:
        iter89.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftUserJobCounts(object):
  """
  Container structure for job counts for a given user

  Attributes:
   - nPrep
   - nRunning
   - nSucceeded
   - nFailed
   - nKilled
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'nPrep', None, None, ), # 1
    (2, TType.I32, 'nRunning', None, None, ), # 2
    (3, TType.I32, 'nSucceeded', None, None, ), # 3
    (4, TType.I32, 'nFailed', None, None, ), # 4
    (5, TType.I32, 'nKilled', None, None, ), # 5
  )

  def __init__(self, nPrep=None, nRunning=None, nSucceeded=None, nFailed=None, nKilled=None,):
    self.nPrep = nPrep
    self.nRunning = nRunning
    self.nSucceeded = nSucceeded
    self.nFailed = nFailed
    self.nKilled = nKilled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.nPrep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.nRunning = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.nSucceeded = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.nFailed = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.nKilled = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftUserJobCounts')
    if self.nPrep is not None:
      oprot.writeFieldBegin('nPrep', TType.I32, 1)
      oprot.writeI32(self.nPrep)
      oprot.writeFieldEnd()
    if self.nRunning is not None:
      oprot.writeFieldBegin('nRunning', TType.I32, 2)
      oprot.writeI32(self.nRunning)
      oprot.writeFieldEnd()
    if self.nSucceeded is not None:
      oprot.writeFieldBegin('nSucceeded', TType.I32, 3)
      oprot.writeI32(self.nSucceeded)
      oprot.writeFieldEnd()
    if self.nFailed is not None:
      oprot.writeFieldBegin('nFailed', TType.I32, 4)
      oprot.writeI32(self.nFailed)
      oprot.writeFieldEnd()
    if self.nKilled is not None:
      oprot.writeFieldBegin('nKilled', TType.I32, 5)
      oprot.writeI32(self.nKilled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ThriftClusterStatus(object):
  """
  Status of the cluster as viewed by the jobtracker

  Attributes:
   - numActiveTrackers
   - activeTrackerNames
   - blacklistedTrackerNames
   - numBlacklistedTrackers
   - numExcludedNodes
   - taskTrackerExpiryInterval
   - mapTasks
   - reduceTasks
   - maxMapTasks
   - maxReduceTasks
   - state
   - usedMemory: Used and max memory for the cluster, in bytes
   - maxMemory
   - totalSubmissions
   - hasRestarted
   - hasRecovered
   - startTime
   - hostname
   - identifier
   - httpPort
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'numActiveTrackers', None, None, ), # 1
    (2, TType.LIST, 'activeTrackerNames', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'blacklistedTrackerNames', (TType.STRING,None), None, ), # 3
    (4, TType.I32, 'numBlacklistedTrackers', None, None, ), # 4
    (5, TType.I32, 'numExcludedNodes', None, None, ), # 5
    (6, TType.I64, 'taskTrackerExpiryInterval', None, None, ), # 6
    (7, TType.I32, 'mapTasks', None, None, ), # 7
    (8, TType.I32, 'reduceTasks', None, None, ), # 8
    (9, TType.I32, 'maxMapTasks', None, None, ), # 9
    (10, TType.I32, 'maxReduceTasks', None, None, ), # 10
    (11, TType.I32, 'state', None, None, ), # 11
    (12, TType.I64, 'usedMemory', None, None, ), # 12
    (13, TType.I64, 'maxMemory', None, None, ), # 13
    (14, TType.I32, 'totalSubmissions', None, None, ), # 14
    (15, TType.BOOL, 'hasRestarted', None, None, ), # 15
    (16, TType.BOOL, 'hasRecovered', None, None, ), # 16
    (17, TType.I64, 'startTime', None, None, ), # 17
    (18, TType.STRING, 'hostname', None, None, ), # 18
    (19, TType.STRING, 'identifier', None, None, ), # 19
    (20, TType.I32, 'httpPort', None, None, ), # 20
  )

  def __init__(self, numActiveTrackers=None, activeTrackerNames=None, blacklistedTrackerNames=None, numBlacklistedTrackers=None, numExcludedNodes=None, taskTrackerExpiryInterval=None, mapTasks=None, reduceTasks=None, maxMapTasks=None, maxReduceTasks=None, state=None, usedMemory=None, maxMemory=None, totalSubmissions=None, hasRestarted=None, hasRecovered=None, startTime=None, hostname=None, identifier=None, httpPort=None,):
    self.numActiveTrackers = numActiveTrackers
    self.activeTrackerNames = activeTrackerNames
    self.blacklistedTrackerNames = blacklistedTrackerNames
    self.numBlacklistedTrackers = numBlacklistedTrackers
    self.numExcludedNodes = numExcludedNodes
    self.taskTrackerExpiryInterval = taskTrackerExpiryInterval
    self.mapTasks = mapTasks
    self.reduceTasks = reduceTasks
    self.maxMapTasks = maxMapTasks
    self.maxReduceTasks = maxReduceTasks
    self.state = state
    self.usedMemory = usedMemory
    self.maxMemory = maxMemory
    self.totalSubmissions = totalSubmissions
    self.hasRestarted = hasRestarted
    self.hasRecovered = hasRecovered
    self.startTime = startTime
    self.hostname = hostname
    self.identifier = identifier
    self.httpPort = httpPort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.numActiveTrackers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.activeTrackerNames = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readString();
            self.activeTrackerNames.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.blacklistedTrackerNames = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = iprot.readString();
            self.blacklistedTrackerNames.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.numBlacklistedTrackers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.numExcludedNodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.taskTrackerExpiryInterval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.mapTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.reduceTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.maxMapTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.maxReduceTasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.usedMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.maxMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.totalSubmissions = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.hasRestarted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.hasRecovered = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.hostname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I32:
          self.httpPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ThriftClusterStatus')
    if self.numActiveTrackers is not None:
      oprot.writeFieldBegin('numActiveTrackers', TType.I32, 1)
      oprot.writeI32(self.numActiveTrackers)
      oprot.writeFieldEnd()
    if self.activeTrackerNames is not None:
      oprot.writeFieldBegin('activeTrackerNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.activeTrackerNames))
      for iter102 in self.activeTrackerNames:
        oprot.writeString(iter102)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.blacklistedTrackerNames is not None:
      oprot.writeFieldBegin('blacklistedTrackerNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.blacklistedTrackerNames))
      for iter103 in self.blacklistedTrackerNames:
        oprot.writeString(iter103)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.numBlacklistedTrackers is not None:
      oprot.writeFieldBegin('numBlacklistedTrackers', TType.I32, 4)
      oprot.writeI32(self.numBlacklistedTrackers)
      oprot.writeFieldEnd()
    if self.numExcludedNodes is not None:
      oprot.writeFieldBegin('numExcludedNodes', TType.I32, 5)
      oprot.writeI32(self.numExcludedNodes)
      oprot.writeFieldEnd()
    if self.taskTrackerExpiryInterval is not None:
      oprot.writeFieldBegin('taskTrackerExpiryInterval', TType.I64, 6)
      oprot.writeI64(self.taskTrackerExpiryInterval)
      oprot.writeFieldEnd()
    if self.mapTasks is not None:
      oprot.writeFieldBegin('mapTasks', TType.I32, 7)
      oprot.writeI32(self.mapTasks)
      oprot.writeFieldEnd()
    if self.reduceTasks is not None:
      oprot.writeFieldBegin('reduceTasks', TType.I32, 8)
      oprot.writeI32(self.reduceTasks)
      oprot.writeFieldEnd()
    if self.maxMapTasks is not None:
      oprot.writeFieldBegin('maxMapTasks', TType.I32, 9)
      oprot.writeI32(self.maxMapTasks)
      oprot.writeFieldEnd()
    if self.maxReduceTasks is not None:
      oprot.writeFieldBegin('maxReduceTasks', TType.I32, 10)
      oprot.writeI32(self.maxReduceTasks)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 11)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.usedMemory is not None:
      oprot.writeFieldBegin('usedMemory', TType.I64, 12)
      oprot.writeI64(self.usedMemory)
      oprot.writeFieldEnd()
    if self.maxMemory is not None:
      oprot.writeFieldBegin('maxMemory', TType.I64, 13)
      oprot.writeI64(self.maxMemory)
      oprot.writeFieldEnd()
    if self.totalSubmissions is not None:
      oprot.writeFieldBegin('totalSubmissions', TType.I32, 14)
      oprot.writeI32(self.totalSubmissions)
      oprot.writeFieldEnd()
    if self.hasRestarted is not None:
      oprot.writeFieldBegin('hasRestarted', TType.BOOL, 15)
      oprot.writeBool(self.hasRestarted)
      oprot.writeFieldEnd()
    if self.hasRecovered is not None:
      oprot.writeFieldBegin('hasRecovered', TType.BOOL, 16)
      oprot.writeBool(self.hasRecovered)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 17)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 18)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 19)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    if self.httpPort is not None:
      oprot.writeFieldBegin('httpPort', TType.I32, 20)
      oprot.writeI32(self.httpPort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobNotFoundException(TException):
  """
  Merely an indicator that job wasn't found.
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobNotFoundException')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskNotFoundException(TException):
  """
  Merely an indicator that task wasn't found.
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskNotFoundException')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskAttemptNotFoundException(TException):
  """
  Indicates that a task attempt wasn't found
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskAttemptNotFoundException')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskTrackerNotFoundException(TException):
  """
  Indicates that a tasktracker wasn't found
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskTrackerNotFoundException')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
