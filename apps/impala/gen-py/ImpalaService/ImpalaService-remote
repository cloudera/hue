#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

import sys
import pprint
from urlparse import urlparse
from thrift.transport import TTransport
from thrift.transport import TSocket
from thrift.transport import TSSLSocket
from thrift.transport import THttpClient
from thrift.protocol import TBinaryProtocol

from ImpalaService import ImpalaService
from ImpalaService.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
  print('')
  print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] function [arg1 [arg2...]]')
  print('')
  print('Functions:')
  print('  TStatus Cancel(QueryHandle query_id)')
  print('  TStatus ResetCatalog()')
  print('  TStatus ResetTable(TResetTableReq request)')
  print('  string GetRuntimeProfile(QueryHandle query_id)')
  print('  TInsertResult CloseInsert(QueryHandle handle)')
  print('  TPingImpalaServiceResp PingImpalaService()')
  print('  TExecSummary GetExecSummary(QueryHandle handle)')
  print('  QueryHandle query(Query query)')
  print('  QueryHandle executeAndWait(Query query, LogContextId clientCtx)')
  print('  QueryExplanation explain(Query query)')
  print('  Results fetch(QueryHandle query_id, bool start_over, i32 fetch_size)')
  print('  QueryState get_state(QueryHandle handle)')
  print('  ResultsMetadata get_results_metadata(QueryHandle handle)')
  print('  string echo(string s)')
  print('  string dump_config()')
  print('  string get_log(LogContextId context)')
  print('   get_default_configuration(bool include_hadoop)')
  print('  void close(QueryHandle handle)')
  print('  void clean(LogContextId log_context)')
  print('')
  sys.exit(0)

pp = pprint.PrettyPrinter(indent = 2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
http = False
argi = 1

if sys.argv[argi] == '-h':
  parts = sys.argv[argi+1].split(':')
  host = parts[0]
  if len(parts) > 1:
    port = int(parts[1])
  argi += 2

if sys.argv[argi] == '-u':
  url = urlparse(sys.argv[argi+1])
  parts = url[1].split(':')
  host = parts[0]
  if len(parts) > 1:
    port = int(parts[1])
  else:
    port = 80
  uri = url[2]
  if url[4]:
    uri += '?%s' % url[4]
  http = True
  argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
  framed = True
  argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
  ssl = True
  argi += 1

cmd = sys.argv[argi]
args = sys.argv[argi+1:]

if http:
  transport = THttpClient.THttpClient(host, port, uri)
else:
  socket = TSSLSocket.TSSLSocket(host, port, validate=False) if ssl else TSocket.TSocket(host, port)
  if framed:
    transport = TTransport.TFramedTransport(socket)
  else:
    transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol.TBinaryProtocol(transport)
client = ImpalaService.Client(protocol)
transport.open()

if cmd == 'Cancel':
  if len(args) != 1:
    print('Cancel requires 1 args')
    sys.exit(1)
  pp.pprint(client.Cancel(eval(args[0]),))

elif cmd == 'ResetCatalog':
  if len(args) != 0:
    print('ResetCatalog requires 0 args')
    sys.exit(1)
  pp.pprint(client.ResetCatalog())

elif cmd == 'ResetTable':
  if len(args) != 1:
    print('ResetTable requires 1 args')
    sys.exit(1)
  pp.pprint(client.ResetTable(eval(args[0]),))

elif cmd == 'GetRuntimeProfile':
  if len(args) != 1:
    print('GetRuntimeProfile requires 1 args')
    sys.exit(1)
  pp.pprint(client.GetRuntimeProfile(eval(args[0]),))

elif cmd == 'CloseInsert':
  if len(args) != 1:
    print('CloseInsert requires 1 args')
    sys.exit(1)
  pp.pprint(client.CloseInsert(eval(args[0]),))

elif cmd == 'PingImpalaService':
  if len(args) != 0:
    print('PingImpalaService requires 0 args')
    sys.exit(1)
  pp.pprint(client.PingImpalaService())

elif cmd == 'GetExecSummary':
  if len(args) != 1:
    print('GetExecSummary requires 1 args')
    sys.exit(1)
  pp.pprint(client.GetExecSummary(eval(args[0]),))

elif cmd == 'query':
  if len(args) != 1:
    print('query requires 1 args')
    sys.exit(1)
  pp.pprint(client.query(eval(args[0]),))

elif cmd == 'executeAndWait':
  if len(args) != 2:
    print('executeAndWait requires 2 args')
    sys.exit(1)
  pp.pprint(client.executeAndWait(eval(args[0]),eval(args[1]),))

elif cmd == 'explain':
  if len(args) != 1:
    print('explain requires 1 args')
    sys.exit(1)
  pp.pprint(client.explain(eval(args[0]),))

elif cmd == 'fetch':
  if len(args) != 3:
    print('fetch requires 3 args')
    sys.exit(1)
  pp.pprint(client.fetch(eval(args[0]),eval(args[1]),eval(args[2]),))

elif cmd == 'get_state':
  if len(args) != 1:
    print('get_state requires 1 args')
    sys.exit(1)
  pp.pprint(client.get_state(eval(args[0]),))

elif cmd == 'get_results_metadata':
  if len(args) != 1:
    print('get_results_metadata requires 1 args')
    sys.exit(1)
  pp.pprint(client.get_results_metadata(eval(args[0]),))

elif cmd == 'echo':
  if len(args) != 1:
    print('echo requires 1 args')
    sys.exit(1)
  pp.pprint(client.echo(args[0],))

elif cmd == 'dump_config':
  if len(args) != 0:
    print('dump_config requires 0 args')
    sys.exit(1)
  pp.pprint(client.dump_config())

elif cmd == 'get_log':
  if len(args) != 1:
    print('get_log requires 1 args')
    sys.exit(1)
  pp.pprint(client.get_log(eval(args[0]),))

elif cmd == 'get_default_configuration':
  if len(args) != 1:
    print('get_default_configuration requires 1 args')
    sys.exit(1)
  pp.pprint(client.get_default_configuration(eval(args[0]),))

elif cmd == 'close':
  if len(args) != 1:
    print('close requires 1 args')
    sys.exit(1)
  pp.pprint(client.close(eval(args[0]),))

elif cmd == 'clean':
  if len(args) != 1:
    print('clean requires 1 args')
    sys.exit(1)
  pp.pprint(client.clean(eval(args[0]),))

else:
  print('Unrecognized method %s' % cmd)
  sys.exit(1)

transport.close()
